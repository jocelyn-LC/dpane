import { defineComponent as tI, ref as nI, onMounted as iI, onUnmounted as rI, openBlock as oI, createElementBlock as aI, normalizeClass as I_, createElementVNode as sI } from "../vue.esm-browser.prod.js";
import { v as uI } from "./index.effbeeae.es.js";
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var lI = globalThis && globalThis.__extends || function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var o in r)
        r.hasOwnProperty(o) && (i[o] = r[o]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function i() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i());
  };
}(), cI = Object.prototype.hasOwnProperty;
function W1(e, t) {
  return cI.call(e, t);
}
function G1(e) {
  if (Array.isArray(e)) {
    for (var t = new Array(e.length), n = 0; n < t.length; n++)
      t[n] = "" + n;
    return t;
  }
  if (Object.keys)
    return Object.keys(e);
  var i = [];
  for (var r in e)
    W1(e, r) && i.push(r);
  return i;
}
function In(e) {
  switch (typeof e) {
    case "object":
      return JSON.parse(JSON.stringify(e));
    case "undefined":
      return null;
    default:
      return e;
  }
}
function H1(e) {
  for (var t = 0, n = e.length, i; t < n; ) {
    if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
      t++;
      continue;
    }
    return !1;
  }
  return !0;
}
function Da(e) {
  return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
function pF(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
function Y1(e) {
  if (e === void 0)
    return !0;
  if (e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = e.length; t < n; t++)
        if (Y1(e[t]))
          return !0;
    } else if (typeof e == "object") {
      for (var i = G1(e), r = i.length, o = 0; o < r; o++)
        if (Y1(e[i[o]]))
          return !0;
    }
  }
  return !1;
}
function P_(e, t) {
  var n = [e];
  for (var i in t) {
    var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
    typeof r < "u" && n.push(i + ": " + r);
  }
  return n.join(`
`);
}
var gF = function(e) {
  lI(t, e);
  function t(n, i, r, o, a) {
    var s = this.constructor, u = e.call(this, P_(n, { name: i, index: r, operation: o, tree: a })) || this;
    return u.name = i, u.index = r, u.operation = o, u.tree = a, Object.setPrototypeOf(u, s.prototype), u.message = P_(n, { name: i, index: r, operation: o, tree: a }), u;
  }
  return t;
}(Error), Ke = gF, fI = In, uu = {
  add: function(e, t, n) {
    return e[t] = this.value, { newDocument: n };
  },
  remove: function(e, t, n) {
    var i = e[t];
    return delete e[t], { newDocument: n, removed: i };
  },
  replace: function(e, t, n) {
    var i = e[t];
    return e[t] = this.value, { newDocument: n, removed: i };
  },
  move: function(e, t, n) {
    var i = $h(n, this.path);
    i && (i = In(i));
    var r = Va(n, { op: "remove", path: this.from }).removed;
    return Va(n, { op: "add", path: this.path, value: r }), { newDocument: n, removed: i };
  },
  copy: function(e, t, n) {
    var i = $h(n, this.from);
    return Va(n, { op: "add", path: this.path, value: In(i) }), { newDocument: n };
  },
  test: function(e, t, n) {
    return { newDocument: n, test: Gc(e[t], this.value) };
  },
  _get: function(e, t, n) {
    return this.value = e[t], { newDocument: n };
  }
}, dI = {
  add: function(e, t, n) {
    return H1(t) ? e.splice(t, 0, this.value) : e[t] = this.value, { newDocument: n, index: t };
  },
  remove: function(e, t, n) {
    var i = e.splice(t, 1);
    return { newDocument: n, removed: i[0] };
  },
  replace: function(e, t, n) {
    var i = e[t];
    return e[t] = this.value, { newDocument: n, removed: i };
  },
  move: uu.move,
  copy: uu.copy,
  test: uu.test,
  _get: uu._get
};
function $h(e, t) {
  if (t == "")
    return e;
  var n = { op: "_get", path: t };
  return Va(e, n), n.value;
}
function Va(e, t, n, i, r, o) {
  if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), o === void 0 && (o = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : kh(t, 0)), t.path === "") {
    var a = { newDocument: e };
    if (t.op === "add")
      return a.newDocument = t.value, a;
    if (t.op === "replace")
      return a.newDocument = t.value, a.removed = e, a;
    if (t.op === "move" || t.op === "copy")
      return a.newDocument = $h(e, t.from), t.op === "move" && (a.removed = e), a;
    if (t.op === "test") {
      if (a.test = Gc(e, t.value), a.test === !1)
        throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
      return a.newDocument = e, a;
    } else {
      if (t.op === "remove")
        return a.removed = e, a.newDocument = null, a;
      if (t.op === "_get")
        return t.value = e, a;
      if (n)
        throw new Ke("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", o, t, e);
      return a;
    }
  } else {
    i || (e = In(e));
    var s = t.path || "", u = s.split("/"), l = e, c = 1, f = u.length, d = void 0, h = void 0, p = void 0;
    for (typeof n == "function" ? p = n : p = kh; ; ) {
      if (h = u[c], h && h.indexOf("~") != -1 && (h = pF(h)), r && (h == "__proto__" || h == "prototype" && c > 0 && u[c - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && d === void 0 && (l[h] === void 0 ? d = u.slice(0, c).join("/") : c == f - 1 && (d = t.path), d !== void 0 && p(t, 0, e, d)), c++, Array.isArray(l)) {
        if (h === "-")
          h = l.length;
        else {
          if (n && !H1(h))
            throw new Ke("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", o, t, e);
          H1(h) && (h = ~~h);
        }
        if (c >= f) {
          if (n && t.op === "add" && h > l.length)
            throw new Ke("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", o, t, e);
          var a = dI[t.op].call(t, l, h, e);
          if (a.test === !1)
            throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
          return a;
        }
      } else if (c >= f) {
        var a = uu[t.op].call(t, l, h, e);
        if (a.test === !1)
          throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", o, t, e);
        return a;
      }
      if (l = l[h], n && c < f && (!l || typeof l != "object"))
        throw new Ke("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", o, t, e);
    }
  }
}
function cg(e, t, n, i, r) {
  if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t))
    throw new Ke("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  i || (e = In(e));
  for (var o = new Array(t.length), a = 0, s = t.length; a < s; a++)
    o[a] = Va(e, t[a], n, !0, r, a), e = o[a].newDocument;
  return o.newDocument = e, o;
}
function hI(e, t, n) {
  var i = Va(e, t);
  if (i.test === !1)
    throw new Ke("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
  return i.newDocument;
}
function kh(e, t, n, i) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new Ke("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
  if (uu[e.op]) {
    if (typeof e.path != "string")
      throw new Ke("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
    if (e.path.indexOf("/") !== 0 && e.path.length > 0)
      throw new Ke('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
    if ((e.op === "move" || e.op === "copy") && typeof e.from != "string")
      throw new Ke("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0)
      throw new Ke("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && Y1(e.value))
      throw new Ke("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
    if (n) {
      if (e.op == "add") {
        var r = e.path.split("/").length, o = i.split("/").length;
        if (r !== o + 1 && r !== o)
          throw new Ke("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
      } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
        if (e.path !== i)
          throw new Ke("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
      } else if (e.op === "move" || e.op === "copy") {
        var a = { op: "_get", path: e.from, value: void 0 }, s = mF([a], n);
        if (s && s.name === "OPERATION_PATH_UNRESOLVABLE")
          throw new Ke("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
      }
    }
  } else
    throw new Ke("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
}
function mF(e, t, n) {
  try {
    if (!Array.isArray(e))
      throw new Ke("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (t)
      cg(In(t), In(e), n || !0);
    else {
      n = n || kh;
      for (var i = 0; i < e.length; i++)
        n(e[i], i, t, void 0);
    }
  } catch (r) {
    if (r instanceof Ke)
      return r;
    throw r;
  }
}
function Gc(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    var n = Array.isArray(e), i = Array.isArray(t), r, o, a;
    if (n && i) {
      if (o = e.length, o != t.length)
        return !1;
      for (r = o; r-- !== 0; )
        if (!Gc(e[r], t[r]))
          return !1;
      return !0;
    }
    if (n != i)
      return !1;
    var s = Object.keys(e);
    if (o = s.length, o !== Object.keys(t).length)
      return !1;
    for (r = o; r-- !== 0; )
      if (!t.hasOwnProperty(s[r]))
        return !1;
    for (r = o; r-- !== 0; )
      if (a = s[r], !Gc(e[a], t[a]))
        return !1;
    return !0;
  }
  return e !== e && t !== t;
}
const pI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JsonPatchError: Ke,
  deepClone: fI,
  getValueByPointer: $h,
  applyOperation: Va,
  applyPatch: cg,
  applyReducer: hI,
  validator: kh,
  validate: mF,
  _areEquals: Gc
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
var ob = /* @__PURE__ */ new WeakMap(), gI = function() {
  function e(t) {
    this.observers = /* @__PURE__ */ new Map(), this.obj = t;
  }
  return e;
}(), mI = function() {
  function e(t, n) {
    this.callback = t, this.observer = n;
  }
  return e;
}();
function yI(e) {
  return ob.get(e);
}
function vI(e, t) {
  return e.observers.get(t);
}
function bI(e, t) {
  e.observers.delete(t.callback);
}
function xI(e, t) {
  t.unobserve();
}
function wI(e, t) {
  var n = [], i, r = yI(e);
  if (!r)
    r = new gI(e), ob.set(e, r);
  else {
    var o = vI(r, t);
    i = o && o.observer;
  }
  if (i)
    return i;
  if (i = {}, r.value = In(e), t) {
    i.callback = t, i.next = null;
    var a = function() {
      X1(i);
    }, s = function() {
      clearTimeout(i.next), i.next = setTimeout(a);
    };
    typeof window < "u" && (window.addEventListener("mouseup", s), window.addEventListener("keyup", s), window.addEventListener("mousedown", s), window.addEventListener("keydown", s), window.addEventListener("change", s));
  }
  return i.patches = n, i.object = e, i.unobserve = function() {
    X1(i), clearTimeout(i.next), bI(r, i), typeof window < "u" && (window.removeEventListener("mouseup", s), window.removeEventListener("keyup", s), window.removeEventListener("mousedown", s), window.removeEventListener("keydown", s), window.removeEventListener("change", s));
  }, r.observers.set(t, new mI(t, i)), i;
}
function X1(e, t) {
  t === void 0 && (t = !1);
  var n = ob.get(e.object);
  ab(n.value, e.object, e.patches, "", t), e.patches.length && cg(n.value, e.patches);
  var i = e.patches;
  return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i;
}
function ab(e, t, n, i, r) {
  if (t !== e) {
    typeof t.toJSON == "function" && (t = t.toJSON());
    for (var o = G1(t), a = G1(e), s = !1, u = a.length - 1; u >= 0; u--) {
      var l = a[u], c = e[l];
      if (W1(t, l) && !(t[l] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
        var f = t[l];
        typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? ab(c, f, n, i + "/" + Da(l), r) : c !== f && (r && n.push({ op: "test", path: i + "/" + Da(l), value: In(c) }), n.push({ op: "replace", path: i + "/" + Da(l), value: In(f) }));
      } else
        Array.isArray(e) === Array.isArray(t) ? (r && n.push({ op: "test", path: i + "/" + Da(l), value: In(c) }), n.push({ op: "remove", path: i + "/" + Da(l) }), s = !0) : (r && n.push({ op: "test", path: i, value: e }), n.push({ op: "replace", path: i, value: t }));
    }
    if (!(!s && o.length == a.length))
      for (var u = 0; u < o.length; u++) {
        var l = o[u];
        !W1(e, l) && t[l] !== void 0 && n.push({ op: "add", path: i + "/" + Da(l), value: In(t[l]) });
      }
  }
}
function EI(e, t, n) {
  n === void 0 && (n = !1);
  var i = [];
  return ab(e, t, i, "", n), i;
}
const _I = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  unobserve: xI,
  observe: wI,
  generate: X1,
  compare: EI
}, Symbol.toStringTag, { value: "Module" }));
Object.assign({}, pI, _I, {
  JsonPatchError: gF,
  deepClone: In,
  escapePathComponent: Da,
  unescapePathComponent: pF
});
var SI = /("(?:[^\\"]|\\.)*")|[:,]/g, m0 = function(t, n) {
  var i, r, o;
  return n = n || {}, i = JSON.stringify(
    [1],
    void 0,
    n.indent === void 0 ? 2 : n.indent
  ).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, o = n.replacer, function a(s, u, l) {
    var c, f, d, h, p, g, m, y, v, b, x, E;
    if (s && typeof s.toJSON == "function" && (s = s.toJSON()), x = JSON.stringify(s, o), x === void 0)
      return x;
    if (m = r - u.length - l, x.length <= m && (v = x.replace(
      SI,
      function(_, w) {
        return w || _ + " ";
      }
    ), v.length <= m))
      return v;
    if (o != null && (s = JSON.parse(x), o = void 0), typeof s == "object" && s !== null) {
      if (y = u + i, d = [], f = 0, Array.isArray(s))
        for (b = "[", c = "]", m = s.length; f < m; f++)
          d.push(
            a(s[f], y, f === m - 1 ? 0 : 1) || "null"
          );
      else
        for (b = "{", c = "}", g = Object.keys(s), m = g.length; f < m; f++)
          h = g[f], p = JSON.stringify(h) + ": ", E = a(
            s[h],
            y,
            p.length + (f === m - 1 ? 0 : 1)
          ), E !== void 0 && d.push(p + E);
      if (d.length > 0)
        return [b, i + d.join(`,
` + y), c].join(
          `
` + u
        );
    }
    return x;
  }(t, "", 0);
};
function Fn(e, t, n) {
  return e.fields = t || [], e.fname = n, e;
}
function Ze(e) {
  return e == null ? null : e.fname;
}
function Bt(e) {
  return e == null ? null : e.fields;
}
function yF(e) {
  return e.length === 1 ? AI(e[0]) : $I(e);
}
const AI = (e) => function(t) {
  return t[e];
}, $I = (e) => {
  const t = e.length;
  return function(n) {
    for (let i = 0; i < t; ++i)
      n = n[e[i]];
    return n;
  };
};
function I(e) {
  throw Error(e);
}
function Er(e) {
  const t = [], n = e.length;
  let i = null, r = 0, o = "", a, s, u;
  e = e + "";
  function l() {
    t.push(o + e.substring(a, s)), o = "", a = s + 1;
  }
  for (a = s = 0; s < n; ++s)
    if (u = e[s], u === "\\")
      o += e.substring(a, s++), a = s;
    else if (u === i)
      l(), i = null, r = -1;
    else {
      if (i)
        continue;
      a === r && u === '"' || a === r && u === "'" ? (a = s + 1, i = u) : u === "." && !r ? s > a ? l() : a = s + 1 : u === "[" ? (s > a && l(), r = a = s + 1) : u === "]" && (r || I("Access path missing open bracket: " + e), r > 0 && l(), r = 0, a = s + 1);
    }
  return r && I("Access path missing closing bracket: " + e), i && I("Access path missing closing quote: " + e), s > a && (s++, l()), t;
}
function En(e, t, n) {
  const i = Er(e);
  return e = i.length === 1 ? i[0] : e, Fn((n && n.get || yF)(i), [e], t || e);
}
const _f = En("id"), Wt = Fn((e) => e, [], "identity"), Co = Fn(() => 0, [], "zero"), ul = Fn(() => 1, [], "one"), ei = Fn(() => !0, [], "true"), xo = Fn(() => !1, [], "false");
function kI(e, t, n) {
  const i = [t].concat([].slice.call(n));
  console[e].apply(console, i);
}
const vF = 0, sb = 1, ub = 2, bF = 3, xF = 4;
function lb(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : kI, i = e || vF;
  return {
    level(r) {
      return arguments.length ? (i = +r, this) : i;
    },
    error() {
      return i >= sb && n(t || "error", "ERROR", arguments), this;
    },
    warn() {
      return i >= ub && n(t || "warn", "WARN", arguments), this;
    },
    info() {
      return i >= bF && n(t || "log", "INFO", arguments), this;
    },
    debug() {
      return i >= xF && n(t || "log", "DEBUG", arguments), this;
    }
  };
}
var P = Array.isArray;
function K(e) {
  return e === Object(e);
}
const z_ = (e) => e !== "__proto__";
function ll() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t.reduce((i, r) => {
    for (const o in r)
      if (o === "signals")
        i.signals = CI(i.signals, r.signals);
      else {
        const a = o === "legend" ? {
          layout: 1
        } : o === "style" ? !0 : null;
        cl(i, o, r[o], a);
      }
    return i;
  }, {});
}
function cl(e, t, n, i) {
  if (!z_(t))
    return;
  let r, o;
  if (K(n) && !P(n)) {
    o = K(e[t]) ? e[t] : e[t] = {};
    for (r in n)
      i && (i === !0 || i[r]) ? cl(o, r, n[r]) : z_(r) && (o[r] = n[r]);
  } else
    e[t] = n;
}
function CI(e, t) {
  if (e == null)
    return t;
  const n = {}, i = [];
  function r(o) {
    n[o.name] || (n[o.name] = 1, i.push(o));
  }
  return t.forEach(r), e.forEach(r), i;
}
function xe(e) {
  return e[e.length - 1];
}
function It(e) {
  return e == null || e === "" ? null : +e;
}
const wF = (e) => (t) => e * Math.exp(t), EF = (e) => (t) => Math.log(e * t), _F = (e) => (t) => Math.sign(t) * Math.log1p(Math.abs(t / e)), SF = (e) => (t) => Math.sign(t) * Math.expm1(Math.abs(t)) * e, Ch = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
function fg(e, t, n, i) {
  const r = n(e[0]), o = n(xe(e)), a = (o - r) * t;
  return [i(r - a), i(o - a)];
}
function AF(e, t) {
  return fg(e, t, It, Wt);
}
function $F(e, t) {
  var n = Math.sign(e[0]);
  return fg(e, t, EF(n), wF(n));
}
function kF(e, t, n) {
  return fg(e, t, Ch(n), Ch(1 / n));
}
function CF(e, t, n) {
  return fg(e, t, _F(n), SF(n));
}
function dg(e, t, n, i, r) {
  const o = i(e[0]), a = i(xe(e)), s = t != null ? i(t) : (o + a) / 2;
  return [r(s + (o - s) * n), r(s + (a - s) * n)];
}
function cb(e, t, n) {
  return dg(e, t, n, It, Wt);
}
function fb(e, t, n) {
  const i = Math.sign(e[0]);
  return dg(e, t, n, EF(i), wF(i));
}
function Fh(e, t, n, i) {
  return dg(e, t, n, Ch(i), Ch(1 / i));
}
function db(e, t, n, i) {
  return dg(e, t, n, _F(i), SF(i));
}
function FF(e) {
  return 1 + ~~(new Date(e).getMonth() / 3);
}
function MF(e) {
  return 1 + ~~(new Date(e).getUTCMonth() / 3);
}
function X(e) {
  return e != null ? P(e) ? e : [e] : [];
}
function TF(e, t, n) {
  let i = e[0], r = e[1], o;
  return r < i && (o = r, r = i, i = o), o = r - i, o >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - o), i + o];
}
function fe(e) {
  return typeof e == "function";
}
const FI = "descending";
function hb(e, t, n) {
  n = n || {}, t = X(t) || [];
  const i = [], r = [], o = {}, a = n.comparator || MI;
  return X(e).forEach((s, u) => {
    s != null && (i.push(t[u] === FI ? -1 : 1), r.push(s = fe(s) ? s : En(s, null, n)), (Bt(s) || []).forEach((l) => o[l] = 1));
  }), r.length === 0 ? null : Fn(a(r, i), Object.keys(o));
}
const hg = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0), MI = (e, t) => e.length === 1 ? TI(e[0], t[0]) : OI(e, t, e.length), TI = (e, t) => function(n, i) {
  return hg(e(n), e(i)) * t;
}, OI = (e, t, n) => (t.push(0), function(i, r) {
  let o, a = 0, s = -1;
  for (; a === 0 && ++s < n; )
    o = e[s], a = hg(o(i), o(r));
  return a * t[s];
});
function Gt(e) {
  return fe(e) ? e : () => e;
}
function pb(e, t) {
  let n;
  return (i) => {
    n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e);
  };
}
function ce(e) {
  for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
    t = arguments[i];
    for (n in t)
      e[n] = t[n];
  }
  return e;
}
function hr(e, t) {
  let n = 0, i, r, o, a;
  if (e && (i = e.length))
    if (t == null) {
      for (r = e[n]; n < i && (r == null || r !== r); r = e[++n])
        ;
      for (o = a = r; n < i; ++n)
        r = e[n], r != null && (r < o && (o = r), r > a && (a = r));
    } else {
      for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n]))
        ;
      for (o = a = r; n < i; ++n)
        r = t(e[n]), r != null && (r < o && (o = r), r > a && (a = r));
    }
  return [o, a];
}
function OF(e, t) {
  const n = e.length;
  let i = -1, r, o, a, s, u;
  if (t == null) {
    for (; ++i < n; )
      if (o = e[i], o != null && o >= o) {
        r = a = o;
        break;
      }
    if (i === n)
      return [-1, -1];
    for (s = u = i; ++i < n; )
      o = e[i], o != null && (r > o && (r = o, s = i), a < o && (a = o, u = i));
  } else {
    for (; ++i < n; )
      if (o = t(e[i], i, e), o != null && o >= o) {
        r = a = o;
        break;
      }
    if (i === n)
      return [-1, -1];
    for (s = u = i; ++i < n; )
      o = t(e[i], i, e), o != null && (r > o && (r = o, s = i), a < o && (a = o, u = i));
  }
  return [s, u];
}
const NI = Object.prototype.hasOwnProperty;
function ie(e, t) {
  return NI.call(e, t);
}
const pd = {};
function fl(e) {
  let t = {}, n;
  function i(o) {
    return ie(t, o) && t[o] !== pd;
  }
  const r = {
    size: 0,
    empty: 0,
    object: t,
    has: i,
    get(o) {
      return i(o) ? t[o] : void 0;
    },
    set(o, a) {
      return i(o) || (++r.size, t[o] === pd && --r.empty), t[o] = a, this;
    },
    delete(o) {
      return i(o) && (--r.size, ++r.empty, t[o] = pd), this;
    },
    clear() {
      r.size = r.empty = 0, r.object = t = {};
    },
    test(o) {
      return arguments.length ? (n = o, r) : n;
    },
    clean() {
      const o = {};
      let a = 0;
      for (const s in t) {
        const u = t[s];
        u !== pd && (!n || !n(u)) && (o[s] = u, ++a);
      }
      r.size = a, r.empty = 0, r.object = t = o;
    }
  };
  return e && Object.keys(e).forEach((o) => {
    r.set(o, e[o]);
  }), r;
}
function NF(e, t, n, i, r, o) {
  if (!n && n !== 0)
    return o;
  const a = +n;
  let s = e[0], u = xe(e), l;
  u < s && (l = s, s = u, u = l), l = Math.abs(t - s);
  const c = Math.abs(u - t);
  return l < c && l <= a ? i : c <= a ? r : o;
}
function G(e, t, n) {
  const i = e.prototype = Object.create(t.prototype);
  return Object.defineProperty(i, "constructor", {
    value: e,
    writable: !0,
    enumerable: !0,
    configurable: !0
  }), ce(i, n);
}
function lu(e, t, n, i) {
  let r = t[0], o = t[t.length - 1], a;
  return r > o && (a = r, r = o, o = a), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= o : e < o);
}
function ua(e) {
  return typeof e == "boolean";
}
function zo(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function DF(e) {
  return e && fe(e[Symbol.iterator]);
}
function Oe(e) {
  return typeof e == "number";
}
function RF(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function Y(e) {
  return typeof e == "string";
}
function gb(e, t, n) {
  e && (e = t ? X(e).map((s) => s.replace(/\\(.)/g, "$1")) : X(e));
  const i = e && e.length, r = n && n.get || yF, o = (s) => r(t ? [s] : Er(s));
  let a;
  if (!i)
    a = function() {
      return "";
    };
  else if (i === 1) {
    const s = o(e[0]);
    a = function(u) {
      return "" + s(u);
    };
  } else {
    const s = e.map(o);
    a = function(u) {
      let l = "" + s[0](u), c = 0;
      for (; ++c < i; )
        l += "|" + s[c](u);
      return l;
    };
  }
  return Fn(a, e, "key");
}
function LF(e, t) {
  const n = e[0], i = xe(e), r = +t;
  return r ? r === 1 ? i : n + r * (i - n) : n;
}
const DI = 1e4;
function IF(e) {
  e = +e || DI;
  let t, n, i;
  const r = () => {
    t = {}, n = {}, i = 0;
  }, o = (a, s) => (++i > e && (n = t, t = {}, i = 1), t[a] = s);
  return r(), {
    clear: r,
    has: (a) => ie(t, a) || ie(n, a),
    get: (a) => ie(t, a) ? t[a] : ie(n, a) ? o(a, n[a]) : void 0,
    set: (a, s) => ie(t, a) ? t[a] = s : o(a, s)
  };
}
function PF(e, t, n, i) {
  const r = t.length, o = n.length;
  if (!o)
    return t;
  if (!r)
    return n;
  const a = i || new t.constructor(r + o);
  let s = 0, u = 0, l = 0;
  for (; s < r && u < o; ++l)
    a[l] = e(t[s], n[u]) > 0 ? n[u++] : t[s++];
  for (; s < r; ++s, ++l)
    a[l] = t[s];
  for (; u < o; ++u, ++l)
    a[l] = n[u];
  return a;
}
function sc(e, t) {
  let n = "";
  for (; --t >= 0; )
    n += e;
  return n;
}
function zF(e, t, n, i) {
  const r = n || " ", o = e + "", a = t - o.length;
  return a <= 0 ? o : i === "left" ? sc(r, a) + o : i === "center" ? sc(r, ~~(a / 2)) + o + sc(r, Math.ceil(a / 2)) : o + sc(r, a);
}
function Sf(e) {
  return e && xe(e) - e[0] || 0;
}
function W(e) {
  return P(e) ? "[" + e.map(W) + "]" : K(e) || Y(e) ? JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : e;
}
function mb(e) {
  return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e;
}
const RI = (e) => Oe(e) || zo(e) ? e : Date.parse(e);
function yb(e, t) {
  return t = t || RI, e == null || e === "" ? null : t(e);
}
function vb(e) {
  return e == null || e === "" ? null : e + "";
}
function Oi(e) {
  const t = {}, n = e.length;
  for (let i = 0; i < n; ++i)
    t[e[i]] = !0;
  return t;
}
function BF(e, t, n, i) {
  const r = i != null ? i : "\u2026", o = e + "", a = o.length, s = Math.max(0, t - r.length);
  return a <= t ? o : n === "left" ? r + o.slice(a - s) : n === "center" ? o.slice(0, Math.ceil(s / 2)) + r + o.slice(a - ~~(s / 2)) : o.slice(0, s) + r;
}
function _o(e, t, n) {
  if (e)
    if (t) {
      const i = e.length;
      for (let r = 0; r < i; ++r) {
        const o = t(e[r]);
        o && n(o, r, e);
      }
    } else
      e.forEach(n);
}
var B_ = {}, y0 = {}, v0 = 34, Rl = 10, b0 = 13;
function jF(e) {
  return new Function("d", "return {" + e.map(function(t, n) {
    return JSON.stringify(t) + ": d[" + n + '] || ""';
  }).join(",") + "}");
}
function LI(e, t) {
  var n = jF(e);
  return function(i, r) {
    return t(n(i), r, e);
  };
}
function j_(e) {
  var t = /* @__PURE__ */ Object.create(null), n = [];
  return e.forEach(function(i) {
    for (var r in i)
      r in t || n.push(t[r] = r);
  }), n;
}
function fn(e, t) {
  var n = e + "", i = n.length;
  return i < t ? new Array(t - i + 1).join(0) + n : n;
}
function II(e) {
  return e < 0 ? "-" + fn(-e, 6) : e > 9999 ? "+" + fn(e, 6) : fn(e, 4);
}
function PI(e) {
  var t = e.getUTCHours(), n = e.getUTCMinutes(), i = e.getUTCSeconds(), r = e.getUTCMilliseconds();
  return isNaN(e) ? "Invalid Date" : II(e.getUTCFullYear()) + "-" + fn(e.getUTCMonth() + 1, 2) + "-" + fn(e.getUTCDate(), 2) + (r ? "T" + fn(t, 2) + ":" + fn(n, 2) + ":" + fn(i, 2) + "." + fn(r, 3) + "Z" : i ? "T" + fn(t, 2) + ":" + fn(n, 2) + ":" + fn(i, 2) + "Z" : n || t ? "T" + fn(t, 2) + ":" + fn(n, 2) + "Z" : "");
}
function zI(e) {
  var t = new RegExp('["' + e + `
\r]`), n = e.charCodeAt(0);
  function i(f, d) {
    var h, p, g = r(f, function(m, y) {
      if (h)
        return h(m, y - 1);
      p = m, h = d ? LI(m, d) : jF(m);
    });
    return g.columns = p || [], g;
  }
  function r(f, d) {
    var h = [], p = f.length, g = 0, m = 0, y, v = p <= 0, b = !1;
    f.charCodeAt(p - 1) === Rl && --p, f.charCodeAt(p - 1) === b0 && --p;
    function x() {
      if (v)
        return y0;
      if (b)
        return b = !1, B_;
      var _, w = g, S;
      if (f.charCodeAt(w) === v0) {
        for (; g++ < p && f.charCodeAt(g) !== v0 || f.charCodeAt(++g) === v0; )
          ;
        return (_ = g) >= p ? v = !0 : (S = f.charCodeAt(g++)) === Rl ? b = !0 : S === b0 && (b = !0, f.charCodeAt(g) === Rl && ++g), f.slice(w + 1, _ - 1).replace(/""/g, '"');
      }
      for (; g < p; ) {
        if ((S = f.charCodeAt(_ = g++)) === Rl)
          b = !0;
        else if (S === b0)
          b = !0, f.charCodeAt(g) === Rl && ++g;
        else if (S !== n)
          continue;
        return f.slice(w, _);
      }
      return v = !0, f.slice(w, p);
    }
    for (; (y = x()) !== y0; ) {
      for (var E = []; y !== B_ && y !== y0; )
        E.push(y), y = x();
      d && (E = d(E, m++)) == null || h.push(E);
    }
    return h;
  }
  function o(f, d) {
    return f.map(function(h) {
      return d.map(function(p) {
        return c(h[p]);
      }).join(e);
    });
  }
  function a(f, d) {
    return d == null && (d = j_(f)), [d.map(c).join(e)].concat(o(f, d)).join(`
`);
  }
  function s(f, d) {
    return d == null && (d = j_(f)), o(f, d).join(`
`);
  }
  function u(f) {
    return f.map(l).join(`
`);
  }
  function l(f) {
    return f.map(c).join(e);
  }
  function c(f) {
    return f == null ? "" : f instanceof Date ? PI(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f;
  }
  return {
    parse: i,
    parseRows: r,
    format: a,
    formatBody: s,
    formatRows: u,
    formatRow: l,
    formatValue: c
  };
}
function BI(e) {
  return e;
}
function jI(e) {
  if (e == null)
    return BI;
  var t, n, i = e.scale[0], r = e.scale[1], o = e.translate[0], a = e.translate[1];
  return function(s, u) {
    u || (t = n = 0);
    var l = 2, c = s.length, f = new Array(c);
    for (f[0] = (t += s[0]) * i + o, f[1] = (n += s[1]) * r + a; l < c; )
      f[l] = s[l], ++l;
    return f;
  };
}
function UI(e, t) {
  for (var n, i = e.length, r = i - t; r < --i; )
    n = e[r], e[r++] = e[i], e[i] = n;
}
function qI(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return U_(e, n);
  }) } : U_(e, t);
}
function U_(e, t) {
  var n = t.id, i = t.bbox, r = t.properties == null ? {} : t.properties, o = UF(e, t);
  return n == null && i == null ? { type: "Feature", properties: r, geometry: o } : i == null ? { type: "Feature", id: n, properties: r, geometry: o } : { type: "Feature", id: n, bbox: i, properties: r, geometry: o };
}
function UF(e, t) {
  var n = jI(e.transform), i = e.arcs;
  function r(c, f) {
    f.length && f.pop();
    for (var d = i[c < 0 ? ~c : c], h = 0, p = d.length; h < p; ++h)
      f.push(n(d[h], h));
    c < 0 && UI(f, p);
  }
  function o(c) {
    return n(c);
  }
  function a(c) {
    for (var f = [], d = 0, h = c.length; d < h; ++d)
      r(c[d], f);
    return f.length < 2 && f.push(f[0]), f;
  }
  function s(c) {
    for (var f = a(c); f.length < 4; )
      f.push(f[0]);
    return f;
  }
  function u(c) {
    return c.map(s);
  }
  function l(c) {
    var f = c.type, d;
    switch (f) {
      case "GeometryCollection":
        return { type: f, geometries: c.geometries.map(l) };
      case "Point":
        d = o(c.coordinates);
        break;
      case "MultiPoint":
        d = c.coordinates.map(o);
        break;
      case "LineString":
        d = a(c.arcs);
        break;
      case "MultiLineString":
        d = c.arcs.map(a);
        break;
      case "Polygon":
        d = u(c.arcs);
        break;
      case "MultiPolygon":
        d = c.arcs.map(u);
        break;
      default:
        return null;
    }
    return { type: f, coordinates: d };
  }
  return l(t);
}
function WI(e, t) {
  var n = {}, i = {}, r = {}, o = [], a = -1;
  t.forEach(function(l, c) {
    var f = e.arcs[l < 0 ? ~l : l], d;
    f.length < 3 && !f[1][0] && !f[1][1] && (d = t[++a], t[a] = l, t[c] = d);
  }), t.forEach(function(l) {
    var c = s(l), f = c[0], d = c[1], h, p;
    if (h = r[f])
      if (delete r[h.end], h.push(l), h.end = d, p = i[d]) {
        delete i[p.start];
        var g = p === h ? h : h.concat(p);
        i[g.start = h.start] = r[g.end = p.end] = g;
      } else
        i[h.start] = r[h.end] = h;
    else if (h = i[d])
      if (delete i[h.start], h.unshift(l), h.start = f, p = r[f]) {
        delete r[p.end];
        var m = p === h ? h : p.concat(h);
        i[m.start = p.start] = r[m.end = h.end] = m;
      } else
        i[h.start] = r[h.end] = h;
    else
      h = [l], i[h.start = f] = r[h.end = d] = h;
  });
  function s(l) {
    var c = e.arcs[l < 0 ? ~l : l], f = c[0], d;
    return e.transform ? (d = [0, 0], c.forEach(function(h) {
      d[0] += h[0], d[1] += h[1];
    })) : d = c[c.length - 1], l < 0 ? [d, f] : [f, d];
  }
  function u(l, c) {
    for (var f in l) {
      var d = l[f];
      delete c[d.start], delete d.start, delete d.end, d.forEach(function(h) {
        n[h < 0 ? ~h : h] = 1;
      }), o.push(d);
    }
  }
  return u(r, i), u(i, r), t.forEach(function(l) {
    n[l < 0 ? ~l : l] || o.push([l]);
  }), o;
}
function GI(e) {
  return UF(e, HI.apply(this, arguments));
}
function HI(e, t, n) {
  var i, r, o;
  if (arguments.length > 1)
    i = YI(e, t, n);
  else
    for (r = 0, i = new Array(o = e.arcs.length); r < o; ++r)
      i[r] = r;
  return { type: "MultiLineString", arcs: WI(e, i) };
}
function YI(e, t, n) {
  var i = [], r = [], o;
  function a(f) {
    var d = f < 0 ? ~f : f;
    (r[d] || (r[d] = [])).push({ i: f, g: o });
  }
  function s(f) {
    f.forEach(a);
  }
  function u(f) {
    f.forEach(s);
  }
  function l(f) {
    f.forEach(u);
  }
  function c(f) {
    switch (o = f, f.type) {
      case "GeometryCollection":
        f.geometries.forEach(c);
        break;
      case "LineString":
        s(f.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        u(f.arcs);
        break;
      case "MultiPolygon":
        l(f.arcs);
        break;
    }
  }
  return c(t), r.forEach(n == null ? function(f) {
    i.push(f[0].i);
  } : function(f) {
    n(f[0].g, f[f.length - 1].g) && i.push(f[0].i);
  }), i;
}
function Kr(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function XI(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Af(e) {
  let t, n, i;
  e.length !== 2 ? (t = Kr, n = (s, u) => Kr(e(s), u), i = (s, u) => e(s) - u) : (t = e === Kr || e === XI ? e : VI, n = e, i = e);
  function r(s, u, l = 0, c = s.length) {
    if (l < c) {
      if (t(u, u) !== 0)
        return c;
      do {
        const f = l + c >>> 1;
        n(s[f], u) < 0 ? l = f + 1 : c = f;
      } while (l < c);
    }
    return l;
  }
  function o(s, u, l = 0, c = s.length) {
    if (l < c) {
      if (t(u, u) !== 0)
        return c;
      do {
        const f = l + c >>> 1;
        n(s[f], u) <= 0 ? l = f + 1 : c = f;
      } while (l < c);
    }
    return l;
  }
  function a(s, u, l = 0, c = s.length) {
    const f = r(s, u, l, c - 1);
    return f > l && i(s[f - 1], u) > -i(s[f], u) ? f - 1 : f;
  }
  return { left: r, center: a, right: o };
}
function VI() {
  return 0;
}
function qF(e) {
  return e === null ? NaN : +e;
}
function* KI(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
  }
}
const WF = Af(Kr), Mh = WF.right, JI = WF.left;
Af(qF).center;
const $f = Mh;
function QI(e, t) {
  let n = 0, i, r = 0, o = 0;
  if (t === void 0)
    for (let a of e)
      a != null && (a = +a) >= a && (i = a - r, r += i / ++n, o += i * (a - r));
  else {
    let a = -1;
    for (let s of e)
      (s = t(s, ++a, e)) != null && (s = +s) >= s && (i = s - r, r += i / ++n, o += i * (s - r));
  }
  if (n > 1)
    return o / (n - 1);
}
function ZI(e, t) {
  const n = QI(e, t);
  return n && Math.sqrt(n);
}
class nn {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let i = 0;
    for (let r = 0; r < this._n && r < 32; r++) {
      const o = n[r], a = t + o, s = Math.abs(t) < Math.abs(o) ? t - (a - o) : o - (a - t);
      s && (n[i++] = s), t = a;
    }
    return n[i] = t, this._n = i + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, i, r, o, a = 0;
    if (n > 0) {
      for (a = t[--n]; n > 0 && (i = a, r = t[--n], a = i + r, o = r - (a - i), !o); )
        ;
      n > 0 && (o < 0 && t[n - 1] < 0 || o > 0 && t[n - 1] > 0) && (r = o * 2, i = a + r, r == i - a && (a = i));
    }
    return a;
  }
}
class q_ extends Map {
  constructor(t, n = YF) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [i, r] of t)
        this.set(i, r);
  }
  get(t) {
    return super.get(V1(this, t));
  }
  has(t) {
    return super.has(V1(this, t));
  }
  set(t, n) {
    return super.set(GF(this, t), n);
  }
  delete(t) {
    return super.delete(HF(this, t));
  }
}
class Th extends Set {
  constructor(t, n = YF) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const i of t)
        this.add(i);
  }
  has(t) {
    return super.has(V1(this, t));
  }
  add(t) {
    return super.add(GF(this, t));
  }
  delete(t) {
    return super.delete(HF(this, t));
  }
}
function V1({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : n;
}
function GF({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : (e.set(i, n), n);
}
function HF({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) && (n = e.get(i), e.delete(i)), n;
}
function YF(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function eP(e, t) {
  return Array.from(t, (n) => e[n]);
}
function tP(e = Kr) {
  if (e === Kr)
    return XF;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const i = e(t, n);
    return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function XF(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
const nP = Math.sqrt(50), iP = Math.sqrt(10), rP = Math.sqrt(2);
function Oh(e, t, n) {
  const i = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(i)), o = i / Math.pow(10, r), a = o >= nP ? 10 : o >= iP ? 5 : o >= rP ? 2 : 1;
  let s, u, l;
  return r < 0 ? (l = Math.pow(10, -r) / a, s = Math.round(e * l), u = Math.round(t * l), s / l < e && ++s, u / l > t && --u, l = -l) : (l = Math.pow(10, r) * a, s = Math.round(e / l), u = Math.round(t / l), s * l < e && ++s, u * l > t && --u), u < s && 0.5 <= n && n < 2 ? Oh(e, t, n * 2) : [s, u, l];
}
function K1(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const i = t < e, [r, o, a] = i ? Oh(t, e, n) : Oh(e, t, n);
  if (!(o >= r))
    return [];
  const s = o - r + 1, u = new Array(s);
  if (i)
    if (a < 0)
      for (let l = 0; l < s; ++l)
        u[l] = (o - l) / -a;
    else
      for (let l = 0; l < s; ++l)
        u[l] = (o - l) * a;
  else if (a < 0)
    for (let l = 0; l < s; ++l)
      u[l] = (r + l) / -a;
  else
    for (let l = 0; l < s; ++l)
      u[l] = (r + l) * a;
  return u;
}
function J1(e, t, n) {
  return t = +t, e = +e, n = +n, Oh(e, t, n)[2];
}
function Ho(e, t, n) {
  t = +t, e = +e, n = +n;
  const i = t < e, r = i ? J1(t, e, n) : J1(e, t, n);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function Ka(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n < i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Q1(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n > i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function VF(e, t, n = 0, i = 1 / 0, r) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i))
    return e;
  for (r = r === void 0 ? XF : tP(r); i > n; ) {
    if (i - n > 600) {
      const u = i - n + 1, l = t - n + 1, c = Math.log(u), f = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * f * (u - f) / u) * (l - u / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - l * f / u + d)), p = Math.min(i, Math.floor(t + (u - l) * f / u + d));
      VF(e, t, h, p, r);
    }
    const o = e[t];
    let a = n, s = i;
    for (Ll(e, n, t), r(e[i], o) > 0 && Ll(e, n, i); a < s; ) {
      for (Ll(e, a, s), ++a, --s; r(e[a], o) < 0; )
        ++a;
      for (; r(e[s], o) > 0; )
        --s;
    }
    r(e[n], o) === 0 ? Ll(e, n, s) : (++s, Ll(e, s, i)), s <= t && (n = s + 1), t <= s && (i = s - 1);
  }
  return e;
}
function Ll(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function Z1(e, t, n) {
  if (e = Float64Array.from(KI(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return Q1(e);
    if (t >= 1)
      return Ka(e);
    var i, r = (i - 1) * t, o = Math.floor(r), a = Ka(VF(e, o).subarray(0, o + 1)), s = Q1(e.subarray(o + 1));
    return a + (s - a) * (r - o);
  }
}
function KF(e, t, n = qF) {
  if (!(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return +n(e[0], 0, e);
    if (t >= 1)
      return +n(e[i - 1], i - 1, e);
    var i, r = (i - 1) * t, o = Math.floor(r), a = +n(e[o], o, e), s = +n(e[o + 1], o + 1, e);
    return a + (s - a) * (r - o);
  }
}
function oP(e, t) {
  let n = 0, i = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (++n, i += r);
  else {
    let r = -1;
    for (let o of e)
      (o = t(o, ++r, e)) != null && (o = +o) >= o && (++n, i += o);
  }
  if (n)
    return i / n;
}
function JF(e, t) {
  return Z1(e, 0.5, t);
}
function* aP(e) {
  for (const t of e)
    yield* t;
}
function QF(e) {
  return Array.from(aP(e));
}
function Pn(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++i < r; )
    o[i] = e + i * n;
  return o;
}
function ZF(e, t) {
  let n = 0;
  if (t === void 0)
    for (let i of e)
      (i = +i) && (n += i);
  else {
    let i = -1;
    for (let r of e)
      (r = +t(r, ++i, e)) && (n += r);
  }
  return n;
}
function sP(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Nh(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, i = e.slice(0, n);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +e.slice(n + 1)
  ];
}
function $u(e) {
  return e = Nh(Math.abs(e)), e ? e[1] : NaN;
}
function uP(e, t) {
  return function(n, i) {
    for (var r = n.length, o = [], a = 0, s = e[0], u = 0; r > 0 && s > 0 && (u + s + 1 > i && (s = Math.max(1, i - u)), o.push(n.substring(r -= s, r + s)), !((u += s + 1) > i)); )
      s = e[a = (a + 1) % e.length];
    return o.reverse().join(t);
  };
}
function lP(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var cP = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function os(e) {
  if (!(t = cP.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new bb({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
os.prototype = bb.prototype;
function bb(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
bb.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function fP(e) {
  e:
    for (var t = e.length, n = 1, i = -1, r; n < t; ++n)
      switch (e[n]) {
        case ".":
          i = r = n;
          break;
        case "0":
          i === 0 && (i = n), r = n;
          break;
        default:
          if (!+e[n])
            break e;
          i > 0 && (i = 0);
          break;
      }
  return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e;
}
var eM;
function dP(e, t) {
  var n = Nh(e, t);
  if (!n)
    return e + "";
  var i = n[0], r = n[1], o = r - (eM = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, a = i.length;
  return o === a ? i : o > a ? i + new Array(o - a + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + new Array(1 - o).join("0") + Nh(e, Math.max(0, t + o - 1))[0];
}
function W_(e, t) {
  var n = Nh(e, t);
  if (!n)
    return e + "";
  var i = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const G_ = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: sP,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => W_(e * 100, t),
  r: W_,
  s: dP,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function H_(e) {
  return e;
}
var Y_ = Array.prototype.map, X_ = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function tM(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? H_ : uP(Y_.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", i = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? H_ : lP(Y_.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", s = e.minus === void 0 ? "\u2212" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function l(f) {
    f = os(f);
    var d = f.fill, h = f.align, p = f.sign, g = f.symbol, m = f.zero, y = f.width, v = f.comma, b = f.precision, x = f.trim, E = f.type;
    E === "n" ? (v = !0, E = "g") : G_[E] || (b === void 0 && (b = 12), x = !0, E = "g"), (m || d === "0" && h === "=") && (m = !0, d = "0", h = "=");
    var _ = g === "$" ? n : g === "#" && /[boxX]/.test(E) ? "0" + E.toLowerCase() : "", w = g === "$" ? i : /[%p]/.test(E) ? a : "", S = G_[E], C = /[defgprs%]/.test(E);
    b = b === void 0 ? 6 : /[gprs]/.test(E) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
    function $(A) {
      var M = _, F = w, O, k, T;
      if (E === "c")
        F = S(A) + F, A = "";
      else {
        A = +A;
        var N = A < 0 || 1 / A < 0;
        if (A = isNaN(A) ? u : S(Math.abs(A), b), x && (A = fP(A)), N && +A == 0 && p !== "+" && (N = !1), M = (N ? p === "(" ? p : s : p === "-" || p === "(" ? "" : p) + M, F = (E === "s" ? X_[8 + eM / 3] : "") + F + (N && p === "(" ? ")" : ""), C) {
          for (O = -1, k = A.length; ++O < k; )
            if (T = A.charCodeAt(O), 48 > T || T > 57) {
              F = (T === 46 ? r + A.slice(O + 1) : A.slice(O)) + F, A = A.slice(0, O);
              break;
            }
        }
      }
      v && !m && (A = t(A, 1 / 0));
      var L = M.length + A.length + F.length, z = L < y ? new Array(y - L + 1).join(d) : "";
      switch (v && m && (A = t(z + A, z.length ? y - F.length : 1 / 0), z = ""), h) {
        case "<":
          A = M + A + F + z;
          break;
        case "=":
          A = M + z + A + F;
          break;
        case "^":
          A = z.slice(0, L = z.length >> 1) + M + A + F + z.slice(L);
          break;
        default:
          A = z + M + A + F;
          break;
      }
      return o(A);
    }
    return $.toString = function() {
      return f + "";
    }, $;
  }
  function c(f, d) {
    var h = l((f = os(f), f.type = "f", f)), p = Math.max(-8, Math.min(8, Math.floor($u(d) / 3))) * 3, g = Math.pow(10, -p), m = X_[8 + p / 3];
    return function(y) {
      return h(g * y) + m;
    };
  }
  return {
    format: l,
    formatPrefix: c
  };
}
var gd, pg, xb;
hP({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function hP(e) {
  return gd = tM(e), pg = gd.format, xb = gd.formatPrefix, gd;
}
function nM(e) {
  return Math.max(0, -$u(Math.abs(e)));
}
function iM(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor($u(t) / 3))) * 3 - $u(Math.abs(e)));
}
function rM(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, $u(t) - $u(e)) + 1;
}
const x0 = new Date(), w0 = new Date();
function lt(e, t, n, i) {
  function r(o) {
    return e(o = arguments.length === 0 ? new Date() : new Date(+o)), o;
  }
  return r.floor = (o) => (e(o = new Date(+o)), o), r.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), r.round = (o) => {
    const a = r(o), s = r.ceil(o);
    return o - a < s - o ? a : s;
  }, r.offset = (o, a) => (t(o = new Date(+o), a == null ? 1 : Math.floor(a)), o), r.range = (o, a, s) => {
    const u = [];
    if (o = r.ceil(o), s = s == null ? 1 : Math.floor(s), !(o < a) || !(s > 0))
      return u;
    let l;
    do
      u.push(l = new Date(+o)), t(o, s), e(o);
    while (l < o && o < a);
    return u;
  }, r.filter = (o) => lt((a) => {
    if (a >= a)
      for (; e(a), !o(a); )
        a.setTime(a - 1);
  }, (a, s) => {
    if (a >= a)
      if (s < 0)
        for (; ++s <= 0; )
          for (; t(a, -1), !o(a); )
            ;
      else
        for (; --s >= 0; )
          for (; t(a, 1), !o(a); )
            ;
  }), n && (r.count = (o, a) => (x0.setTime(+o), w0.setTime(+a), e(x0), e(w0), Math.floor(n(x0, w0))), r.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(i ? (a) => i(a) % o === 0 : (a) => r.count(0, a) % o === 0) : r)), r;
}
const ku = lt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
ku.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? lt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : ku);
ku.range;
const Wr = 1e3, Xn = Wr * 60, Gr = Xn * 60, io = Gr * 24, wb = io * 7, V_ = io * 30, E0 = io * 365, Hr = lt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * Wr);
}, (e, t) => (t - e) / Wr, (e) => e.getUTCSeconds());
Hr.range;
const gg = lt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Wr);
}, (e, t) => {
  e.setTime(+e + t * Xn);
}, (e, t) => (t - e) / Xn, (e) => e.getMinutes());
gg.range;
const mg = lt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Xn);
}, (e, t) => (t - e) / Xn, (e) => e.getUTCMinutes());
mg.range;
const yg = lt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Wr - e.getMinutes() * Xn);
}, (e, t) => {
  e.setTime(+e + t * Gr);
}, (e, t) => (t - e) / Gr, (e) => e.getHours());
yg.range;
const vg = lt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * Gr);
}, (e, t) => (t - e) / Gr, (e) => e.getUTCHours());
vg.range;
const Jr = lt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Xn) / io,
  (e) => e.getDate() - 1
);
Jr.range;
const Bo = lt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / io, (e) => e.getUTCDate() - 1);
Bo.range;
const oM = lt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / io, (e) => Math.floor(e / io));
oM.range;
function ks(e) {
  return lt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Xn) / wb);
}
const dl = ks(0), Dh = ks(1), pP = ks(2), gP = ks(3), Cu = ks(4), mP = ks(5), yP = ks(6);
dl.range;
Dh.range;
pP.range;
gP.range;
Cu.range;
mP.range;
yP.range;
function Cs(e) {
  return lt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / wb);
}
const hl = Cs(0), Rh = Cs(1), vP = Cs(2), bP = Cs(3), Fu = Cs(4), xP = Cs(5), wP = Cs(6);
hl.range;
Rh.range;
vP.range;
bP.range;
Fu.range;
xP.range;
wP.range;
const Hc = lt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
Hc.range;
const Yc = lt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Yc.range;
const pr = lt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
pr.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : lt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
pr.range;
const gr = lt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
gr.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : lt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
gr.range;
function aM(e, t, n, i, r, o) {
  const a = [
    [Hr, 1, Wr],
    [Hr, 5, 5 * Wr],
    [Hr, 15, 15 * Wr],
    [Hr, 30, 30 * Wr],
    [o, 1, Xn],
    [o, 5, 5 * Xn],
    [o, 15, 15 * Xn],
    [o, 30, 30 * Xn],
    [r, 1, Gr],
    [r, 3, 3 * Gr],
    [r, 6, 6 * Gr],
    [r, 12, 12 * Gr],
    [i, 1, io],
    [i, 2, 2 * io],
    [n, 1, wb],
    [t, 1, V_],
    [t, 3, 3 * V_],
    [e, 1, E0]
  ];
  function s(l, c, f) {
    const d = c < l;
    d && ([l, c] = [c, l]);
    const h = f && typeof f.range == "function" ? f : u(l, c, f), p = h ? h.range(l, +c + 1) : [];
    return d ? p.reverse() : p;
  }
  function u(l, c, f) {
    const d = Math.abs(c - l) / f, h = Af(([, , m]) => m).right(a, d);
    if (h === a.length)
      return e.every(Ho(l / E0, c / E0, f));
    if (h === 0)
      return ku.every(Math.max(Ho(l, c, f), 1));
    const [p, g] = a[d / a[h - 1][2] < a[h][2] / d ? h - 1 : h];
    return p.every(g);
  }
  return [s, u];
}
const [EP, _P] = aM(gr, Yc, hl, oM, vg, mg), [SP, AP] = aM(pr, Hc, dl, Jr, yg, gg), $t = "year", _n = "quarter", jt = "month", at = "week", Sn = "date", Lt = "day", mr = "dayofyear", Bn = "hours", jn = "minutes", ti = "seconds", Ni = "milliseconds", Eb = [$t, _n, jt, at, Sn, Lt, mr, Bn, jn, ti, Ni], _0 = Eb.reduce((e, t, n) => (e[t] = 1 + n, e), {});
function _b(e) {
  const t = X(e).slice(), n = {};
  return t.length || I("Missing time unit."), t.forEach((r) => {
    ie(_0, r) ? n[r] = 1 : I(`Invalid time unit: ${r}.`);
  }), (n[at] || n[Lt] ? 1 : 0) + (n[_n] || n[jt] || n[Sn] ? 1 : 0) + (n[mr] ? 1 : 0) > 1 && I(`Incompatible time units: ${e}`), t.sort((r, o) => _0[r] - _0[o]), t;
}
const $P = {
  [$t]: "%Y ",
  [_n]: "Q%q ",
  [jt]: "%b ",
  [Sn]: "%d ",
  [at]: "W%U ",
  [Lt]: "%a ",
  [mr]: "%j ",
  [Bn]: "%H:00",
  [jn]: "00:%M",
  [ti]: ":%S",
  [Ni]: ".%L",
  [`${$t}-${jt}`]: "%Y-%m ",
  [`${$t}-${jt}-${Sn}`]: "%Y-%m-%d ",
  [`${Bn}-${jn}`]: "%H:%M"
};
function sM(e, t) {
  const n = ce({}, $P, t), i = _b(e), r = i.length;
  let o = "", a = 0, s, u;
  for (a = 0; a < r; )
    for (s = i.length; s > a; --s)
      if (u = i.slice(a, s).join("-"), n[u] != null) {
        o += n[u], a = s;
        break;
      }
  return o.trim();
}
const Ia = new Date();
function Sb(e) {
  return Ia.setFullYear(e), Ia.setMonth(0), Ia.setDate(1), Ia.setHours(0, 0, 0, 0), Ia;
}
function uM(e) {
  return cM(new Date(e));
}
function lM(e) {
  return ey(new Date(e));
}
function cM(e) {
  return Jr.count(Sb(e.getFullYear()) - 1, e);
}
function ey(e) {
  return dl.count(Sb(e.getFullYear()) - 1, e);
}
function ty(e) {
  return Sb(e).getDay();
}
function kP(e, t, n, i, r, o, a) {
  if (0 <= e && e < 100) {
    const s = new Date(-1, t, n, i, r, o, a);
    return s.setFullYear(e), s;
  }
  return new Date(e, t, n, i, r, o, a);
}
function fM(e) {
  return hM(new Date(e));
}
function dM(e) {
  return ny(new Date(e));
}
function hM(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return Bo.count(t - 1, e);
}
function ny(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return hl.count(t - 1, e);
}
function iy(e) {
  return Ia.setTime(Date.UTC(e, 0, 1)), Ia.getUTCDay();
}
function CP(e, t, n, i, r, o, a) {
  if (0 <= e && e < 100) {
    const s = new Date(Date.UTC(-1, t, n, i, r, o, a));
    return s.setUTCFullYear(n.y), s;
  }
  return new Date(Date.UTC(e, t, n, i, r, o, a));
}
function pM(e, t, n, i, r) {
  const o = t || 1, a = xe(e), s = (y, v, b) => (b = b || y, FP(n[b], i[b], y === a && o, v)), u = new Date(), l = Oi(e), c = l[$t] ? s($t) : Gt(2012), f = l[jt] ? s(jt) : l[_n] ? s(_n) : Co, d = l[at] && l[Lt] ? s(Lt, 1, at + Lt) : l[at] ? s(at, 1) : l[Lt] ? s(Lt, 1) : l[Sn] ? s(Sn, 1) : l[mr] ? s(mr, 1) : ul, h = l[Bn] ? s(Bn) : Co, p = l[jn] ? s(jn) : Co, g = l[ti] ? s(ti) : Co, m = l[Ni] ? s(Ni) : Co;
  return function(y) {
    u.setTime(+y);
    const v = c(u);
    return r(v, f(u), d(u, v), h(u), p(u), g(u), m(u));
  };
}
function FP(e, t, n, i) {
  const r = n <= 1 ? e : i ? (o, a) => i + n * Math.floor((e(o, a) - i) / n) : (o, a) => n * Math.floor(e(o, a) / n);
  return t ? (o, a) => t(r(o, a), a) : r;
}
function Mu(e, t, n) {
  return t + e * 7 - (n + 6) % 7;
}
const MP = {
  [$t]: (e) => e.getFullYear(),
  [_n]: (e) => Math.floor(e.getMonth() / 3),
  [jt]: (e) => e.getMonth(),
  [Sn]: (e) => e.getDate(),
  [Bn]: (e) => e.getHours(),
  [jn]: (e) => e.getMinutes(),
  [ti]: (e) => e.getSeconds(),
  [Ni]: (e) => e.getMilliseconds(),
  [mr]: (e) => cM(e),
  [at]: (e) => ey(e),
  [at + Lt]: (e, t) => Mu(ey(e), e.getDay(), ty(t)),
  [Lt]: (e, t) => Mu(1, e.getDay(), ty(t))
}, TP = {
  [_n]: (e) => 3 * e,
  [at]: (e, t) => Mu(e, 0, ty(t))
};
function gM(e, t) {
  return pM(e, t || 1, MP, TP, kP);
}
const OP = {
  [$t]: (e) => e.getUTCFullYear(),
  [_n]: (e) => Math.floor(e.getUTCMonth() / 3),
  [jt]: (e) => e.getUTCMonth(),
  [Sn]: (e) => e.getUTCDate(),
  [Bn]: (e) => e.getUTCHours(),
  [jn]: (e) => e.getUTCMinutes(),
  [ti]: (e) => e.getUTCSeconds(),
  [Ni]: (e) => e.getUTCMilliseconds(),
  [mr]: (e) => hM(e),
  [at]: (e) => ny(e),
  [Lt]: (e, t) => Mu(1, e.getUTCDay(), iy(t)),
  [at + Lt]: (e, t) => Mu(ny(e), e.getUTCDay(), iy(t))
}, NP = {
  [_n]: (e) => 3 * e,
  [at]: (e, t) => Mu(e, 0, iy(t))
};
function mM(e, t) {
  return pM(e, t || 1, OP, NP, CP);
}
const DP = {
  [$t]: pr,
  [_n]: Hc.every(3),
  [jt]: Hc,
  [at]: dl,
  [Sn]: Jr,
  [Lt]: Jr,
  [mr]: Jr,
  [Bn]: yg,
  [jn]: gg,
  [ti]: Hr,
  [Ni]: ku
}, RP = {
  [$t]: gr,
  [_n]: Yc.every(3),
  [jt]: Yc,
  [at]: hl,
  [Sn]: Bo,
  [Lt]: Bo,
  [mr]: Bo,
  [Bn]: vg,
  [jn]: mg,
  [ti]: Hr,
  [Ni]: ku
};
function pl(e) {
  return DP[e];
}
function gl(e) {
  return RP[e];
}
function yM(e, t, n) {
  return e ? e.offset(t, n) : void 0;
}
function vM(e, t, n) {
  return yM(pl(e), t, n);
}
function bM(e, t, n) {
  return yM(gl(e), t, n);
}
function xM(e, t, n, i) {
  return e ? e.range(t, n, i) : void 0;
}
function wM(e, t, n, i) {
  return xM(pl(e), t, n, i);
}
function EM(e, t, n, i) {
  return xM(gl(e), t, n, i);
}
const uc = 1e3, lc = uc * 60, cc = lc * 60, bg = cc * 24, LP = bg * 7, K_ = bg * 30, ry = bg * 365, _M = [$t, jt, Sn, Bn, jn, ti, Ni], fc = _M.slice(0, -1), dc = fc.slice(0, -1), hc = dc.slice(0, -1), IP = hc.slice(0, -1), PP = [$t, at], J_ = [$t, jt], SM = [$t], Il = [[fc, 1, uc], [fc, 5, 5 * uc], [fc, 15, 15 * uc], [fc, 30, 30 * uc], [dc, 1, lc], [dc, 5, 5 * lc], [dc, 15, 15 * lc], [dc, 30, 30 * lc], [hc, 1, cc], [hc, 3, 3 * cc], [hc, 6, 6 * cc], [hc, 12, 12 * cc], [IP, 1, bg], [PP, 1, LP], [J_, 1, K_], [J_, 3, 3 * K_], [SM, 1, ry]];
function AM(e) {
  const t = e.extent, n = e.maxbins || 40, i = Math.abs(Sf(t)) / n;
  let r = Af((s) => s[2]).right(Il, i), o, a;
  return r === Il.length ? (o = SM, a = Ho(t[0] / ry, t[1] / ry, n)) : r ? (r = Il[i / Il[r - 1][2] < Il[r][2] / i ? r - 1 : r], o = r[0], a = r[1]) : (o = _M, a = Math.max(Ho(t[0], t[1], n), 1)), {
    units: o,
    step: a
  };
}
function S0(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function A0(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function Pl(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function $M(e) {
  var t = e.dateTime, n = e.date, i = e.time, r = e.periods, o = e.days, a = e.shortDays, s = e.months, u = e.shortMonths, l = zl(r), c = Bl(r), f = zl(o), d = Bl(o), h = zl(a), p = Bl(a), g = zl(s), m = Bl(s), y = zl(u), v = Bl(u), b = {
    a: N,
    A: L,
    b: z,
    B: J,
    c: null,
    d: iS,
    e: iS,
    f: s8,
    g: y8,
    G: b8,
    H: r8,
    I: o8,
    j: a8,
    L: kM,
    m: u8,
    M: l8,
    p: le,
    q: Ee,
    Q: aS,
    s: sS,
    S: c8,
    u: f8,
    U: d8,
    V: h8,
    w: p8,
    W: g8,
    x: null,
    X: null,
    y: m8,
    Y: v8,
    Z: x8,
    "%": oS
  }, x = {
    a: _e,
    A: Ue,
    b: ye,
    B: Mt,
    c: null,
    d: rS,
    e: rS,
    f: S8,
    g: D8,
    G: L8,
    H: w8,
    I: E8,
    j: _8,
    L: FM,
    m: A8,
    M: $8,
    p: Gi,
    q: Ht,
    Q: aS,
    s: sS,
    S: k8,
    u: C8,
    U: F8,
    V: M8,
    w: T8,
    W: O8,
    x: null,
    X: null,
    y: N8,
    Y: R8,
    Z: I8,
    "%": oS
  }, E = {
    a: $,
    A,
    b: M,
    B: F,
    c: O,
    d: tS,
    e: tS,
    f: e8,
    g: eS,
    G: Z_,
    H: nS,
    I: nS,
    j: KP,
    L: ZP,
    m: VP,
    M: JP,
    p: C,
    q: XP,
    Q: n8,
    s: i8,
    S: QP,
    u: qP,
    U: WP,
    V: GP,
    w: UP,
    W: HP,
    x: k,
    X: T,
    y: eS,
    Y: Z_,
    Z: YP,
    "%": t8
  };
  b.x = _(n, b), b.X = _(i, b), b.c = _(t, b), x.x = _(n, x), x.X = _(i, x), x.c = _(t, x);
  function _(V, ue) {
    return function(de) {
      var j = [], He = -1, ve = 0, rt = V.length, Xe, Tn, Hi;
      for (de instanceof Date || (de = new Date(+de)); ++He < rt; )
        V.charCodeAt(He) === 37 && (j.push(V.slice(ve, He)), (Tn = Q_[Xe = V.charAt(++He)]) != null ? Xe = V.charAt(++He) : Tn = Xe === "e" ? " " : "0", (Hi = ue[Xe]) && (Xe = Hi(de, Tn)), j.push(Xe), ve = He + 1);
      return j.push(V.slice(ve, He)), j.join("");
    };
  }
  function w(V, ue) {
    return function(de) {
      var j = Pl(1900, void 0, 1), He = S(j, V, de += "", 0), ve, rt;
      if (He != de.length)
        return null;
      if ("Q" in j)
        return new Date(j.Q);
      if ("s" in j)
        return new Date(j.s * 1e3 + ("L" in j ? j.L : 0));
      if (ue && !("Z" in j) && (j.Z = 0), "p" in j && (j.H = j.H % 12 + j.p * 12), j.m === void 0 && (j.m = "q" in j ? j.q : 0), "V" in j) {
        if (j.V < 1 || j.V > 53)
          return null;
        "w" in j || (j.w = 1), "Z" in j ? (ve = A0(Pl(j.y, 0, 1)), rt = ve.getUTCDay(), ve = rt > 4 || rt === 0 ? Rh.ceil(ve) : Rh(ve), ve = Bo.offset(ve, (j.V - 1) * 7), j.y = ve.getUTCFullYear(), j.m = ve.getUTCMonth(), j.d = ve.getUTCDate() + (j.w + 6) % 7) : (ve = S0(Pl(j.y, 0, 1)), rt = ve.getDay(), ve = rt > 4 || rt === 0 ? Dh.ceil(ve) : Dh(ve), ve = Jr.offset(ve, (j.V - 1) * 7), j.y = ve.getFullYear(), j.m = ve.getMonth(), j.d = ve.getDate() + (j.w + 6) % 7);
      } else
        ("W" in j || "U" in j) && ("w" in j || (j.w = "u" in j ? j.u % 7 : "W" in j ? 1 : 0), rt = "Z" in j ? A0(Pl(j.y, 0, 1)).getUTCDay() : S0(Pl(j.y, 0, 1)).getDay(), j.m = 0, j.d = "W" in j ? (j.w + 6) % 7 + j.W * 7 - (rt + 5) % 7 : j.w + j.U * 7 - (rt + 6) % 7);
      return "Z" in j ? (j.H += j.Z / 100 | 0, j.M += j.Z % 100, A0(j)) : S0(j);
    };
  }
  function S(V, ue, de, j) {
    for (var He = 0, ve = ue.length, rt = de.length, Xe, Tn; He < ve; ) {
      if (j >= rt)
        return -1;
      if (Xe = ue.charCodeAt(He++), Xe === 37) {
        if (Xe = ue.charAt(He++), Tn = E[Xe in Q_ ? ue.charAt(He++) : Xe], !Tn || (j = Tn(V, de, j)) < 0)
          return -1;
      } else if (Xe != de.charCodeAt(j++))
        return -1;
    }
    return j;
  }
  function C(V, ue, de) {
    var j = l.exec(ue.slice(de));
    return j ? (V.p = c.get(j[0].toLowerCase()), de + j[0].length) : -1;
  }
  function $(V, ue, de) {
    var j = h.exec(ue.slice(de));
    return j ? (V.w = p.get(j[0].toLowerCase()), de + j[0].length) : -1;
  }
  function A(V, ue, de) {
    var j = f.exec(ue.slice(de));
    return j ? (V.w = d.get(j[0].toLowerCase()), de + j[0].length) : -1;
  }
  function M(V, ue, de) {
    var j = y.exec(ue.slice(de));
    return j ? (V.m = v.get(j[0].toLowerCase()), de + j[0].length) : -1;
  }
  function F(V, ue, de) {
    var j = g.exec(ue.slice(de));
    return j ? (V.m = m.get(j[0].toLowerCase()), de + j[0].length) : -1;
  }
  function O(V, ue, de) {
    return S(V, t, ue, de);
  }
  function k(V, ue, de) {
    return S(V, n, ue, de);
  }
  function T(V, ue, de) {
    return S(V, i, ue, de);
  }
  function N(V) {
    return a[V.getDay()];
  }
  function L(V) {
    return o[V.getDay()];
  }
  function z(V) {
    return u[V.getMonth()];
  }
  function J(V) {
    return s[V.getMonth()];
  }
  function le(V) {
    return r[+(V.getHours() >= 12)];
  }
  function Ee(V) {
    return 1 + ~~(V.getMonth() / 3);
  }
  function _e(V) {
    return a[V.getUTCDay()];
  }
  function Ue(V) {
    return o[V.getUTCDay()];
  }
  function ye(V) {
    return u[V.getUTCMonth()];
  }
  function Mt(V) {
    return s[V.getUTCMonth()];
  }
  function Gi(V) {
    return r[+(V.getUTCHours() >= 12)];
  }
  function Ht(V) {
    return 1 + ~~(V.getUTCMonth() / 3);
  }
  return {
    format: function(V) {
      var ue = _(V += "", b);
      return ue.toString = function() {
        return V;
      }, ue;
    },
    parse: function(V) {
      var ue = w(V += "", !1);
      return ue.toString = function() {
        return V;
      }, ue;
    },
    utcFormat: function(V) {
      var ue = _(V += "", x);
      return ue.toString = function() {
        return V;
      }, ue;
    },
    utcParse: function(V) {
      var ue = w(V += "", !0);
      return ue.toString = function() {
        return V;
      }, ue;
    }
  };
}
var Q_ = { "-": "", _: " ", 0: "0" }, Et = /^\s*\d+/, zP = /^%/, BP = /[\\^$*+?|[\]().{}]/g;
function Ae(e, t, n) {
  var i = e < 0 ? "-" : "", r = (i ? -e : e) + "", o = r.length;
  return i + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function jP(e) {
  return e.replace(BP, "\\$&");
}
function zl(e) {
  return new RegExp("^(?:" + e.map(jP).join("|") + ")", "i");
}
function Bl(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function UP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 1));
  return i ? (e.w = +i[0], n + i[0].length) : -1;
}
function qP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 1));
  return i ? (e.u = +i[0], n + i[0].length) : -1;
}
function WP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.U = +i[0], n + i[0].length) : -1;
}
function GP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.V = +i[0], n + i[0].length) : -1;
}
function HP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.W = +i[0], n + i[0].length) : -1;
}
function Z_(e, t, n) {
  var i = Et.exec(t.slice(n, n + 4));
  return i ? (e.y = +i[0], n + i[0].length) : -1;
}
function eS(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
}
function YP(e, t, n) {
  var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
}
function XP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 1));
  return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
}
function VP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
}
function tS(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.d = +i[0], n + i[0].length) : -1;
}
function KP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 3));
  return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
}
function nS(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.H = +i[0], n + i[0].length) : -1;
}
function JP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.M = +i[0], n + i[0].length) : -1;
}
function QP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 2));
  return i ? (e.S = +i[0], n + i[0].length) : -1;
}
function ZP(e, t, n) {
  var i = Et.exec(t.slice(n, n + 3));
  return i ? (e.L = +i[0], n + i[0].length) : -1;
}
function e8(e, t, n) {
  var i = Et.exec(t.slice(n, n + 6));
  return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
}
function t8(e, t, n) {
  var i = zP.exec(t.slice(n, n + 1));
  return i ? n + i[0].length : -1;
}
function n8(e, t, n) {
  var i = Et.exec(t.slice(n));
  return i ? (e.Q = +i[0], n + i[0].length) : -1;
}
function i8(e, t, n) {
  var i = Et.exec(t.slice(n));
  return i ? (e.s = +i[0], n + i[0].length) : -1;
}
function iS(e, t) {
  return Ae(e.getDate(), t, 2);
}
function r8(e, t) {
  return Ae(e.getHours(), t, 2);
}
function o8(e, t) {
  return Ae(e.getHours() % 12 || 12, t, 2);
}
function a8(e, t) {
  return Ae(1 + Jr.count(pr(e), e), t, 3);
}
function kM(e, t) {
  return Ae(e.getMilliseconds(), t, 3);
}
function s8(e, t) {
  return kM(e, t) + "000";
}
function u8(e, t) {
  return Ae(e.getMonth() + 1, t, 2);
}
function l8(e, t) {
  return Ae(e.getMinutes(), t, 2);
}
function c8(e, t) {
  return Ae(e.getSeconds(), t, 2);
}
function f8(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function d8(e, t) {
  return Ae(dl.count(pr(e) - 1, e), t, 2);
}
function CM(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Cu(e) : Cu.ceil(e);
}
function h8(e, t) {
  return e = CM(e), Ae(Cu.count(pr(e), e) + (pr(e).getDay() === 4), t, 2);
}
function p8(e) {
  return e.getDay();
}
function g8(e, t) {
  return Ae(Dh.count(pr(e) - 1, e), t, 2);
}
function m8(e, t) {
  return Ae(e.getFullYear() % 100, t, 2);
}
function y8(e, t) {
  return e = CM(e), Ae(e.getFullYear() % 100, t, 2);
}
function v8(e, t) {
  return Ae(e.getFullYear() % 1e4, t, 4);
}
function b8(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Cu(e) : Cu.ceil(e), Ae(e.getFullYear() % 1e4, t, 4);
}
function x8(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ae(t / 60 | 0, "0", 2) + Ae(t % 60, "0", 2);
}
function rS(e, t) {
  return Ae(e.getUTCDate(), t, 2);
}
function w8(e, t) {
  return Ae(e.getUTCHours(), t, 2);
}
function E8(e, t) {
  return Ae(e.getUTCHours() % 12 || 12, t, 2);
}
function _8(e, t) {
  return Ae(1 + Bo.count(gr(e), e), t, 3);
}
function FM(e, t) {
  return Ae(e.getUTCMilliseconds(), t, 3);
}
function S8(e, t) {
  return FM(e, t) + "000";
}
function A8(e, t) {
  return Ae(e.getUTCMonth() + 1, t, 2);
}
function $8(e, t) {
  return Ae(e.getUTCMinutes(), t, 2);
}
function k8(e, t) {
  return Ae(e.getUTCSeconds(), t, 2);
}
function C8(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function F8(e, t) {
  return Ae(hl.count(gr(e) - 1, e), t, 2);
}
function MM(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Fu(e) : Fu.ceil(e);
}
function M8(e, t) {
  return e = MM(e), Ae(Fu.count(gr(e), e) + (gr(e).getUTCDay() === 4), t, 2);
}
function T8(e) {
  return e.getUTCDay();
}
function O8(e, t) {
  return Ae(Rh.count(gr(e) - 1, e), t, 2);
}
function N8(e, t) {
  return Ae(e.getUTCFullYear() % 100, t, 2);
}
function D8(e, t) {
  return e = MM(e), Ae(e.getUTCFullYear() % 100, t, 2);
}
function R8(e, t) {
  return Ae(e.getUTCFullYear() % 1e4, t, 4);
}
function L8(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Fu(e) : Fu.ceil(e), Ae(e.getUTCFullYear() % 1e4, t, 4);
}
function I8() {
  return "+0000";
}
function oS() {
  return "%";
}
function aS(e) {
  return +e;
}
function sS(e) {
  return Math.floor(+e / 1e3);
}
var Hs, Ab, TM, $b, OM;
P8({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function P8(e) {
  return Hs = $M(e), Ab = Hs.format, TM = Hs.parse, $b = Hs.utcFormat, OM = Hs.utcParse, Hs;
}
function pc(e) {
  const t = {};
  return (n) => t[n] || (t[n] = e(n));
}
function z8(e, t) {
  return (n) => {
    const i = e(n), r = i.indexOf(t);
    if (r < 0)
      return i;
    let o = B8(i, r);
    const a = o < i.length ? i.slice(o) : "";
    for (; --o > r; )
      if (i[o] !== "0") {
        ++o;
        break;
      }
    return i.slice(0, o) + a;
  };
}
function B8(e, t) {
  let n = e.lastIndexOf("e"), i;
  if (n > 0)
    return n;
  for (n = e.length; --n > t; )
    if (i = e.charCodeAt(n), i >= 48 && i <= 57)
      return n + 1;
}
function NM(e) {
  const t = pc(e.format), n = e.formatPrefix;
  return {
    format: t,
    formatPrefix: n,
    formatFloat(i) {
      const r = os(i || ",");
      if (r.precision == null) {
        switch (r.precision = 12, r.type) {
          case "%":
            r.precision -= 2;
            break;
          case "e":
            r.precision -= 1;
            break;
        }
        return z8(
          t(r),
          t(".1f")(1)[1]
        );
      } else
        return t(r);
    },
    formatSpan(i, r, o, a) {
      a = os(a == null ? ",f" : a);
      const s = Ho(i, r, o), u = Math.max(Math.abs(i), Math.abs(r));
      let l;
      if (a.precision == null)
        switch (a.type) {
          case "s":
            return isNaN(l = iM(s, u)) || (a.precision = l), n(a, u);
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            isNaN(l = rM(s, u)) || (a.precision = l - (a.type === "e"));
            break;
          }
          case "f":
          case "%": {
            isNaN(l = nM(s)) || (a.precision = l - (a.type === "%") * 2);
            break;
          }
        }
      return t(a);
    }
  };
}
let oy;
DM();
function DM() {
  return oy = NM({
    format: pg,
    formatPrefix: xb
  });
}
function RM(e) {
  return NM(tM(e));
}
function Lh(e) {
  return arguments.length ? oy = RM(e) : oy;
}
function uS(e, t, n) {
  n = n || {}, K(n) || I(`Invalid time multi-format specifier: ${n}`);
  const i = t(ti), r = t(jn), o = t(Bn), a = t(Sn), s = t(at), u = t(jt), l = t(_n), c = t($t), f = e(n[Ni] || ".%L"), d = e(n[ti] || ":%S"), h = e(n[jn] || "%I:%M"), p = e(n[Bn] || "%I %p"), g = e(n[Sn] || n[Lt] || "%a %d"), m = e(n[at] || "%b %d"), y = e(n[jt] || "%B"), v = e(n[_n] || "%B"), b = e(n[$t] || "%Y");
  return (x) => (i(x) < x ? f : r(x) < x ? d : o(x) < x ? h : a(x) < x ? p : u(x) < x ? s(x) < x ? g : m : c(x) < x ? l(x) < x ? y : v : b)(x);
}
function LM(e) {
  const t = pc(e.format), n = pc(e.utcFormat);
  return {
    timeFormat: (i) => Y(i) ? t(i) : uS(t, pl, i),
    utcFormat: (i) => Y(i) ? n(i) : uS(n, gl, i),
    timeParse: pc(e.parse),
    utcParse: pc(e.utcParse)
  };
}
let ay;
IM();
function IM() {
  return ay = LM({
    format: Ab,
    parse: TM,
    utcFormat: $b,
    utcParse: OM
  });
}
function PM(e) {
  return LM($M(e));
}
function Xc(e) {
  return arguments.length ? ay = PM(e) : ay;
}
const sy = (e, t) => ce({}, e, t);
function zM(e, t) {
  const n = e ? RM(e) : Lh(), i = t ? PM(t) : Xc();
  return sy(n, i);
}
function kb(e, t) {
  const n = arguments.length;
  return n && n !== 2 && I("defaultLocale expects either zero or two arguments."), n ? sy(Lh(e), Xc(t)) : sy(Lh(), Xc());
}
function j8() {
  return DM(), IM(), kb();
}
const U8 = /^(data:|([A-Za-z]+:)?\/\/)/, q8 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, W8 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, lS = "file://";
function G8(e, t) {
  return (n) => ({
    options: n || {},
    sanitize: Y8,
    load: H8,
    fileAccess: !!t,
    file: X8(t),
    http: K8(e)
  });
}
async function H8(e, t) {
  const n = await this.sanitize(e, t), i = n.href;
  return n.localFile ? this.file(i) : this.http(i, t);
}
async function Y8(e, t) {
  t = ce({}, this.options, t);
  const n = this.fileAccess, i = {
    href: null
  };
  let r, o, a;
  const s = q8.test(e.replace(W8, ""));
  (e == null || typeof e != "string" || !s) && I("Sanitize failure, invalid URI: " + W(e));
  const u = U8.test(e);
  return (a = t.baseURL) && !u && (!e.startsWith("/") && !a.endsWith("/") && (e = "/" + e), e = a + e), o = (r = e.startsWith(lS)) || t.mode === "file" || t.mode !== "http" && !u && n, r ? e = e.slice(lS.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), o = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
    value: !!o
  }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i;
}
function X8(e) {
  return e ? (t) => new Promise((n, i) => {
    e.readFile(t, (r, o) => {
      r ? i(r) : n(o);
    });
  }) : V8;
}
async function V8() {
  I("No file system access.");
}
function K8(e) {
  return e ? async function(t, n) {
    const i = ce({}, this.options.http, n), r = n && n.response, o = await e(t, i);
    return o.ok ? fe(o[r]) ? o[r]() : o.text() : I(o.status + "" + o.statusText);
  } : J8;
}
async function J8() {
  I("No HTTP fetch method available.");
}
const Q8 = (e) => e != null && e === e, Z8 = (e) => e === "true" || e === "false" || e === !0 || e === !1, ez = (e) => !Number.isNaN(Date.parse(e)), BM = (e) => !Number.isNaN(+e) && !(e instanceof Date), tz = (e) => BM(e) && Number.isInteger(+e), uy = {
  boolean: mb,
  integer: It,
  number: It,
  date: yb,
  string: vb,
  unknown: Wt
}, md = [Z8, tz, BM, ez], nz = ["boolean", "integer", "number", "date"];
function jM(e, t) {
  if (!e || !e.length)
    return "unknown";
  const n = e.length, i = md.length, r = md.map((o, a) => a + 1);
  for (let o = 0, a = 0, s, u; o < n; ++o)
    for (u = t ? e[o][t] : e[o], s = 0; s < i; ++s)
      if (r[s] && Q8(u) && !md[s](u) && (r[s] = 0, ++a, a === md.length))
        return "string";
  return nz[r.reduce((o, a) => o === 0 ? a : o, 0) - 1];
}
function UM(e, t) {
  return t.reduce((n, i) => (n[i] = jM(e, i), n), {});
}
function cS(e) {
  const t = function(n, i) {
    const r = {
      delimiter: e
    };
    return Cb(n, i ? ce(i, r) : r);
  };
  return t.responseType = "text", t;
}
function Cb(e, t) {
  return t.header && (e = t.header.map(W).join(t.delimiter) + `
` + e), zI(t.delimiter).parse(e + "");
}
Cb.responseType = "text";
function iz(e) {
  return typeof Buffer == "function" && fe(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1;
}
function Fb(e, t) {
  const n = t && t.property ? En(t.property) : Wt;
  return K(e) && !iz(e) ? rz(n(e), t) : n(JSON.parse(e));
}
Fb.responseType = "json";
function rz(e, t) {
  return !P(e) && DF(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
}
const oz = {
  interior: (e, t) => e !== t,
  exterior: (e, t) => e === t
};
function qM(e, t) {
  let n, i, r, o;
  return e = Fb(e, t), t && t.feature ? (n = qI, r = t.feature) : t && t.mesh ? (n = GI, r = t.mesh, o = oz[t.filter]) : I("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, o) : I("Invalid TopoJSON object: " + r), i && i.features || [i];
}
qM.responseType = "json";
const nh = {
  dsv: Cb,
  csv: cS(","),
  tsv: cS("	"),
  json: Fb,
  topojson: qM
};
function Mb(e, t) {
  return arguments.length > 1 ? (nh[e] = t, this) : ie(nh, e) ? nh[e] : null;
}
function WM(e) {
  const t = Mb(e);
  return t && t.responseType || "text";
}
function GM(e, t, n, i) {
  t = t || {};
  const r = Mb(t.type || "json");
  return r || I("Unknown data format type: " + t.type), e = r(e, t), t.parse && az(e, t.parse, n, i), ie(e, "columns") && delete e.columns, e;
}
function az(e, t, n, i) {
  if (!e.length)
    return;
  const r = Xc();
  n = n || r.timeParse, i = i || r.utcParse;
  let o = e.columns || Object.keys(e[0]), a, s, u, l, c, f;
  t === "auto" && (t = UM(e, o)), o = Object.keys(t);
  const d = o.map((h) => {
    const p = t[h];
    let g, m;
    if (p && (p.startsWith("date:") || p.startsWith("utc:")))
      return g = p.split(/:(.+)?/, 2), m = g[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (g[0] === "utc" ? i : n)(m);
    if (!uy[p])
      throw Error("Illegal format pattern: " + h + ":" + p);
    return uy[p];
  });
  for (u = 0, c = e.length, f = o.length; u < c; ++u)
    for (a = e[u], l = 0; l < f; ++l)
      s = o[l], a[s] = d[l](a[s]);
}
const xg = G8(
  typeof fetch < "u" && fetch,
  null
);
function wg(e) {
  const t = e || Wt, n = [], i = {};
  return n.add = (r) => {
    const o = t(r);
    return i[o] || (i[o] = 1, n.push(r)), n;
  }, n.remove = (r) => {
    const o = t(r);
    if (i[o]) {
      i[o] = 0;
      const a = n.indexOf(r);
      a >= 0 && n.splice(a, 1);
    }
    return n;
  }, n;
}
async function ih(e, t) {
  try {
    await t(e);
  } catch (n) {
    e.error(n);
  }
}
const HM = Symbol("vega_id");
let sz = 1;
function Eg(e) {
  return !!(e && te(e));
}
function te(e) {
  return e[HM];
}
function YM(e, t) {
  return e[HM] = t, e;
}
function Ce(e) {
  const t = e === Object(e) ? e : {
    data: e
  };
  return te(t) ? t : YM(t, sz++);
}
function Tb(e) {
  return _g(e, Ce({}));
}
function _g(e, t) {
  for (const n in e)
    t[n] = e[n];
  return t;
}
function XM(e, t) {
  return YM(t, te(e));
}
function Fs(e, t) {
  return e ? t ? (n, i) => e(n, i) || te(t(n)) - te(t(i)) : (n, i) => e(n, i) || te(n) - te(i) : null;
}
function VM(e) {
  return e && e.constructor === Ms;
}
function Ms() {
  const e = [], t = [], n = [], i = [], r = [];
  let o = null, a = !1;
  return {
    constructor: Ms,
    insert(s) {
      const u = X(s), l = u.length;
      for (let c = 0; c < l; ++c)
        e.push(u[c]);
      return this;
    },
    remove(s) {
      const u = fe(s) ? i : t, l = X(s), c = l.length;
      for (let f = 0; f < c; ++f)
        u.push(l[f]);
      return this;
    },
    modify(s, u, l) {
      const c = {
        field: u,
        value: Gt(l)
      };
      return fe(s) ? (c.filter = s, r.push(c)) : (c.tuple = s, n.push(c)), this;
    },
    encode(s, u) {
      return fe(s) ? r.push({
        filter: s,
        field: u
      }) : n.push({
        tuple: s,
        field: u
      }), this;
    },
    clean(s) {
      return o = s, this;
    },
    reflow() {
      return a = !0, this;
    },
    pulse(s, u) {
      const l = {}, c = {};
      let f, d, h, p, g, m;
      for (f = 0, d = u.length; f < d; ++f)
        l[te(u[f])] = 1;
      for (f = 0, d = t.length; f < d; ++f)
        g = t[f], l[te(g)] = -1;
      for (f = 0, d = i.length; f < d; ++f)
        p = i[f], u.forEach((v) => {
          p(v) && (l[te(v)] = -1);
        });
      for (f = 0, d = e.length; f < d; ++f)
        g = e[f], m = te(g), l[m] ? l[m] = 1 : s.add.push(Ce(e[f]));
      for (f = 0, d = u.length; f < d; ++f)
        g = u[f], l[te(g)] < 0 && s.rem.push(g);
      function y(v, b, x) {
        x ? v[b] = x(v) : s.encode = b, a || (c[te(v)] = v);
      }
      for (f = 0, d = n.length; f < d; ++f)
        h = n[f], g = h.tuple, p = h.field, m = l[te(g)], m > 0 && (y(g, p, h.value), s.modifies(p));
      for (f = 0, d = r.length; f < d; ++f)
        h = r[f], p = h.filter, u.forEach((v) => {
          p(v) && l[te(v)] > 0 && y(v, h.field, h.value);
        }), s.modifies(h.field);
      if (a)
        s.mod = t.length || i.length ? u.filter((v) => l[te(v)] > 0) : u.slice();
      else
        for (m in c)
          s.mod.push(c[m]);
      return (o || o == null && (t.length || i.length)) && s.clean(!0), s;
    }
  };
}
const rh = "_:mod:_";
function Sg() {
  Object.defineProperty(this, rh, {
    writable: !0,
    value: {}
  });
}
Sg.prototype = {
  set(e, t, n, i) {
    const r = this, o = r[e], a = r[rh];
    return t != null && t >= 0 ? (o[t] !== n || i) && (o[t] = n, a[t + ":" + e] = -1, a[e] = -1) : (o !== n || i) && (r[e] = n, a[e] = P(n) ? 1 + n.length : -1), r;
  },
  modified(e, t) {
    const n = this[rh];
    if (arguments.length) {
      if (P(e)) {
        for (let i = 0; i < e.length; ++i)
          if (n[e[i]])
            return !0;
        return !1;
      }
    } else {
      for (const i in n)
        if (n[i])
          return !0;
      return !1;
    }
    return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e];
  },
  clear() {
    return this[rh] = {}, this;
  }
};
let uz = 0;
const lz = "pulse", cz = new Sg(), fz = 1, dz = 2;
function Le(e, t, n, i) {
  this.id = ++uz, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i);
}
function fS(e) {
  return function(t) {
    const n = this.flags;
    return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this);
  };
}
Le.prototype = {
  targets() {
    return this._targets || (this._targets = wg(_f));
  },
  set(e) {
    return this.value !== e ? (this.value = e, 1) : 0;
  },
  skip: fS(fz),
  modified: fS(dz),
  parameters(e, t, n) {
    t = t !== !1;
    const i = this._argval = this._argval || new Sg(), r = this._argops = this._argops || [], o = [];
    let a, s, u, l;
    const c = (f, d, h) => {
      h instanceof Le ? (h !== this && (t && h.targets().add(this), o.push(h)), r.push({
        op: h,
        name: f,
        index: d
      })) : i.set(f, d, h);
    };
    for (a in e)
      if (s = e[a], a === lz)
        X(s).forEach((f) => {
          f instanceof Le ? f !== this && (f.targets().add(this), o.push(f)) : I("Pulse parameters must be operator instances.");
        }), this.source = s;
      else if (P(s))
        for (i.set(a, -1, Array(u = s.length)), l = 0; l < u; ++l)
          c(a, l, s[l]);
      else
        c(a, -1, s);
    return this.marshall().clear(), n && (r.initonly = !0), o;
  },
  marshall(e) {
    const t = this._argval || cz, n = this._argops;
    let i, r, o, a;
    if (n) {
      const s = n.length;
      for (r = 0; r < s; ++r)
        i = n[r], o = i.op, a = o.modified() && o.stamp === e, t.set(i.name, i.index, o.value, a);
      if (n.initonly) {
        for (r = 0; r < s; ++r)
          i = n[r], i.op.targets().remove(this);
        this._argops = null, this._update = null;
      }
    }
    return t;
  },
  detach() {
    const e = this._argops;
    let t, n, i, r;
    if (e)
      for (t = 0, n = e.length; t < n; ++t)
        i = e[t], r = i.op, r._targets && r._targets.remove(this);
    this.pulse = null, this.source = null;
  },
  evaluate(e) {
    const t = this._update;
    if (t) {
      const n = this.marshall(e.stamp), i = t.call(this, n, e);
      if (n.clear(), i !== this.value)
        this.value = i;
      else if (!this.modified())
        return e.StopPropagation;
    }
  },
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e;
  }
};
function hz(e, t, n, i) {
  let r = 1, o;
  return e instanceof Le ? o = e : e && e.prototype instanceof Le ? o = new e() : fe(e) ? o = new Le(null, e) : (r = 0, o = new Le(e, t)), this.rank(o), r && (i = n, n = t), n && this.connect(o, o.parameters(n, i)), this.touch(o), o;
}
function pz(e, t) {
  const n = e.rank, i = t.length;
  for (let r = 0; r < i; ++r)
    if (n < t[r].rank) {
      this.rerank(e);
      return;
    }
}
let gz = 0;
function Ag(e, t, n) {
  this.id = ++gz, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t);
}
function wo(e, t, n) {
  return new Ag(e, t, n);
}
Ag.prototype = {
  _filter: ei,
  _apply: Wt,
  targets() {
    return this._targets || (this._targets = wg(_f));
  },
  consume(e) {
    return arguments.length ? (this._consume = !!e, this) : !!this._consume;
  },
  receive(e) {
    if (this._filter(e)) {
      const t = this.value = this._apply(e), n = this._targets, i = n ? n.length : 0;
      for (let r = 0; r < i; ++r)
        n[r].receive(t);
      this._consume && (e.preventDefault(), e.stopPropagation());
    }
  },
  filter(e) {
    const t = wo(e);
    return this.targets().add(t), t;
  },
  apply(e) {
    const t = wo(null, e);
    return this.targets().add(t), t;
  },
  merge() {
    const e = wo();
    this.targets().add(e);
    for (let t = 0, n = arguments.length; t < n; ++t)
      arguments[t].targets().add(e);
    return e;
  },
  throttle(e) {
    let t = -1;
    return this.filter(() => {
      const n = Date.now();
      return n - t > e ? (t = n, 1) : 0;
    });
  },
  debounce(e) {
    const t = wo();
    return this.targets().add(wo(null, null, pb(e, (n) => {
      const i = n.dataflow;
      t.receive(n), i && i.run && i.run();
    }))), t;
  },
  between(e, t) {
    let n = !1;
    return e.targets().add(wo(null, null, () => n = !0)), t.targets().add(wo(null, null, () => n = !1)), this.filter(() => n);
  },
  detach() {
    this._filter = ei, this._targets = null;
  }
};
function mz(e, t, n, i) {
  const r = this, o = wo(n, i), a = function(l) {
    l.dataflow = r;
    try {
      o.receive(l);
    } catch (c) {
      r.error(c);
    } finally {
      r.run();
    }
  };
  let s;
  typeof e == "string" && typeof document < "u" ? s = document.querySelectorAll(e) : s = X(e);
  const u = s.length;
  for (let l = 0; l < u; ++l)
    s[l].addEventListener(t, a);
  return o;
}
function yz(e, t) {
  const n = this.locale();
  return GM(e, t, n.timeParse, n.utcParse);
}
function vz(e, t, n) {
  return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t));
}
async function bz(e, t) {
  const n = this;
  let i = 0, r;
  try {
    r = await n.loader().load(e, {
      context: "dataflow",
      response: WM(t && t.type)
    });
    try {
      r = n.parse(r, t);
    } catch (o) {
      i = -2, n.warn("Data ingestion failed", e, o);
    }
  } catch (o) {
    i = -1, n.warn("Loading failed", e, o);
  }
  return {
    data: r,
    status: i
  };
}
async function xz(e, t, n) {
  const i = this, r = i._pending || wz(i);
  r.requests += 1;
  const o = await i.request(t, n);
  return i.pulse(e, i.changeset().remove(ei).insert(o.data || [])), r.done(), o;
}
function wz(e) {
  let t;
  const n = new Promise((i) => t = i);
  return n.requests = 0, n.done = () => {
    --n.requests === 0 && (e._pending = null, t(e));
  }, e._pending = n;
}
const Ez = {
  skip: !0
};
function _z(e, t, n, i, r) {
  return (e instanceof Le ? Az : Sz)(this, e, t, n, i, r), this;
}
function Sz(e, t, n, i, r, o) {
  const a = ce({}, o, Ez);
  let s, u;
  fe(n) || (n = Gt(n)), i === void 0 ? s = (l) => e.touch(n(l)) : fe(i) ? (u = new Le(null, i, r, !1), s = (l) => {
    u.evaluate(l);
    const c = n(l), f = u.value;
    VM(f) ? e.pulse(c, f, o) : e.update(c, f, a);
  }) : s = (l) => e.update(n(l), i, a), t.apply(s);
}
function Az(e, t, n, i, r, o) {
  if (i === void 0)
    t.targets().add(n);
  else {
    const a = o || {}, s = new Le(null, $z(n, i), r, !1);
    s.modified(a.force), s.rank = t.rank, t.targets().add(s), n && (s.skip(!0), s.value = n.value, s.targets().add(n), e.connect(n, [s]));
  }
}
function $z(e, t) {
  return t = fe(t) ? t : Gt(t), e ? function(n, i) {
    const r = t(n, i);
    return e.skip() || (e.skip(r !== this.value).value = r), r;
  } : t;
}
function kz(e) {
  e.rank = ++this._rank;
}
function Cz(e) {
  const t = [e];
  let n, i, r;
  for (; t.length; )
    if (this.rank(n = t.pop()), i = n._targets)
      for (r = i.length; --r >= 0; )
        t.push(n = i[r]), n === e && I("Cycle detected in dataflow graph.");
}
const Ih = {}, Ji = 1 << 0, So = 1 << 1, Pr = 1 << 2, Fz = Ji | So, dS = Ji | Pr, Ys = Ji | So | Pr, hS = 1 << 3, jl = 1 << 4, pS = 1 << 5, gS = 1 << 6;
function jo(e, t, n) {
  this.dataflow = e, this.stamp = t == null ? -1 : t, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null;
}
function $0(e, t) {
  const n = [];
  return _o(e, t, (i) => n.push(i)), n;
}
function mS(e, t) {
  const n = {};
  return e.visit(t, (i) => {
    n[te(i)] = 1;
  }), (i) => n[te(i)] ? null : i;
}
function yd(e, t) {
  return e ? (n, i) => e(n, i) && t(n, i) : t;
}
jo.prototype = {
  StopPropagation: Ih,
  ADD: Ji,
  REM: So,
  MOD: Pr,
  ADD_REM: Fz,
  ADD_MOD: dS,
  ALL: Ys,
  REFLOW: hS,
  SOURCE: jl,
  NO_SOURCE: pS,
  NO_FIELDS: gS,
  fork(e) {
    return new jo(this.dataflow).init(this, e);
  },
  clone() {
    const e = this.fork(Ys);
    return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(Ys | jl);
  },
  addAll() {
    let e = this;
    return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new jo(this.dataflow).init(this), e.add = e.source, e.rem = []), e;
  },
  init(e, t) {
    const n = this;
    return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & gS) && (n.fields = e.fields), t & Ji ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & So ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & Pr ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & pS ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n;
  },
  runAfter(e) {
    this.dataflow.runAfter(e);
  },
  changed(e) {
    const t = e || Ys;
    return t & Ji && this.add.length || t & So && this.rem.length || t & Pr && this.mod.length;
  },
  reflow(e) {
    if (e)
      return this.fork(Ys).reflow();
    const t = this.add.length, n = this.source && this.source.length;
    return n && n !== t && (this.mod = this.source, t && this.filter(Pr, mS(this, Ji))), this;
  },
  clean(e) {
    return arguments.length ? (this.cleans = !!e, this) : this.cleans;
  },
  modifies(e) {
    const t = this.fields || (this.fields = {});
    return P(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
  },
  modified(e, t) {
    const n = this.fields;
    return (t || this.mod.length) && n ? arguments.length ? P(e) ? e.some((i) => n[i]) : n[e] : !!n : !1;
  },
  filter(e, t) {
    const n = this;
    return e & Ji && (n.addF = yd(n.addF, t)), e & So && (n.remF = yd(n.remF, t)), e & Pr && (n.modF = yd(n.modF, t)), e & jl && (n.srcF = yd(n.srcF, t)), n;
  },
  materialize(e) {
    e = e || Ys;
    const t = this;
    return e & Ji && t.addF && (t.add = $0(t.add, t.addF), t.addF = null), e & So && t.remF && (t.rem = $0(t.rem, t.remF), t.remF = null), e & Pr && t.modF && (t.mod = $0(t.mod, t.modF), t.modF = null), e & jl && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t;
  },
  visit(e, t) {
    const n = this, i = t;
    if (e & jl)
      return _o(n.source, n.srcF, i), n;
    e & Ji && _o(n.add, n.addF, i), e & So && _o(n.rem, n.remF, i), e & Pr && _o(n.mod, n.modF, i);
    const r = n.source;
    if (e & hS && r) {
      const o = n.add.length + n.mod.length;
      o === r.length || (o ? _o(r, mS(n, dS), i) : _o(r, n.srcF, i));
    }
    return n;
  }
};
function Ob(e, t, n, i) {
  const r = this;
  let o = 0;
  this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
  for (const a of n)
    if (a.stamp === t) {
      if (a.fields) {
        const s = r.fields || (r.fields = {});
        for (const u in a.fields)
          s[u] = 1;
      }
      a.changed(r.ADD) && (o |= r.ADD), a.changed(r.REM) && (o |= r.REM), a.changed(r.MOD) && (o |= r.MOD);
    }
  this.changes = o;
}
G(Ob, jo, {
  fork(e) {
    const t = new jo(this.dataflow).init(this, e & this.NO_FIELDS);
    return e !== void 0 && (e & t.ADD && this.visit(t.ADD, (n) => t.add.push(n)), e & t.REM && this.visit(t.REM, (n) => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, (n) => t.mod.push(n))), t;
  },
  changed(e) {
    return this.changes & e;
  },
  modified(e) {
    const t = this, n = t.fields;
    return n && t.changes & t.MOD ? P(e) ? e.some((i) => n[i]) : n[e] : 0;
  },
  filter() {
    I("MultiPulse does not support filtering.");
  },
  materialize() {
    I("MultiPulse does not support materialization.");
  },
  visit(e, t) {
    const n = this, i = n.pulses, r = i.length;
    let o = 0;
    if (e & n.SOURCE)
      for (; o < r; ++o)
        i[o].visit(e, t);
    else
      for (; o < r; ++o)
        i[o].stamp === n.stamp && i[o].visit(e, t);
    return n;
  }
});
async function Mz(e, t, n) {
  const i = this, r = [];
  if (i._pulse)
    return KM(i);
  if (i._pending && await i._pending, t && await ih(i, t), !i._touched.length)
    return i.debug("Dataflow invoked, but nothing to do."), i;
  const o = ++i._clock;
  i._pulse = new jo(i, o, e), i._touched.forEach((c) => i._enqueue(c, !0)), i._touched = wg(_f);
  let a = 0, s, u, l;
  try {
    for (; i._heap.size() > 0; ) {
      if (s = i._heap.pop(), s.rank !== s.qrank) {
        i._enqueue(s, !0);
        continue;
      }
      u = s.run(i._getPulse(s, e)), u.then ? u = await u : u.async && (r.push(u.async), u = Ih), u !== Ih && s._targets && s._targets.forEach((c) => i._enqueue(c)), ++a;
    }
  } catch (c) {
    i._heap.clear(), l = c;
  }
  if (i._input = {}, i._pulse = null, i.debug(`Pulse ${o}: ${a} operators`), l && (i._postrun = [], i.error(l)), i._postrun.length) {
    const c = i._postrun.sort((f, d) => d.priority - f.priority);
    i._postrun = [];
    for (let f = 0; f < c.length; ++f)
      await ih(i, c[f].callback);
  }
  return n && await ih(i, n), r.length && Promise.all(r).then((c) => i.runAsync(null, () => {
    c.forEach((f) => {
      try {
        f(i);
      } catch (d) {
        i.error(d);
      }
    });
  })), i;
}
async function Tz(e, t, n) {
  for (; this._running; )
    await this._running;
  const i = () => this._running = null;
  return (this._running = this.evaluate(e, t, n)).then(i, i), this._running;
}
function Oz(e, t, n) {
  return this._pulse ? KM(this) : (this.evaluate(e, t, n), this);
}
function Nz(e, t, n) {
  if (this._pulse || t)
    this._postrun.push({
      priority: n || 0,
      callback: e
    });
  else
    try {
      e(this);
    } catch (i) {
      this.error(i);
    }
}
function KM(e) {
  return e.error("Dataflow already running. Use runAsync() to chain invocations."), e;
}
function Dz(e, t) {
  const n = e.stamp < this._clock;
  n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e));
}
function Rz(e, t) {
  const n = e.source, i = this._clock;
  return n && P(n) ? new Ob(this, i, n.map((r) => r.pulse), t) : this._input[e.id] || Lz(this._pulse, n && n.pulse);
}
function Lz(e, t) {
  return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== Ih && (e.source = t.source), e);
}
const Nb = {
  skip: !1,
  force: !1
};
function Iz(e, t) {
  const n = t || Nb;
  return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this;
}
function Pz(e, t, n) {
  const i = n || Nb;
  return (e.set(t) || i.force) && this.touch(e, i), this;
}
function zz(e, t, n) {
  this.touch(e, n || Nb);
  const i = new jo(this, this._clock + (this._pulse ? 0 : 1)), r = e.pulse && e.pulse.source || [];
  return i.target = e, this._input[e.id] = t.pulse(i, r), this;
}
function Bz(e) {
  let t = [];
  return {
    clear: () => t = [],
    size: () => t.length,
    peek: () => t[0],
    push: (n) => (t.push(n), JM(t, 0, t.length - 1, e)),
    pop: () => {
      const n = t.pop();
      let i;
      return t.length ? (i = t[0], t[0] = n, jz(t, 0, e)) : i = n, i;
    }
  };
}
function JM(e, t, n, i) {
  let r, o;
  const a = e[n];
  for (; n > t; ) {
    if (o = n - 1 >> 1, r = e[o], i(a, r) < 0) {
      e[n] = r, n = o;
      continue;
    }
    break;
  }
  return e[n] = a;
}
function jz(e, t, n) {
  const i = t, r = e.length, o = e[t];
  let a = (t << 1) + 1, s;
  for (; a < r; )
    s = a + 1, s < r && n(e[a], e[s]) >= 0 && (a = s), e[t] = e[a], t = a, a = (t << 1) + 1;
  return e[t] = o, JM(e, i, t, n);
}
function gu() {
  this.logger(lb()), this.logLevel(sb), this._clock = 0, this._rank = 0, this._locale = kb();
  try {
    this._loader = xg();
  } catch {
  }
  this._touched = wg(_f), this._input = {}, this._pulse = null, this._heap = Bz((e, t) => e.qrank - t.qrank), this._postrun = [];
}
function Ul(e) {
  return function() {
    return this._log[e].apply(this, arguments);
  };
}
gu.prototype = {
  stamp() {
    return this._clock;
  },
  loader(e) {
    return arguments.length ? (this._loader = e, this) : this._loader;
  },
  locale(e) {
    return arguments.length ? (this._locale = e, this) : this._locale;
  },
  logger(e) {
    return arguments.length ? (this._log = e, this) : this._log;
  },
  error: Ul("error"),
  warn: Ul("warn"),
  info: Ul("info"),
  debug: Ul("debug"),
  logLevel: Ul("level"),
  cleanThreshold: 1e4,
  add: hz,
  connect: pz,
  rank: kz,
  rerank: Cz,
  pulse: zz,
  touch: Iz,
  update: Pz,
  changeset: Ms,
  ingest: vz,
  parse: yz,
  preload: xz,
  request: bz,
  events: mz,
  on: _z,
  evaluate: Mz,
  run: Oz,
  runAsync: Tz,
  runAfter: Nz,
  _enqueue: Dz,
  _getPulse: Rz
};
function D(e, t) {
  Le.call(this, e, null, t);
}
G(D, Le, {
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then((n) => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t;
  },
  evaluate(e) {
    const t = this.marshall(e.stamp), n = this.transform(t, e);
    return t.clear(), n;
  },
  transform() {
  }
});
const Tu = {};
function QM(e) {
  const t = ZM(e);
  return t && t.Definition || null;
}
function ZM(e) {
  return e = e && e.toLowerCase(), ie(Tu, e) ? Tu[e] : null;
}
function* eT(e, t) {
  if (t == null)
    for (let n of e)
      n != null && n !== "" && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i);
  }
}
function Db(e, t, n) {
  const i = Float64Array.from(eT(e, n));
  return i.sort(Kr), t.map((r) => KF(i, r));
}
function Rb(e, t) {
  return Db(e, [0.25, 0.5, 0.75], t);
}
function Lb(e, t) {
  const n = e.length, i = ZI(e, t), r = Rb(e, t), o = (r[2] - r[0]) / 1.34;
  return 1.06 * (Math.min(i, o) || i || Math.abs(r[0]) || 1) * Math.pow(n, -0.2);
}
function tT(e) {
  const t = e.maxbins || 20, n = e.base || 10, i = Math.log(n), r = e.divide || [5, 2];
  let o = e.extent[0], a = e.extent[1], s, u, l, c, f, d;
  const h = e.span || a - o || Math.abs(o) || 1;
  if (e.step)
    s = e.step;
  else if (e.steps) {
    for (c = h / t, f = 0, d = e.steps.length; f < d && e.steps[f] < c; ++f)
      ;
    s = e.steps[Math.max(0, f - 1)];
  } else {
    for (u = Math.ceil(Math.log(t) / i), l = e.minstep || 0, s = Math.max(l, Math.pow(n, Math.round(Math.log(h) / i) - u)); Math.ceil(h / s) > t; )
      s *= n;
    for (f = 0, d = r.length; f < d; ++f)
      c = s / r[f], c >= l && h / c <= t && (s = c);
  }
  c = Math.log(s);
  const p = c >= 0 ? 0 : ~~(-c / i) + 1, g = Math.pow(n, -p - 1);
  return (e.nice || e.nice === void 0) && (c = Math.floor(o / s + g) * s, o = o < c ? c - s : c, a = Math.ceil(a / s) * s), {
    start: o,
    stop: a === o ? o + s : a,
    step: s
  };
}
var ni = Math.random;
function Uz(e) {
  ni = e;
}
function nT(e, t, n, i) {
  if (!e.length)
    return [void 0, void 0];
  const r = Float64Array.from(eT(e, i)), o = r.length, a = t;
  let s, u, l, c;
  for (l = 0, c = Array(a); l < a; ++l) {
    for (s = 0, u = 0; u < o; ++u)
      s += r[~~(ni() * o)];
    c[l] = s / o;
  }
  return c.sort(Kr), [Z1(c, n / 2), Z1(c, 1 - n / 2)];
}
function iT(e, t, n, i) {
  i = i || ((d) => d);
  const r = e.length, o = new Float64Array(r);
  let a = 0, s = 1, u = i(e[0]), l = u, c = u + t, f;
  for (; s < r; ++s) {
    if (f = i(e[s]), f >= c) {
      for (l = (u + l) / 2; a < s; ++a)
        o[a] = l;
      c = f + t, u = f;
    }
    l = f;
  }
  for (l = (u + l) / 2; a < s; ++a)
    o[a] = l;
  return n ? qz(o, t + t / 4) : o;
}
function qz(e, t) {
  const n = e.length;
  let i = 0, r = 1, o, a;
  for (; e[i] === e[r]; )
    ++r;
  for (; r < n; ) {
    for (o = r + 1; e[r] === e[o]; )
      ++o;
    if (e[r] - e[r - 1] < t) {
      for (a = r + (i + o - r - r >> 1); a < r; )
        e[a++] = e[r];
      for (; a > r; )
        e[a--] = e[i];
    }
    i = r, r = o;
  }
  return e;
}
function Wz(e) {
  return function() {
    return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647;
  };
}
function Gz(e, t) {
  t == null && (t = e, e = 0);
  let n, i, r;
  const o = {
    min(a) {
      return arguments.length ? (n = a || 0, r = i - n, o) : n;
    },
    max(a) {
      return arguments.length ? (i = a || 0, r = i - n, o) : i;
    },
    sample() {
      return n + Math.floor(r * ni());
    },
    pdf(a) {
      return a === Math.floor(a) && a >= n && a < i ? 1 / r : 0;
    },
    cdf(a) {
      const s = Math.floor(a);
      return s < n ? 0 : s >= i ? 1 : (s - n + 1) / r;
    },
    icdf(a) {
      return a >= 0 && a <= 1 ? n - 1 + Math.floor(a * r) : NaN;
    }
  };
  return o.min(e).max(t);
}
const rT = Math.sqrt(2 * Math.PI), Hz = Math.SQRT2;
let ql = NaN;
function $g(e, t) {
  e = e || 0, t = t == null ? 1 : t;
  let n = 0, i = 0, r, o;
  if (ql === ql)
    n = ql, ql = NaN;
  else {
    do
      n = ni() * 2 - 1, i = ni() * 2 - 1, r = n * n + i * i;
    while (r === 0 || r > 1);
    o = Math.sqrt(-2 * Math.log(r) / r), n *= o, ql = i * o;
  }
  return e + n * t;
}
function Ib(e, t, n) {
  n = n == null ? 1 : n;
  const i = (e - (t || 0)) / n;
  return Math.exp(-0.5 * i * i) / (n * rT);
}
function kg(e, t, n) {
  t = t || 0, n = n == null ? 1 : n;
  const i = (e - t) / n, r = Math.abs(i);
  let o;
  if (r > 37)
    o = 0;
  else {
    const a = Math.exp(-r * r / 2);
    let s;
    r < 7.07106781186547 ? (s = 0.0352624965998911 * r + 0.700383064443688, s = s * r + 6.37396220353165, s = s * r + 33.912866078383, s = s * r + 112.079291497871, s = s * r + 221.213596169931, s = s * r + 220.206867912376, o = a * s, s = 0.0883883476483184 * r + 1.75566716318264, s = s * r + 16.064177579207, s = s * r + 86.7807322029461, s = s * r + 296.564248779674, s = s * r + 637.333633378831, s = s * r + 793.826512519948, s = s * r + 440.413735824752, o = o / s) : (s = r + 0.65, s = r + 4 / s, s = r + 3 / s, s = r + 2 / s, s = r + 1 / s, o = a / s / 2.506628274631);
  }
  return i > 0 ? 1 - o : o;
}
function Cg(e, t, n) {
  return e < 0 || e > 1 ? NaN : (t || 0) + (n == null ? 1 : n) * Hz * Yz(2 * e - 1);
}
function Yz(e) {
  let t = -Math.log((1 - e) * (1 + e)), n;
  return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
}
function Pb(e, t) {
  let n, i;
  const r = {
    mean(o) {
      return arguments.length ? (n = o || 0, r) : n;
    },
    stdev(o) {
      return arguments.length ? (i = o == null ? 1 : o, r) : i;
    },
    sample: () => $g(n, i),
    pdf: (o) => Ib(o, n, i),
    cdf: (o) => kg(o, n, i),
    icdf: (o) => Cg(o, n, i)
  };
  return r.mean(e).stdev(t);
}
function zb(e, t) {
  const n = Pb();
  let i = 0;
  const r = {
    data(o) {
      return arguments.length ? (e = o, i = o ? o.length : 0, r.bandwidth(t)) : e;
    },
    bandwidth(o) {
      return arguments.length ? (t = o, !t && e && (t = Lb(e)), r) : t;
    },
    sample() {
      return e[~~(ni() * i)] + t * n.sample();
    },
    pdf(o) {
      let a = 0, s = 0;
      for (; s < i; ++s)
        a += n.pdf((o - e[s]) / t);
      return a / t / i;
    },
    cdf(o) {
      let a = 0, s = 0;
      for (; s < i; ++s)
        a += n.cdf((o - e[s]) / t);
      return a / i;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return r.data(e);
}
function Bb(e, t) {
  return e = e || 0, t = t == null ? 1 : t, Math.exp(e + $g() * t);
}
function jb(e, t, n) {
  if (e <= 0)
    return 0;
  t = t || 0, n = n == null ? 1 : n;
  const i = (Math.log(e) - t) / n;
  return Math.exp(-0.5 * i * i) / (n * rT * e);
}
function Ub(e, t, n) {
  return kg(Math.log(e), t, n);
}
function qb(e, t, n) {
  return Math.exp(Cg(e, t, n));
}
function oT(e, t) {
  let n, i;
  const r = {
    mean(o) {
      return arguments.length ? (n = o || 0, r) : n;
    },
    stdev(o) {
      return arguments.length ? (i = o == null ? 1 : o, r) : i;
    },
    sample: () => Bb(n, i),
    pdf: (o) => jb(o, n, i),
    cdf: (o) => Ub(o, n, i),
    icdf: (o) => qb(o, n, i)
  };
  return r.mean(e).stdev(t);
}
function aT(e, t) {
  let n = 0, i;
  function r(a) {
    const s = [];
    let u = 0, l;
    for (l = 0; l < n; ++l)
      u += s[l] = a[l] == null ? 1 : +a[l];
    for (l = 0; l < n; ++l)
      s[l] /= u;
    return s;
  }
  const o = {
    weights(a) {
      return arguments.length ? (i = r(t = a || []), o) : t;
    },
    distributions(a) {
      return arguments.length ? (a ? (n = a.length, e = a) : (n = 0, e = []), o.weights(t)) : e;
    },
    sample() {
      const a = ni();
      let s = e[n - 1], u = i[0], l = 0;
      for (; l < n - 1; u += i[++l])
        if (a < u) {
          s = e[l];
          break;
        }
      return s.sample();
    },
    pdf(a) {
      let s = 0, u = 0;
      for (; u < n; ++u)
        s += i[u] * e[u].pdf(a);
      return s;
    },
    cdf(a) {
      let s = 0, u = 0;
      for (; u < n; ++u)
        s += i[u] * e[u].cdf(a);
      return s;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return o.distributions(e).weights(t);
}
function Wb(e, t) {
  return t == null && (t = e == null ? 1 : e, e = 0), e + (t - e) * ni();
}
function Gb(e, t, n) {
  return n == null && (n = t == null ? 1 : t, t = 0), e >= t && e <= n ? 1 / (n - t) : 0;
}
function Hb(e, t, n) {
  return n == null && (n = t == null ? 1 : t, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t);
}
function Yb(e, t, n) {
  return n == null && (n = t == null ? 1 : t, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN;
}
function sT(e, t) {
  let n, i;
  const r = {
    min(o) {
      return arguments.length ? (n = o || 0, r) : n;
    },
    max(o) {
      return arguments.length ? (i = o == null ? 1 : o, r) : i;
    },
    sample: () => Wb(n, i),
    pdf: (o) => Gb(o, n, i),
    cdf: (o) => Hb(o, n, i),
    icdf: (o) => Yb(o, n, i)
  };
  return t == null && (t = e == null ? 1 : e, e = 0), r.min(e).max(t);
}
function Xb(e, t, n) {
  let i = 0, r = 0;
  for (const o of e) {
    const a = n(o);
    t(o) == null || a == null || isNaN(a) || (i += (a - i) / ++r);
  }
  return {
    coef: [i],
    predict: () => i,
    rSquared: 0
  };
}
function kf(e, t, n, i) {
  const r = i - e * e, o = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
  return [t - o * e, o];
}
function Fg(e, t, n, i) {
  e = e.filter((h) => {
    let p = t(h), g = n(h);
    return p != null && (p = +p) >= p && g != null && (g = +g) >= g;
  }), i && e.sort((h, p) => t(h) - t(p));
  const r = e.length, o = new Float64Array(r), a = new Float64Array(r);
  let s = 0, u = 0, l = 0, c, f, d;
  for (d of e)
    o[s] = c = +t(d), a[s] = f = +n(d), ++s, u += (c - u) / s, l += (f - l) / s;
  for (s = 0; s < r; ++s)
    o[s] -= u, a[s] -= l;
  return [o, a, u, l];
}
function Cf(e, t, n, i) {
  let r = -1, o, a;
  for (const s of e)
    o = t(s), a = n(s), o != null && (o = +o) >= o && a != null && (a = +a) >= a && i(o, a, ++r);
}
function ml(e, t, n, i, r) {
  let o = 0, a = 0;
  return Cf(e, t, n, (s, u) => {
    const l = u - r(s), c = u - i;
    o += l * l, a += c * c;
  }), 1 - o / a;
}
function Vb(e, t, n) {
  let i = 0, r = 0, o = 0, a = 0, s = 0;
  Cf(e, t, n, (c, f) => {
    ++s, i += (c - i) / s, r += (f - r) / s, o += (c * f - o) / s, a += (c * c - a) / s;
  });
  const u = kf(i, r, o, a), l = (c) => u[0] + u[1] * c;
  return {
    coef: u,
    predict: l,
    rSquared: ml(e, t, n, r, l)
  };
}
function uT(e, t, n) {
  let i = 0, r = 0, o = 0, a = 0, s = 0;
  Cf(e, t, n, (c, f) => {
    ++s, c = Math.log(c), i += (c - i) / s, r += (f - r) / s, o += (c * f - o) / s, a += (c * c - a) / s;
  });
  const u = kf(i, r, o, a), l = (c) => u[0] + u[1] * Math.log(c);
  return {
    coef: u,
    predict: l,
    rSquared: ml(e, t, n, r, l)
  };
}
function lT(e, t, n) {
  const [i, r, o, a] = Fg(e, t, n);
  let s = 0, u = 0, l = 0, c = 0, f = 0, d, h, p;
  Cf(e, t, n, (v, b) => {
    d = i[f++], h = Math.log(b), p = d * b, s += (b * h - s) / f, u += (p - u) / f, l += (p * h - l) / f, c += (d * p - c) / f;
  });
  const [g, m] = kf(u / a, s / a, l / a, c / a), y = (v) => Math.exp(g + m * (v - o));
  return {
    coef: [Math.exp(g - m * o), m],
    predict: y,
    rSquared: ml(e, t, n, a, y)
  };
}
function cT(e, t, n) {
  let i = 0, r = 0, o = 0, a = 0, s = 0, u = 0;
  Cf(e, t, n, (f, d) => {
    const h = Math.log(f), p = Math.log(d);
    ++u, i += (h - i) / u, r += (p - r) / u, o += (h * p - o) / u, a += (h * h - a) / u, s += (d - s) / u;
  });
  const l = kf(i, r, o, a), c = (f) => l[0] * Math.pow(f, l[1]);
  return l[0] = Math.exp(l[0]), {
    coef: l,
    predict: c,
    rSquared: ml(e, t, n, s, c)
  };
}
function Kb(e, t, n) {
  const [i, r, o, a] = Fg(e, t, n), s = i.length;
  let u = 0, l = 0, c = 0, f = 0, d = 0, h, p, g, m;
  for (h = 0; h < s; )
    p = i[h], g = r[h++], m = p * p, u += (m - u) / h, l += (m * p - l) / h, c += (m * m - c) / h, f += (p * g - f) / h, d += (m * g - d) / h;
  const y = c - u * u, v = u * y - l * l, b = (d * u - f * l) / v, x = (f * y - d * l) / v, E = -b * u, _ = (w) => (w = w - o, b * w * w + x * w + E + a);
  return {
    coef: [E - x * o + b * o * o + a, x - 2 * b * o, b],
    predict: _,
    rSquared: ml(e, t, n, a, _)
  };
}
function fT(e, t, n, i) {
  if (i === 0)
    return Xb(e, t, n);
  if (i === 1)
    return Vb(e, t, n);
  if (i === 2)
    return Kb(e, t, n);
  const [r, o, a, s] = Fg(e, t, n), u = r.length, l = [], c = [], f = i + 1;
  let d, h, p, g, m;
  for (d = 0; d < f; ++d) {
    for (p = 0, g = 0; p < u; ++p)
      g += Math.pow(r[p], d) * o[p];
    for (l.push(g), m = new Float64Array(f), h = 0; h < f; ++h) {
      for (p = 0, g = 0; p < u; ++p)
        g += Math.pow(r[p], d + h);
      m[h] = g;
    }
    c.push(m);
  }
  c.push(l);
  const y = Vz(c), v = (b) => {
    b -= a;
    let x = s + y[0] + y[1] * b + y[2] * b * b;
    for (d = 3; d < f; ++d)
      x += y[d] * Math.pow(b, d);
    return x;
  };
  return {
    coef: Xz(f, y, -a, s),
    predict: v,
    rSquared: ml(e, t, n, s, v)
  };
}
function Xz(e, t, n, i) {
  const r = Array(e);
  let o, a, s, u;
  for (o = 0; o < e; ++o)
    r[o] = 0;
  for (o = e - 1; o >= 0; --o)
    for (s = t[o], u = 1, r[o] += s, a = 1; a <= o; ++a)
      u *= (o + 1 - a) / a, r[o - a] += s * Math.pow(n, a) * u;
  return r[0] += i, r;
}
function Vz(e) {
  const t = e.length - 1, n = [];
  let i, r, o, a, s;
  for (i = 0; i < t; ++i) {
    for (a = i, r = i + 1; r < t; ++r)
      Math.abs(e[i][r]) > Math.abs(e[i][a]) && (a = r);
    for (o = i; o < t + 1; ++o)
      s = e[o][i], e[o][i] = e[o][a], e[o][a] = s;
    for (r = i + 1; r < t; ++r)
      for (o = t; o >= i; o--)
        e[o][r] -= e[o][i] * e[i][r] / e[i][i];
  }
  for (r = t - 1; r >= 0; --r) {
    for (s = 0, o = r + 1; o < t; ++o)
      s += e[o][r] * n[o];
    n[r] = (e[t][r] - s) / e[r][r];
  }
  return n;
}
const yS = 2, vS = 1e-12;
function dT(e, t, n, i) {
  const [r, o, a, s] = Fg(e, t, n, !0), u = r.length, l = Math.max(2, ~~(i * u)), c = new Float64Array(u), f = new Float64Array(u), d = new Float64Array(u).fill(1);
  for (let h = -1; ++h <= yS; ) {
    const p = [0, l - 1];
    for (let m = 0; m < u; ++m) {
      const y = r[m], v = p[0], b = p[1], x = y - r[v] > r[b] - y ? v : b;
      let E = 0, _ = 0, w = 0, S = 0, C = 0;
      const $ = 1 / Math.abs(r[x] - y || 1);
      for (let F = v; F <= b; ++F) {
        const O = r[F], k = o[F], T = Kz(Math.abs(y - O) * $) * d[F], N = O * T;
        E += T, _ += N, w += k * T, S += k * N, C += O * N;
      }
      const [A, M] = kf(_ / E, w / E, S / E, C / E);
      c[m] = A + M * y, f[m] = Math.abs(o[m] - c[m]), Jz(r, m + 1, p);
    }
    if (h === yS)
      break;
    const g = JF(f);
    if (Math.abs(g) < vS)
      break;
    for (let m = 0, y, v; m < u; ++m)
      y = f[m] / (6 * g), d[m] = y >= 1 ? vS : (v = 1 - y * y) * v;
  }
  return Qz(r, c, a, s);
}
function Kz(e) {
  return (e = 1 - e * e * e) * e * e;
}
function Jz(e, t, n) {
  const i = e[t];
  let r = n[0], o = n[1] + 1;
  if (!(o >= e.length))
    for (; t > r && e[o] - i <= i - e[r]; )
      n[0] = ++r, n[1] = o, ++o;
}
function Qz(e, t, n, i) {
  const r = e.length, o = [];
  let a = 0, s = 0, u = [], l;
  for (; a < r; ++a)
    l = e[a] + n, u[0] === l ? u[1] += (t[a] - u[1]) / ++s : (s = 0, u[1] += i, u = [l, t[a]], o.push(u));
  return u[1] += i, o;
}
const Zz = 0.5 * Math.PI / 180;
function Mg(e, t, n, i) {
  n = n || 25, i = Math.max(n, i || 200);
  const r = (g) => [g, e(g)], o = t[0], a = t[1], s = a - o, u = s / i, l = [r(o)], c = [];
  if (n === i) {
    for (let g = 1; g < i; ++g)
      l.push(r(o + g / n * s));
    return l.push(r(a)), l;
  } else {
    c.push(r(a));
    for (let g = n; --g > 0; )
      c.push(r(o + g / n * s));
  }
  let f = l[0], d = c[c.length - 1];
  const h = 1 / s, p = e9(f[1], c);
  for (; d; ) {
    const g = r((f[0] + d[0]) / 2);
    g[0] - f[0] >= u && t9(f, g, d, h, p) > Zz ? c.push(g) : (f = d, l.push(d), c.pop()), d = c[c.length - 1];
  }
  return l;
}
function e9(e, t) {
  let n = e, i = e;
  const r = t.length;
  for (let o = 0; o < r; ++o) {
    const a = t[o][1];
    a < n && (n = a), a > i && (i = a);
  }
  return 1 / (i - n);
}
function t9(e, t, n, i, r) {
  const o = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])), a = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
  return Math.abs(o - a);
}
function n9(e) {
  return (t) => {
    const n = e.length;
    let i = 1, r = String(e[0](t));
    for (; i < n; ++i)
      r += "|" + e[i](t);
    return r;
  };
}
function ly(e) {
  return !e || !e.length ? function() {
    return "";
  } : e.length === 1 ? e[0] : n9(e);
}
function hT(e, t, n) {
  return n || e + (t ? "_" + t : "");
}
const k0 = () => {
}, i9 = {
  init: k0,
  add: k0,
  rem: k0,
  idx: 0
}, Vc = {
  values: {
    init: (e) => e.cell.store = !0,
    value: (e) => e.cell.data.values(),
    idx: -1
  },
  count: {
    value: (e) => e.cell.num
  },
  __count__: {
    value: (e) => e.missing + e.valid
  },
  missing: {
    value: (e) => e.missing
  },
  valid: {
    value: (e) => e.valid
  },
  sum: {
    init: (e) => e.sum = 0,
    value: (e) => e.sum,
    add: (e, t) => e.sum += +t,
    rem: (e, t) => e.sum -= t
  },
  product: {
    init: (e) => e.product = 1,
    value: (e) => e.valid ? e.product : void 0,
    add: (e, t) => e.product *= t,
    rem: (e, t) => e.product /= t
  },
  mean: {
    init: (e) => e.mean = 0,
    value: (e) => e.valid ? e.mean : void 0,
    add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
    rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
  },
  average: {
    value: (e) => e.valid ? e.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (e) => e.dev = 0,
    value: (e) => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
    add: (e, t) => e.dev += e.mean_d * (t - e.mean),
    rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (e) => e.valid > 1 ? e.dev / e.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (e) => e.cell.data.distinct(e.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (e) => e.cell.data.ci0(e.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (e) => e.cell.data.ci1(e.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (e) => e.cell.data.q2(e.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (e) => e.cell.data.q1(e.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (e) => e.cell.data.q3(e.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (e) => e.min = void 0,
    value: (e) => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
    add: (e, t) => {
      (t < e.min || e.min === void 0) && (e.min = t);
    },
    rem: (e, t) => {
      t <= e.min && (e.min = NaN);
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (e) => e.max = void 0,
    value: (e) => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
    add: (e, t) => {
      (t > e.max || e.max === void 0) && (e.max = t);
    },
    rem: (e, t) => {
      t >= e.max && (e.max = NaN);
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (e) => e.argmin = void 0,
    value: (e) => e.argmin || e.cell.data.argmin(e.get),
    add: (e, t, n) => {
      t < e.min && (e.argmin = n);
    },
    rem: (e, t) => {
      t <= e.min && (e.argmin = void 0);
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (e) => e.argmax = void 0,
    value: (e) => e.argmax || e.cell.data.argmax(e.get),
    add: (e, t, n) => {
      t > e.max && (e.argmax = n);
    },
    rem: (e, t) => {
      t >= e.max && (e.argmax = void 0);
    },
    req: ["max", "values"],
    idx: 3
  }
}, Ff = Object.keys(Vc).filter((e) => e !== "__count__");
function r9(e, t) {
  return (n) => ce({
    name: e,
    out: n || e
  }, i9, t);
}
[...Ff, "__count__"].forEach((e) => {
  Vc[e] = r9(e, Vc[e]);
});
function pT(e, t) {
  return Vc[e](t);
}
function gT(e, t) {
  return e.idx - t.idx;
}
function o9(e) {
  const t = {};
  e.forEach((i) => t[i.name] = i);
  const n = (i) => {
    !i.req || i.req.forEach((r) => {
      t[r] || n(t[r] = Vc[r]());
    });
  };
  return e.forEach(n), Object.values(t).sort(gT);
}
function a9() {
  this.valid = 0, this.missing = 0, this._ops.forEach((e) => e.init(this));
}
function s9(e, t) {
  if (e == null || e === "") {
    ++this.missing;
    return;
  }
  e === e && (++this.valid, this._ops.forEach((n) => n.add(this, e, t)));
}
function u9(e, t) {
  if (e == null || e === "") {
    --this.missing;
    return;
  }
  e === e && (--this.valid, this._ops.forEach((n) => n.rem(this, e, t)));
}
function l9(e) {
  return this._out.forEach((t) => e[t.out] = t.value(this)), e;
}
function mT(e, t) {
  const n = t || Wt, i = o9(e), r = e.slice().sort(gT);
  function o(a) {
    this._ops = i, this._out = r, this.cell = a, this.init();
  }
  return o.prototype.init = a9, o.prototype.add = s9, o.prototype.rem = u9, o.prototype.set = l9, o.prototype.get = n, o.fields = e.map((a) => a.out), o;
}
function Jb(e) {
  this._key = e ? En(e) : te, this.reset();
}
const Ft = Jb.prototype;
Ft.reset = function() {
  this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
};
Ft.add = function(e) {
  this._add.push(e);
};
Ft.rem = function(e) {
  this._rem.push(e);
};
Ft.values = function() {
  if (this._get = null, this._rem.length === 0)
    return this._add;
  const e = this._add, t = this._rem, n = this._key, i = e.length, r = t.length, o = Array(i - r), a = {};
  let s, u, l;
  for (s = 0; s < r; ++s)
    a[n(t[s])] = 1;
  for (s = 0, u = 0; s < i; ++s)
    a[n(l = e[s])] ? a[n(l)] = 0 : o[u++] = l;
  return this._rem = [], this._add = o;
};
Ft.distinct = function(e) {
  const t = this.values(), n = {};
  let i = t.length, r = 0, o;
  for (; --i >= 0; )
    o = e(t[i]) + "", ie(n, o) || (n[o] = 1, ++r);
  return r;
};
Ft.extent = function(e) {
  if (this._get !== e || !this._ext) {
    const t = this.values(), n = OF(t, e);
    this._ext = [t[n[0]], t[n[1]]], this._get = e;
  }
  return this._ext;
};
Ft.argmin = function(e) {
  return this.extent(e)[0] || {};
};
Ft.argmax = function(e) {
  return this.extent(e)[1] || {};
};
Ft.min = function(e) {
  const t = this.extent(e)[0];
  return t != null ? e(t) : void 0;
};
Ft.max = function(e) {
  const t = this.extent(e)[1];
  return t != null ? e(t) : void 0;
};
Ft.quartile = function(e) {
  return (this._get !== e || !this._q) && (this._q = Rb(this.values(), e), this._get = e), this._q;
};
Ft.q1 = function(e) {
  return this.quartile(e)[0];
};
Ft.q2 = function(e) {
  return this.quartile(e)[1];
};
Ft.q3 = function(e) {
  return this.quartile(e)[2];
};
Ft.ci = function(e) {
  return (this._get !== e || !this._ci) && (this._ci = nT(this.values(), 1e3, 0.05, e), this._get = e), this._ci;
};
Ft.ci0 = function(e) {
  return this.ci(e)[0];
};
Ft.ci1 = function(e) {
  return this.ci(e)[1];
};
function Yo(e) {
  D.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
}
Yo.Definition = {
  type: "Aggregate",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: Ff
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "drop",
    type: "boolean",
    default: !0
  }, {
    name: "cross",
    type: "boolean",
    default: !1
  }, {
    name: "key",
    type: "field"
  }]
};
G(Yo, D, {
  transform(e, t) {
    const n = this, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.modified();
    return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : /* @__PURE__ */ Object.create(null), t.visit(t.SOURCE, (o) => n.add(o))) : (n.value = n.value || n.init(e), t.visit(t.REM, (o) => n.rem(o)), t.visit(t.ADD, (o) => n.add(o))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i);
  },
  cross() {
    const e = this, t = e.value, n = e._dnames, i = n.map(() => ({})), r = n.length;
    function o(s) {
      let u, l, c, f;
      for (u in s)
        for (c = s[u].tuple, l = 0; l < r; ++l)
          i[l][f = c[n[l]]] = f;
    }
    o(e._prev), o(t);
    function a(s, u, l) {
      const c = n[l], f = i[l++];
      for (const d in f) {
        const h = s ? s + "|" + d : d;
        u[c] = f[d], l < r ? a(h, u, l) : t[h] || e.cell(h, u);
      }
    }
    a("", {}, 0);
  },
  init(e) {
    const t = this._inputs = [], n = this._outputs = [], i = {};
    function r(m) {
      const y = X(Bt(m)), v = y.length;
      let b = 0, x;
      for (; b < v; ++b)
        i[x = y[b]] || (i[x] = 1, t.push(x));
    }
    this._dims = X(e.groupby), this._dnames = this._dims.map((m) => {
      const y = Ze(m);
      return r(m), n.push(y), y;
    }), this.cellkey = e.key ? e.key : ly(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
    const o = e.fields || [null], a = e.ops || ["count"], s = e.as || [], u = o.length, l = {};
    let c, f, d, h, p, g;
    for (u !== a.length && I("Unmatched number of fields and aggregate ops."), g = 0; g < u; ++g) {
      if (c = o[g], f = a[g], c == null && f !== "count" && I("Null aggregate field specified."), h = Ze(c), p = hT(f, h, s[g]), n.push(p), f === "count") {
        this._counts.push(p);
        continue;
      }
      d = l[h], d || (r(c), d = l[h] = [], d.field = c, this._measures.push(d)), f !== "count" && (this._countOnly = !1), d.push(pT(f, p));
    }
    return this._measures = this._measures.map((m) => mT(m, m.field)), /* @__PURE__ */ Object.create(null);
  },
  cellkey: ly(),
  cell(e, t) {
    let n = this.value[e];
    return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n;
  },
  newcell(e, t) {
    const n = {
      key: e,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[e]),
      stamp: this.stamp,
      store: !1
    };
    if (!this._countOnly) {
      const i = this._measures, r = i.length;
      n.agg = Array(r);
      for (let o = 0; o < r; ++o)
        n.agg[o] = new i[o](n);
    }
    return n.store && (n.data = new Jb()), n;
  },
  newtuple(e, t) {
    const n = this._dnames, i = this._dims, r = i.length, o = {};
    for (let a = 0; a < r; ++a)
      o[n[a]] = i[a](e);
    return t ? XM(t.tuple, o) : Ce(o);
  },
  clean() {
    const e = this.value;
    for (const t in e)
      e[t].num === 0 && delete e[t];
  },
  add(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num += 1, this._countOnly)
      return;
    n.store && n.data.add(e);
    const i = n.agg;
    for (let r = 0, o = i.length; r < o; ++r)
      i[r].add(i[r].get(e), e);
  },
  rem(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num -= 1, this._countOnly)
      return;
    n.store && n.data.rem(e);
    const i = n.agg;
    for (let r = 0, o = i.length; r < o; ++r)
      i[r].rem(i[r].get(e), e);
  },
  celltuple(e) {
    const t = e.tuple, n = this._counts;
    e.store && e.data.values();
    for (let i = 0, r = n.length; i < r; ++i)
      t[n[i]] = e.num;
    if (!this._countOnly) {
      const i = e.agg;
      for (let r = 0, o = i.length; r < o; ++r)
        i[r].set(t);
    }
    return t;
  },
  changes(e) {
    const t = this._adds, n = this._mods, i = this._prev, r = this._drop, o = e.add, a = e.rem, s = e.mod;
    let u, l, c, f;
    if (i)
      for (l in i)
        u = i[l], (!r || u.num) && a.push(u.tuple);
    for (c = 0, f = this._alen; c < f; ++c)
      o.push(this.celltuple(t[c])), t[c] = null;
    for (c = 0, f = this._mlen; c < f; ++c)
      u = n[c], (u.num === 0 && r ? a : s).push(this.celltuple(u)), n[c] = null;
    return this._alen = this._mlen = 0, this._prev = null, e;
  }
});
const c9 = 1e-14;
function Qb(e) {
  D.call(this, null, e);
}
Qb.Definition = {
  type: "Bin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "anchor",
    type: "number"
  }, {
    name: "maxbins",
    type: "number",
    default: 20
  }, {
    name: "base",
    type: "number",
    default: 10
  }, {
    name: "divide",
    type: "number",
    array: !0,
    default: [5, 2]
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "span",
    type: "number"
  }, {
    name: "step",
    type: "number"
  }, {
    name: "steps",
    type: "number",
    array: !0
  }, {
    name: "minstep",
    type: "number",
    default: 0
  }, {
    name: "nice",
    type: "boolean",
    default: !0
  }, {
    name: "name",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["bin0", "bin1"]
  }]
};
G(Qb, D, {
  transform(e, t) {
    const n = e.interval !== !1, i = this._bins(e), r = i.start, o = i.step, a = e.as || ["bin0", "bin1"], s = a[0], u = a[1];
    let l;
    return e.modified() ? (t = t.reflow(!0), l = t.SOURCE) : l = t.modified(Bt(e.field)) ? t.ADD_MOD : t.ADD, t.visit(l, n ? (c) => {
      const f = i(c);
      c[s] = f, c[u] = f == null ? null : r + o * (1 + (f - r) / o);
    } : (c) => c[s] = i(c)), t.modifies(n ? a : s);
  },
  _bins(e) {
    if (this.value && !e.modified())
      return this.value;
    const t = e.field, n = tT(e), i = n.step;
    let r = n.start, o = r + Math.ceil((n.stop - r) / i) * i, a, s;
    (a = e.anchor) != null && (s = a - (r + i * Math.floor((a - r) / i)), r += s, o += s);
    const u = function(l) {
      let c = It(t(l));
      return c == null ? null : c < r ? -1 / 0 : c > o ? 1 / 0 : (c = Math.max(r, Math.min(c, o - i)), r + i * Math.floor(c9 + (c - r) / i));
    };
    return u.start = r, u.stop = n.stop, u.step = i, this.value = Fn(u, Bt(t), e.name || "bin_" + Ze(t));
  }
});
function yT(e, t, n) {
  const i = e;
  let r = t || [], o = n || [], a = {}, s = 0;
  return {
    add: (u) => o.push(u),
    remove: (u) => a[i(u)] = ++s,
    size: () => r.length,
    data: (u, l) => (s && (r = r.filter((c) => !a[i(c)]), a = {}, s = 0), l && u && r.sort(u), o.length && (r = u ? PF(u, r, o.sort(u)) : r.concat(o), o = []), r)
  };
}
function Zb(e) {
  D.call(this, [], e);
}
Zb.Definition = {
  type: "Collect",
  metadata: {
    source: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }]
};
G(Zb, D, {
  transform(e, t) {
    const n = t.fork(t.ALL), i = yT(te, this.value, n.materialize(n.ADD).add), r = e.sort, o = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
    return n.visit(n.REM, i.remove), this.modified(o), this.value = n.source = i.data(Fs(r), o), t.source && t.source.root && (this.value.root = t.source.root), n;
  }
});
function vT(e) {
  Le.call(this, null, f9, e);
}
G(vT, Le);
function f9(e) {
  return this.value && !e.modified() ? this.value : hb(e.fields, e.orders);
}
function ex(e) {
  D.call(this, null, e);
}
ex.Definition = {
  type: "CountPattern",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "case",
    type: "enum",
    values: ["upper", "lower", "mixed"],
    default: "mixed"
  }, {
    name: "pattern",
    type: "string",
    default: '[\\w"]+'
  }, {
    name: "stopwords",
    type: "string",
    default: ""
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["text", "count"]
  }]
};
function d9(e, t, n) {
  switch (t) {
    case "upper":
      e = e.toUpperCase();
      break;
    case "lower":
      e = e.toLowerCase();
      break;
  }
  return e.match(n);
}
G(ex, D, {
  transform(e, t) {
    const n = (f) => (d) => {
      for (var h = d9(s(d), e.case, o) || [], p, g = 0, m = h.length; g < m; ++g)
        a.test(p = h[g]) || f(p);
    }, i = this._parameterCheck(e, t), r = this._counts, o = this._match, a = this._stop, s = e.field, u = e.as || ["text", "count"], l = n((f) => r[f] = 1 + (r[f] || 0)), c = n((f) => r[f] -= 1);
    return i ? t.visit(t.SOURCE, l) : (t.visit(t.ADD, l), t.visit(t.REM, c)), this._finish(t, u);
  },
  _parameterCheck(e, t) {
    let n = !1;
    return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n;
  },
  _finish(e, t) {
    const n = this._counts, i = this._tuples || (this._tuples = {}), r = t[0], o = t[1], a = e.fork(e.NO_SOURCE | e.NO_FIELDS);
    let s, u, l;
    for (s in n)
      u = i[s], l = n[s] || 0, !u && l ? (i[s] = u = Ce({}), u[r] = s, u[o] = l, a.add.push(u)) : l === 0 ? (u && a.rem.push(u), n[s] = null, i[s] = null) : u[o] !== l && (u[o] = l, a.mod.push(u));
    return a.modifies(t);
  }
});
function tx(e) {
  D.call(this, null, e);
}
tx.Definition = {
  type: "Cross",
  metadata: {
    generates: !0
  },
  params: [{
    name: "filter",
    type: "expr"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["a", "b"]
  }]
};
G(tx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.as || ["a", "b"], r = i[0], o = i[1], a = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
    let s = this.value;
    return a ? (s && (n.rem = s), s = t.materialize(t.SOURCE).source, n.add = this.value = h9(s, r, o, e.filter || ei)) : n.mod = s, n.source = this.value, n.modifies(i);
  }
});
function h9(e, t, n, i) {
  for (var r = [], o = {}, a = e.length, s = 0, u, l; s < a; ++s)
    for (o[t] = l = e[s], u = 0; u < a; ++u)
      o[n] = e[u], i(o) && (r.push(Ce(o)), o = {}, o[t] = l);
  return r;
}
const bS = {
  kde: zb,
  mixture: aT,
  normal: Pb,
  lognormal: oT,
  uniform: sT
}, p9 = "distributions", xS = "function", g9 = "field";
function bT(e, t) {
  const n = e[xS];
  ie(bS, n) || I("Unknown distribution function: " + n);
  const i = bS[n]();
  for (const r in e)
    r === g9 ? i.data((e.from || t()).map(e[r])) : r === p9 ? i[r](e[r].map((o) => bT(o, t))) : typeof i[r] === xS && i[r](e[r]);
  return i;
}
function nx(e) {
  D.call(this, null, e);
}
const xT = [{
  key: {
    function: "normal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "lognormal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "uniform"
  },
  params: [{
    name: "min",
    type: "number",
    default: 0
  }, {
    name: "max",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "kde"
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "from",
    type: "data"
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }]
}], m9 = {
  key: {
    function: "mixture"
  },
  params: [{
    name: "distributions",
    type: "param",
    array: !0,
    params: xT
  }, {
    name: "weights",
    type: "number",
    array: !0
  }]
};
nx.Definition = {
  type: "Density",
  metadata: {
    generates: !0
  },
  params: [{
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "method",
    type: "string",
    default: "pdf",
    values: ["pdf", "cdf"]
  }, {
    name: "distribution",
    type: "param",
    params: xT.concat(m9)
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
G(nx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = bT(e.distribution, y9(t)), r = e.steps || e.minsteps || 25, o = e.steps || e.maxsteps || 200;
      let a = e.method || "pdf";
      a !== "pdf" && a !== "cdf" && I("Invalid density method: " + a), !e.extent && !i.data && I("Missing density extent parameter."), a = i[a];
      const s = e.as || ["value", "density"], u = e.extent || hr(i.data()), l = Mg(a, u, r, o).map((c) => {
        const f = {};
        return f[s[0]] = c[0], f[s[1]] = c[1], Ce(f);
      });
      this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
function y9(e) {
  return () => e.materialize(e.SOURCE).source;
}
function wT(e, t) {
  return e ? e.map((n, i) => t[i] || Ze(n)) : null;
}
function ix(e, t, n) {
  const i = [], r = (f) => f(u);
  let o, a, s, u, l, c;
  if (t == null)
    i.push(e.map(n));
  else
    for (o = {}, a = 0, s = e.length; a < s; ++a)
      u = e[a], l = t.map(r), c = o[l], c || (o[l] = c = [], c.dims = l, i.push(c)), c.push(n(u));
  return i;
}
const ET = "bin";
function rx(e) {
  D.call(this, null, e);
}
rx.Definition = {
  type: "DotBin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "step",
    type: "number"
  }, {
    name: "smooth",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: ET
  }]
};
const v9 = (e, t) => Sf(hr(e, t)) / 30;
G(rx, D, {
  transform(e, t) {
    if (this.value && !(e.modified() || t.changed()))
      return t;
    const n = t.materialize(t.SOURCE).source, i = ix(t.source, e.groupby, Wt), r = e.smooth || !1, o = e.field, a = e.step || v9(n, o), s = Fs((p, g) => o(p) - o(g)), u = e.as || ET, l = i.length;
    let c = 1 / 0, f = -1 / 0, d = 0, h;
    for (; d < l; ++d) {
      const p = i[d].sort(s);
      h = -1;
      for (const g of iT(p, a, r, o))
        g < c && (c = g), g > f && (f = g), p[++h][u] = g;
    }
    return this.value = {
      start: c,
      stop: f,
      step: a
    }, t.reflow(!0).modifies(u);
  }
});
function _T(e) {
  Le.call(this, null, b9, e), this.modified(!0);
}
G(_T, Le);
function b9(e) {
  const t = e.expr;
  return this.value && !e.modified("expr") ? this.value : Fn((n) => t(n, e), Bt(t), Ze(t));
}
function ox(e) {
  D.call(this, [void 0, void 0], e);
}
ox.Definition = {
  type: "Extent",
  metadata: {},
  params: [{
    name: "field",
    type: "field",
    required: !0
  }]
};
G(ox, D, {
  transform(e, t) {
    const n = this.value, i = e.field, r = t.changed() || t.modified(i.fields) || e.modified("field");
    let o = n[0], a = n[1];
    if ((r || o == null) && (o = 1 / 0, a = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, (s) => {
      const u = It(i(s));
      u != null && (u < o && (o = u), u > a && (a = u));
    }), !Number.isFinite(o) || !Number.isFinite(a)) {
      let s = Ze(i);
      s && (s = ` for field "${s}"`), t.dataflow.warn(`Infinite extent${s}: [${o}, ${a}]`), o = a = void 0;
    }
    this.value = [o, a];
  }
});
function ax(e, t) {
  Le.call(this, e), this.parent = t, this.count = 0;
}
G(ax, Le, {
  connect(e) {
    return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this;
  },
  add(e) {
    this.count += 1, this.value.add.push(e);
  },
  rem(e) {
    this.count -= 1, this.value.rem.push(e);
  },
  mod(e) {
    this.value.mod.push(e);
  },
  init(e) {
    this.value.init(e, e.NO_SOURCE);
  },
  evaluate() {
    return this.value;
  }
});
function Tg(e) {
  D.call(this, {}, e), this._keys = fl();
  const t = this._targets = [];
  t.active = 0, t.forEach = (n) => {
    for (let i = 0, r = t.active; i < r; ++i)
      n(t[i], i, t);
  };
}
G(Tg, D, {
  activate(e) {
    this._targets[this._targets.active++] = e;
  },
  subflow(e, t, n, i) {
    const r = this.value;
    let o = ie(r, e) && r[e], a, s;
    return o ? o.value.stamp < n.stamp && (o.init(n), this.activate(o)) : (s = i || (s = this._group[e]) && s.tuple, a = n.dataflow, o = new ax(n.fork(n.NO_SOURCE), this), a.add(o).connect(t(a, e, s)), r[e] = o, this.activate(o)), o;
  },
  clean() {
    const e = this.value;
    let t = 0;
    for (const n in e)
      if (e[n].count === 0) {
        const i = e[n].detachSubflow;
        i && i(), delete e[n], ++t;
      }
    if (t) {
      const n = this._targets.filter((i) => i && i.count > 0);
      this.initTargets(n);
    }
  },
  initTargets(e) {
    const t = this._targets, n = t.length, i = e ? e.length : 0;
    let r = 0;
    for (; r < i; ++r)
      t[r] = e[r];
    for (; r < n && t[r] != null; ++r)
      t[r] = null;
    t.active = i;
  },
  transform(e, t) {
    const n = t.dataflow, i = e.key, r = e.subflow, o = this._keys, a = e.modified("key"), s = (u) => this.subflow(u, r, t);
    return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, (u) => {
      const l = te(u), c = o.get(l);
      c !== void 0 && (o.delete(l), s(c).rem(u));
    }), t.visit(t.ADD, (u) => {
      const l = i(u);
      o.set(te(u), l), s(l).add(u);
    }), a || t.modified(i.fields) ? t.visit(t.MOD, (u) => {
      const l = te(u), c = o.get(l), f = i(u);
      c === f ? s(f).mod(u) : (o.set(l, f), s(c).rem(u), s(f).add(u));
    }) : t.changed(t.MOD) && t.visit(t.MOD, (u) => {
      s(o.get(te(u))).mod(u);
    }), a && t.visit(t.REFLOW, (u) => {
      const l = te(u), c = o.get(l), f = i(u);
      c !== f && (o.set(l, f), s(c).rem(u), s(f).add(u));
    }), t.clean() ? n.runAfter(() => {
      this.clean(), o.clean();
    }) : o.empty > n.cleanThreshold && n.runAfter(o.clean), t;
  }
});
function ST(e) {
  Le.call(this, null, x9, e);
}
G(ST, Le);
function x9(e) {
  return this.value && !e.modified() ? this.value : P(e.name) ? X(e.name).map((t) => En(t)) : En(e.name, e.as);
}
function sx(e) {
  D.call(this, fl(), e);
}
sx.Definition = {
  type: "Filter",
  metadata: {
    changes: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }]
};
G(sx, D, {
  transform(e, t) {
    const n = t.dataflow, i = this.value, r = t.fork(), o = r.add, a = r.rem, s = r.mod, u = e.expr;
    let l = !0;
    t.visit(t.REM, (f) => {
      const d = te(f);
      i.has(d) ? i.delete(d) : a.push(f);
    }), t.visit(t.ADD, (f) => {
      u(f, e) ? o.push(f) : i.set(te(f), 1);
    });
    function c(f) {
      const d = te(f), h = u(f, e), p = i.get(d);
      h && p ? (i.delete(d), o.push(f)) : !h && !p ? (i.set(d, 1), a.push(f)) : l && h && !p && s.push(f);
    }
    return t.visit(t.MOD, c), e.modified() && (l = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r;
  }
});
function ux(e) {
  D.call(this, [], e);
}
ux.Definition = {
  type: "Flatten",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "index",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
G(ux, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = wT(i, e.as || []), o = e.index || null, a = r.length;
    return n.rem = this.value, t.visit(t.SOURCE, (s) => {
      const u = i.map((p) => p(s)), l = u.reduce((p, g) => Math.max(p, g.length), 0);
      let c = 0, f, d, h;
      for (; c < l; ++c) {
        for (d = Tb(s), f = 0; f < a; ++f)
          d[r[f]] = (h = u[f][c]) == null ? null : h;
        o && (d[o] = c), n.add.push(d);
      }
    }), this.value = n.source = n.add, o && n.modifies(o), n.modifies(r);
  }
});
function lx(e) {
  D.call(this, [], e);
}
lx.Definition = {
  type: "Fold",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["key", "value"]
  }]
};
G(lx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = i.map(Ze), o = e.as || ["key", "value"], a = o[0], s = o[1], u = i.length;
    return n.rem = this.value, t.visit(t.SOURCE, (l) => {
      for (let c = 0, f; c < u; ++c)
        f = Tb(l), f[a] = r[c], f[s] = i[c](l), n.add.push(f);
    }), this.value = n.source = n.add, n.modifies(o);
  }
});
function cx(e) {
  D.call(this, null, e);
}
cx.Definition = {
  type: "Formula",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }, {
    name: "as",
    type: "string",
    required: !0
  }, {
    name: "initonly",
    type: "boolean"
  }]
};
G(cx, D, {
  transform(e, t) {
    const n = e.expr, i = e.as, r = e.modified(), o = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
    return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(o, (a) => a[i] = n(a, e));
  }
});
function AT(e) {
  D.call(this, [], e);
}
G(AT, D, {
  transform(e, t) {
    const n = t.fork(t.ALL), i = e.generator;
    let r = this.value, o = e.size - r.length, a, s, u;
    if (o > 0) {
      for (a = []; --o >= 0; )
        a.push(u = Ce(i(e))), r.push(u);
      n.add = n.add.length ? n.materialize(n.ADD).add.concat(a) : a;
    } else
      s = r.slice(0, -o), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(s) : s, r = r.slice(-o);
    return n.source = this.value = r, n;
  }
});
const vd = {
  value: "value",
  median: JF,
  mean: oP,
  min: Q1,
  max: Ka
}, w9 = [];
function fx(e) {
  D.call(this, [], e);
}
fx.Definition = {
  type: "Impute",
  metadata: {
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "keyvals",
    array: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "enum",
    default: "value",
    values: ["value", "mean", "median", "max", "min"]
  }, {
    name: "value",
    default: 0
  }]
};
function E9(e) {
  var t = e.method || vd.value, n;
  if (vd[t] == null)
    I("Unrecognized imputation method: " + t);
  else
    return t === vd.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : vd[t];
}
function _9(e) {
  const t = e.field;
  return (n) => n ? t(n) : NaN;
}
G(fx, D, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = E9(e), r = _9(e), o = Ze(e.field), a = Ze(e.key), s = (e.groupby || []).map(Ze), u = S9(t.source, e.groupby, e.key, e.keyvals), l = [], c = this.value, f = u.domain.length, d, h, p, g, m, y, v, b, x, E;
    for (m = 0, b = u.length; m < b; ++m)
      for (d = u[m], p = d.values, h = NaN, v = 0; v < f; ++v)
        if (d[v] == null) {
          for (g = u.domain[v], E = {
            _impute: !0
          }, y = 0, x = p.length; y < x; ++y)
            E[s[y]] = p[y];
          E[a] = g, E[o] = Number.isNaN(h) ? h = i(d, r) : h, l.push(Ce(E));
        }
    return l.length && (n.add = n.materialize(n.ADD).add.concat(l)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = l, n;
  }
});
function S9(e, t, n, i) {
  var r = (y) => y(m), o = [], a = i ? i.slice() : [], s = {}, u = {}, l, c, f, d, h, p, g, m;
  for (a.forEach((y, v) => s[y] = v + 1), d = 0, g = e.length; d < g; ++d)
    m = e[d], p = n(m), h = s[p] || (s[p] = a.push(p)), c = (l = t ? t.map(r) : w9) + "", (f = u[c]) || (f = u[c] = [], o.push(f), f.values = l), f[h - 1] = m;
  return o.domain = a, o;
}
function dx(e) {
  Yo.call(this, e);
}
dx.Definition = {
  type: "JoinAggregate",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: Ff
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "key",
    type: "field"
  }]
};
G(dx, Yo, {
  transform(e, t) {
    const n = this, i = e.modified();
    let r;
    return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, (o) => n.add(o))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, (o) => n.rem(o)), t.visit(t.ADD, (o) => n.add(o))), n.changes(), t.visit(t.SOURCE, (o) => {
      ce(o, r[n.cellkey(o)].tuple);
    }), t.reflow(i).modifies(this._outputs);
  },
  changes() {
    const e = this._adds, t = this._mods;
    let n, i;
    for (n = 0, i = this._alen; n < i; ++n)
      this.celltuple(e[n]), e[n] = null;
    for (n = 0, i = this._mlen; n < i; ++n)
      this.celltuple(t[n]), t[n] = null;
    this._alen = this._mlen = 0;
  }
});
function hx(e) {
  D.call(this, null, e);
}
hx.Definition = {
  type: "KDE",
  metadata: {
    generates: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "cumulative",
    type: "boolean",
    default: !1
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
G(hx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = ix(i, e.groupby, e.field), o = (e.groupby || []).map(Ze), a = e.bandwidth, s = e.cumulative ? "cdf" : "pdf", u = e.as || ["value", "density"], l = [];
      let c = e.extent, f = e.steps || e.minsteps || 25, d = e.steps || e.maxsteps || 200;
      s !== "pdf" && s !== "cdf" && I("Invalid density method: " + s), e.resolve === "shared" && (c || (c = hr(i, e.field)), f = d = e.steps || d), r.forEach((h) => {
        const p = zb(h, a)[s], g = e.counts ? h.length : 1, m = c || hr(h);
        Mg(p, m, f, d).forEach((y) => {
          const v = {};
          for (let b = 0; b < o.length; ++b)
            v[o[b]] = h.dims[b];
          v[u[0]] = y[0], v[u[1]] = y[1] * g, l.push(Ce(v));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
function $T(e) {
  Le.call(this, null, A9, e);
}
G($T, Le);
function A9(e) {
  return this.value && !e.modified() ? this.value : gb(e.fields, e.flat);
}
function kT(e) {
  D.call(this, [], e), this._pending = null;
}
G(kT, D, {
  transform(e, t) {
    const n = t.dataflow;
    return this._pending ? C0(this, t, this._pending) : $9(e) ? t.StopPropagation : e.values ? C0(this, t, n.parse(e.values, e.format)) : e.async ? {
      async: n.request(e.url, e.format).then((r) => (this._pending = X(r.data), (o) => o.touch(this)))
    } : n.request(e.url, e.format).then((i) => C0(this, t, X(i.data)));
  }
});
function $9(e) {
  return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"));
}
function C0(e, t, n) {
  n.forEach(Ce);
  const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
  return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i;
}
function px(e) {
  D.call(this, {}, e);
}
px.Definition = {
  type: "Lookup",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "index",
    type: "index",
    params: [{
      name: "from",
      type: "data",
      required: !0
    }, {
      name: "key",
      type: "field",
      required: !0
    }]
  }, {
    name: "values",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0
  }, {
    name: "default",
    default: null
  }]
};
G(px, D, {
  transform(e, t) {
    const n = e.fields, i = e.index, r = e.values, o = e.default == null ? null : e.default, a = e.modified(), s = n.length;
    let u = a ? t.SOURCE : t.ADD, l = t, c = e.as, f, d, h;
    return r ? (d = r.length, s > 1 && !c && I('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== s * d && I('The "as" parameter has too few output field names.'), c = c || r.map(Ze), f = function(p) {
      for (var g = 0, m = 0, y, v; g < s; ++g)
        if (v = i.get(n[g](p)), v == null)
          for (y = 0; y < d; ++y, ++m)
            p[c[m]] = o;
        else
          for (y = 0; y < d; ++y, ++m)
            p[c[m]] = r[y](v);
    }) : (c || I("Missing output field names."), f = function(p) {
      for (var g = 0, m; g < s; ++g)
        m = i.get(n[g](p)), p[c[g]] = m == null ? o : m;
    }), a ? l = t.reflow(!0) : (h = n.some((p) => t.modified(p.fields)), u |= h ? t.MOD : 0), t.visit(u, f), l.modifies(c);
  }
});
function CT(e) {
  Le.call(this, null, k9, e);
}
G(CT, Le);
function k9(e) {
  if (this.value && !e.modified())
    return this.value;
  const t = e.extents, n = t.length;
  let i = 1 / 0, r = -1 / 0, o, a;
  for (o = 0; o < n; ++o)
    a = t[o], a[0] < i && (i = a[0]), a[1] > r && (r = a[1]);
  return [i, r];
}
function FT(e) {
  Le.call(this, null, C9, e);
}
G(FT, Le);
function C9(e) {
  return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), []);
}
function MT(e) {
  D.call(this, null, e);
}
G(MT, D, {
  transform(e, t) {
    return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function gx(e) {
  Yo.call(this, e);
}
gx.Definition = {
  type: "Pivot",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "value",
    type: "field",
    required: !0
  }, {
    name: "op",
    type: "enum",
    values: Ff,
    default: "sum"
  }, {
    name: "limit",
    type: "number",
    default: 0
  }, {
    name: "key",
    type: "field"
  }]
};
G(gx, Yo, {
  _transform: Yo.prototype.transform,
  transform(e, t) {
    return this._transform(F9(e, t), t);
  }
});
function F9(e, t) {
  const n = e.field, i = e.value, r = (e.op === "count" ? "__count__" : e.op) || "sum", o = Bt(n).concat(Bt(i)), a = T9(n, e.limit || 0, t);
  return t.changed() && e.set("__pivot__", null, null, !0), {
    key: e.key,
    groupby: e.groupby,
    ops: a.map(() => r),
    fields: a.map((s) => M9(s, n, i, o)),
    as: a.map((s) => s + ""),
    modified: e.modified.bind(e)
  };
}
function M9(e, t, n, i) {
  return Fn((r) => t(r) === e ? n(r) : NaN, i, e + "");
}
function T9(e, t, n) {
  const i = {}, r = [];
  return n.visit(n.SOURCE, (o) => {
    const a = e(o);
    i[a] || (i[a] = 1, r.push(a));
  }), r.sort(hg), t ? r.slice(0, t) : r;
}
function TT(e) {
  Tg.call(this, e);
}
G(TT, Tg, {
  transform(e, t) {
    const n = e.subflow, i = e.field, r = (o) => this.subflow(te(o), n, t, o);
    return (e.modified("field") || i && t.modified(Bt(i))) && I("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, (o) => {
      const a = r(o);
      i(o).forEach((s) => a.mod(s));
    }), t.visit(t.ADD, (o) => {
      const a = r(o);
      i(o).forEach((s) => a.add(Ce(s)));
    }), t.visit(t.REM, (o) => {
      const a = r(o);
      i(o).forEach((s) => a.rem(s));
    })) : (t.visit(t.MOD, (o) => r(o).mod(o)), t.visit(t.ADD, (o) => r(o).add(o)), t.visit(t.REM, (o) => r(o).rem(o))), t.clean() && t.runAfter(() => this.clean()), t;
  }
});
function mx(e) {
  D.call(this, null, e);
}
mx.Definition = {
  type: "Project",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }]
};
G(mx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = wT(e.fields, e.as || []), o = i ? (s, u) => O9(s, u, i, r) : _g;
    let a;
    return this.value ? a = this.value : (t = t.addAll(), a = this.value = {}), t.visit(t.REM, (s) => {
      const u = te(s);
      n.rem.push(a[u]), a[u] = null;
    }), t.visit(t.ADD, (s) => {
      const u = o(s, Ce({}));
      a[te(s)] = u, n.add.push(u);
    }), t.visit(t.MOD, (s) => {
      n.mod.push(o(s, a[te(s)]));
    }), n;
  }
});
function O9(e, t, n, i) {
  for (let r = 0, o = n.length; r < o; ++r)
    t[i[r]] = n[r](e);
  return t;
}
function OT(e) {
  D.call(this, null, e);
}
G(OT, D, {
  transform(e, t) {
    return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function yx(e) {
  D.call(this, null, e);
}
yx.Definition = {
  type: "Quantile",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "probs",
    type: "number",
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 0.01
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["prob", "value"]
  }]
};
const N9 = 1e-14;
G(yx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = e.as || ["prob", "value"];
    if (this.value && !e.modified() && !t.changed())
      return n.source = this.value, n;
    const r = t.materialize(t.SOURCE).source, o = ix(r, e.groupby, e.field), a = (e.groupby || []).map(Ze), s = [], u = e.step || 0.01, l = e.probs || Pn(u / 2, 1 - N9, u), c = l.length;
    return o.forEach((f) => {
      const d = Db(f, l);
      for (let h = 0; h < c; ++h) {
        const p = {};
        for (let g = 0; g < a.length; ++g)
          p[a[g]] = f.dims[g];
        p[i[0]] = l[h], p[i[1]] = d[h], s.push(Ce(p));
      }
    }), this.value && (n.rem = this.value), this.value = n.add = n.source = s, n;
  }
});
function NT(e) {
  D.call(this, null, e);
}
G(NT, D, {
  transform(e, t) {
    let n, i;
    return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, (r) => {
      const o = te(r);
      n.rem.push(i[o]), i[o] = null;
    }), t.visit(t.ADD, (r) => {
      const o = Tb(r);
      i[te(r)] = o, n.add.push(o);
    }), t.visit(t.MOD, (r) => {
      const o = i[te(r)];
      for (const a in r)
        o[a] = r[a], n.modifies(a);
      n.mod.push(o);
    })), n;
  }
});
function vx(e) {
  D.call(this, [], e), this.count = 0;
}
vx.Definition = {
  type: "Sample",
  metadata: {},
  params: [{
    name: "size",
    type: "number",
    default: 1e3
  }]
};
G(vx, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.modified("size"), r = e.size, o = this.value.reduce((c, f) => (c[te(f)] = 1, c), {});
    let a = this.value, s = this.count, u = 0;
    function l(c) {
      let f, d;
      a.length < r ? a.push(c) : (d = ~~((s + 1) * ni()), d < a.length && d >= u && (f = a[d], o[te(f)] && n.rem.push(f), a[d] = c)), ++s;
    }
    if (t.rem.length && (t.visit(t.REM, (c) => {
      const f = te(c);
      o[f] && (o[f] = -1, n.rem.push(c)), --s;
    }), a = a.filter((c) => o[te(c)] !== -1)), (t.rem.length || i) && a.length < r && t.source && (u = s = a.length, t.visit(t.SOURCE, (c) => {
      o[te(c)] || l(c);
    }), u = -1), i && a.length > r) {
      const c = a.length - r;
      for (let f = 0; f < c; ++f)
        o[te(a[f])] = -1, n.rem.push(a[f]);
      a = a.slice(c);
    }
    return t.mod.length && t.visit(t.MOD, (c) => {
      o[te(c)] && n.mod.push(c);
    }), t.add.length && t.visit(t.ADD, l), (t.add.length || u < 0) && (n.add = a.filter((c) => !o[te(c)])), this.count = s, this.value = n.source = a, n;
  }
});
function bx(e) {
  D.call(this, null, e);
}
bx.Definition = {
  type: "Sequence",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "start",
    type: "number",
    required: !0
  }, {
    name: "stop",
    type: "number",
    required: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "as",
    type: "string",
    default: "data"
  }]
};
G(bx, D, {
  transform(e, t) {
    if (this.value && !e.modified())
      return;
    const n = t.materialize().fork(t.MOD), i = e.as || "data";
    return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = Pn(e.start, e.stop, e.step || 1).map((r) => {
      const o = {};
      return o[i] = r, Ce(o);
    }), n.add = t.add.concat(this.value), n;
  }
});
function DT(e) {
  D.call(this, null, e), this.modified(!0);
}
G(DT, D, {
  transform(e, t) {
    return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function xx(e) {
  D.call(this, null, e);
}
const RT = ["unit0", "unit1"];
xx.Definition = {
  type: "TimeUnit",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "units",
    type: "enum",
    values: Eb,
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "maxbins",
    type: "number",
    default: 40
  }, {
    name: "extent",
    type: "date",
    array: !0
  }, {
    name: "timezone",
    type: "enum",
    default: "local",
    values: ["local", "utc"]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: RT
  }]
};
G(xx, D, {
  transform(e, t) {
    const n = e.field, i = e.interval !== !1, r = e.timezone === "utc", o = this._floor(e, t), a = (r ? gl : pl)(o.unit).offset, s = e.as || RT, u = s[0], l = s[1], c = o.step;
    let f = o.start || 1 / 0, d = o.stop || -1 / 0, h = t.ADD;
    return (e.modified() || t.changed(t.REM) || t.modified(Bt(n))) && (t = t.reflow(!0), h = t.SOURCE, f = 1 / 0, d = -1 / 0), t.visit(h, (p) => {
      const g = n(p);
      let m, y;
      g == null ? (p[u] = null, i && (p[l] = null)) : (p[u] = m = y = o(g), i && (p[l] = y = a(m, c)), m < f && (f = m), y > d && (d = y));
    }), o.start = f, o.stop = d, t.modifies(i ? s : u);
  },
  _floor(e, t) {
    const n = e.timezone === "utc", {
      units: i,
      step: r
    } = e.units ? {
      units: e.units,
      step: e.step || 1
    } : AM({
      extent: e.extent || hr(t.materialize(t.SOURCE).source, e.field),
      maxbins: e.maxbins
    }), o = _b(i), a = this.value || {}, s = (n ? mM : gM)(o, r);
    return s.unit = xe(o), s.units = o, s.step = r, s.start = a.start, s.stop = a.stop, this.value = s;
  }
});
function LT(e) {
  D.call(this, fl(), e);
}
G(LT, D, {
  transform(e, t) {
    const n = t.dataflow, i = e.field, r = this.value, o = (s) => r.set(i(s), s);
    let a = !0;
    return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, o)) : t.changed() ? (t.visit(t.REM, (s) => r.delete(i(s))), t.visit(t.ADD, o)) : a = !1, this.modified(a), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork();
  }
});
function IT(e) {
  D.call(this, null, e);
}
G(IT, D, {
  transform(e, t) {
    (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(Fs(e.sort)) : t.source).map(e.field));
  }
});
function D9(e, t, n, i) {
  const r = Kc[e](t, n);
  return {
    init: r.init || Co,
    update: function(o, a) {
      a[i] = r.next(o);
    }
  };
}
const Kc = {
  row_number: function() {
    return {
      next: (e) => e.index + 1
    };
  },
  rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, i = t.data;
        return n && t.compare(i[n - 1], i[n]) ? e = n + 1 : e;
      }
    };
  },
  dense_rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, i = t.data;
        return n && t.compare(i[n - 1], i[n]) ? ++e : e;
      }
    };
  },
  percent_rank: function() {
    const e = Kc.rank(), t = e.next;
    return {
      init: e.init,
      next: (n) => (t(n) - 1) / (n.data.length - 1)
    };
  },
  cume_dist: function() {
    let e;
    return {
      init: () => e = 0,
      next: (t) => {
        const n = t.data, i = t.compare;
        let r = t.index;
        if (e < r) {
          for (; r + 1 < n.length && !i(n[r], n[r + 1]); )
            ++r;
          e = r;
        }
        return (1 + e) / n.length;
      }
    };
  },
  ntile: function(e, t) {
    t = +t, t > 0 || I("ntile num must be greater than zero.");
    const n = Kc.cume_dist(), i = n.next;
    return {
      init: n.init,
      next: (r) => Math.ceil(t * i(r))
    };
  },
  lag: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const i = n.index - t;
        return i >= 0 ? e(n.data[i]) : null;
      }
    };
  },
  lead: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const i = n.index + t, r = n.data;
        return i < r.length ? e(r[i]) : null;
      }
    };
  },
  first_value: function(e) {
    return {
      next: (t) => e(t.data[t.i0])
    };
  },
  last_value: function(e) {
    return {
      next: (t) => e(t.data[t.i1 - 1])
    };
  },
  nth_value: function(e, t) {
    return t = +t, t > 0 || I("nth_value nth must be greater than zero."), {
      next: (n) => {
        const i = n.i0 + (t - 1);
        return i < n.i1 ? e(n.data[i]) : null;
      }
    };
  },
  prev_value: function(e) {
    let t;
    return {
      init: () => t = null,
      next: (n) => {
        const i = e(n.data[n.index]);
        return i != null ? t = i : t;
      }
    };
  },
  next_value: function(e) {
    let t, n;
    return {
      init: () => (t = null, n = -1),
      next: (i) => {
        const r = i.data;
        return i.index <= n ? t : (n = R9(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n]);
      }
    };
  }
};
function R9(e, t, n) {
  for (let i = t.length; n < i; ++n)
    if (e(t[n]) != null)
      return n;
  return -1;
}
const L9 = Object.keys(Kc);
function PT(e) {
  const t = X(e.ops), n = X(e.fields), i = X(e.params), r = X(e.as), o = this.outputs = [], a = this.windows = [], s = {}, u = {}, l = [], c = [];
  let f = !0;
  function d(h) {
    X(Bt(h)).forEach((p) => s[p] = 1);
  }
  d(e.sort), t.forEach((h, p) => {
    const g = n[p], m = Ze(g), y = hT(h, m, r[p]);
    if (d(g), o.push(y), ie(Kc, h))
      a.push(D9(h, n[p], i[p], y));
    else {
      if (g == null && h !== "count" && I("Null aggregate field specified."), h === "count") {
        l.push(y);
        return;
      }
      f = !1;
      let v = u[m];
      v || (v = u[m] = [], v.field = g, c.push(v)), v.push(pT(h, y));
    }
  }), (l.length || c.length) && (this.cell = I9(c, l, f)), this.inputs = Object.keys(s);
}
const zT = PT.prototype;
zT.init = function() {
  this.windows.forEach((e) => e.init()), this.cell && this.cell.init();
};
zT.update = function(e, t) {
  const n = this.cell, i = this.windows, r = e.data, o = i && i.length;
  let a;
  if (n) {
    for (a = e.p0; a < e.i0; ++a)
      n.rem(r[a]);
    for (a = e.p1; a < e.i1; ++a)
      n.add(r[a]);
    n.set(t);
  }
  for (a = 0; a < o; ++a)
    i[a].update(e, t);
};
function I9(e, t, n) {
  e = e.map((u) => mT(u, u.field));
  const i = {
    num: 0,
    agg: null,
    store: !1,
    count: t
  };
  if (!n)
    for (var r = e.length, o = i.agg = Array(r), a = 0; a < r; ++a)
      o[a] = new e[a](i);
  if (i.store)
    var s = i.data = new Jb();
  return i.add = function(u) {
    if (i.num += 1, !n) {
      s && s.add(u);
      for (let l = 0; l < r; ++l)
        o[l].add(o[l].get(u), u);
    }
  }, i.rem = function(u) {
    if (i.num -= 1, !n) {
      s && s.rem(u);
      for (let l = 0; l < r; ++l)
        o[l].rem(o[l].get(u), u);
    }
  }, i.set = function(u) {
    let l, c;
    for (s && s.values(), l = 0, c = t.length; l < c; ++l)
      u[t[l]] = i.num;
    if (!n)
      for (l = 0, c = o.length; l < c; ++l)
        o[l].set(u);
  }, i.init = function() {
    i.num = 0, s && s.reset();
    for (let u = 0; u < r; ++u)
      o[u].init();
  }, i;
}
function wx(e) {
  D.call(this, {}, e), this._mlen = 0, this._mods = [];
}
wx.Definition = {
  type: "Window",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: L9.concat(Ff)
  }, {
    name: "params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "frame",
    type: "number",
    null: !0,
    array: !0,
    length: 2,
    default: [null, 0]
  }, {
    name: "ignorePeers",
    type: "boolean",
    default: !1
  }]
};
G(wx, D, {
  transform(e, t) {
    this.stamp = t.stamp;
    const n = e.modified(), i = Fs(e.sort), r = ly(e.groupby), o = (s) => this.group(r(s));
    let a = this.state;
    (!a || n) && (a = this.state = new PT(e)), n || t.modified(a.inputs) ? (this.value = {}, t.visit(t.SOURCE, (s) => o(s).add(s))) : (t.visit(t.REM, (s) => o(s).remove(s)), t.visit(t.ADD, (s) => o(s).add(s)));
    for (let s = 0, u = this._mlen; s < u; ++s)
      P9(this._mods[s], a, i, e);
    return this._mlen = 0, this._mods = [], t.reflow(n).modifies(a.outputs);
  },
  group(e) {
    let t = this.value[e];
    return t || (t = this.value[e] = yT(te), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
  }
});
function P9(e, t, n, i) {
  const r = i.sort, o = r && !i.ignorePeers, a = i.frame || [null, 0], s = e.data(n), u = s.length, l = o ? Af(r) : null, c = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: s,
    compare: r || Gt(-1)
  };
  t.init();
  for (let f = 0; f < u; ++f)
    z9(c, a, f, u), o && B9(c, l), t.update(c, s[f]);
}
function z9(e, t, n, i) {
  e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n;
}
function B9(e, t) {
  const n = e.i0, i = e.i1 - 1, r = e.compare, o = e.data, a = o.length - 1;
  n > 0 && !r(o[n], o[n - 1]) && (e.i0 = t.left(o, o[n])), i < a && !r(o[i], o[i + 1]) && (e.i1 = t.right(o, o[i]));
}
const j9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aggregate: Yo,
  bin: Qb,
  collect: Zb,
  compare: vT,
  countpattern: ex,
  cross: tx,
  density: nx,
  dotbin: rx,
  expression: _T,
  extent: ox,
  facet: Tg,
  field: ST,
  filter: sx,
  flatten: ux,
  fold: lx,
  formula: cx,
  generate: AT,
  impute: fx,
  joinaggregate: dx,
  kde: hx,
  key: $T,
  load: kT,
  lookup: px,
  multiextent: CT,
  multivalues: FT,
  params: MT,
  pivot: gx,
  prefacet: TT,
  project: mx,
  proxy: OT,
  quantile: yx,
  relay: NT,
  sample: vx,
  sequence: bx,
  sieve: DT,
  subflow: ax,
  timeunit: xx,
  tupleindex: LT,
  values: IT,
  window: wx
}, Symbol.toStringTag, { value: "Module" }));
function Fe(e) {
  return function() {
    return e;
  };
}
const wS = Math.abs, Tt = Math.atan2, _a = Math.cos, U9 = Math.max, F0 = Math.min, Yi = Math.sin, qa = Math.sqrt, Nt = 1e-12, Ou = Math.PI, Ph = Ou / 2, BT = 2 * Ou;
function q9(e) {
  return e > 1 ? 0 : e < -1 ? Ou : Math.acos(e);
}
function ES(e) {
  return e >= 1 ? Ph : e <= -1 ? -Ph : Math.asin(e);
}
const cy = Math.PI, fy = 2 * cy, Ra = 1e-6, W9 = fy - Ra;
function jT(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function G9(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return jT;
  const n = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, o = i.length; r < o; ++r)
      this._ += Math.round(arguments[r] * n) / n + i[r];
  };
}
class Ex {
  constructor(t) {
    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = t == null ? jT : G9(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, i, r) {
    this._append`Q${+t},${+n},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, i, r, o, a) {
    this._append`C${+t},${+n},${+i},${+r},${this._x1 = +o},${this._y1 = +a}`;
  }
  arcTo(t, n, i, r, o) {
    if (t = +t, n = +n, i = +i, r = +r, o = +o, o < 0)
      throw new Error(`negative radius: ${o}`);
    let a = this._x1, s = this._y1, u = i - t, l = r - n, c = a - t, f = s - n, d = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (d > Ra)
      if (!(Math.abs(f * u - l * c) > Ra) || !o)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let h = i - a, p = r - s, g = u * u + l * l, m = h * h + p * p, y = Math.sqrt(g), v = Math.sqrt(d), b = o * Math.tan((cy - Math.acos((g + d - m) / (2 * y * v))) / 2), x = b / v, E = b / y;
        Math.abs(x - 1) > Ra && this._append`L${t + x * c},${n + x * f}`, this._append`A${o},${o},0,0,${+(f * h > c * p)},${this._x1 = t + E * u},${this._y1 = n + E * l}`;
      }
  }
  arc(t, n, i, r, o, a) {
    if (t = +t, n = +n, i = +i, a = !!a, i < 0)
      throw new Error(`negative radius: ${i}`);
    let s = i * Math.cos(r), u = i * Math.sin(r), l = t + s, c = n + u, f = 1 ^ a, d = a ? r - o : o - r;
    this._x1 === null ? this._append`M${l},${c}` : (Math.abs(this._x1 - l) > Ra || Math.abs(this._y1 - c) > Ra) && this._append`L${l},${c}`, i && (d < 0 && (d = d % fy + fy), d > W9 ? this._append`A${i},${i},0,1,${f},${t - s},${n - u}A${i},${i},0,1,${f},${this._x1 = l},${this._y1 = c}` : d > Ra && this._append`A${i},${i},0,${+(d >= cy)},${f},${this._x1 = t + i * Math.cos(o)},${this._y1 = n + i * Math.sin(o)}`);
  }
  rect(t, n, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
}
function Og() {
  return new Ex();
}
Og.prototype = Ex.prototype;
function Ng(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const i = Math.floor(n);
      if (!(i >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = i;
    }
    return e;
  }, () => new Ex(t);
}
function H9(e) {
  return e.innerRadius;
}
function Y9(e) {
  return e.outerRadius;
}
function X9(e) {
  return e.startAngle;
}
function V9(e) {
  return e.endAngle;
}
function K9(e) {
  return e && e.padAngle;
}
function J9(e, t, n, i, r, o, a, s) {
  var u = n - e, l = i - t, c = a - r, f = s - o, d = f * u - c * l;
  if (!(d * d < Nt))
    return d = (c * (t - o) - f * (e - r)) / d, [e + d * u, t + d * l];
}
function bd(e, t, n, i, r, o, a) {
  var s = e - n, u = t - i, l = (a ? o : -o) / qa(s * s + u * u), c = l * u, f = -l * s, d = e + c, h = t + f, p = n + c, g = i + f, m = (d + p) / 2, y = (h + g) / 2, v = p - d, b = g - h, x = v * v + b * b, E = r - o, _ = d * g - p * h, w = (b < 0 ? -1 : 1) * qa(U9(0, E * E * x - _ * _)), S = (_ * b - v * w) / x, C = (-_ * v - b * w) / x, $ = (_ * b + v * w) / x, A = (-_ * v + b * w) / x, M = S - m, F = C - y, O = $ - m, k = A - y;
  return M * M + F * F > O * O + k * k && (S = $, C = A), {
    cx: S,
    cy: C,
    x01: -c,
    y01: -f,
    x11: S * (r / E - 1),
    y11: C * (r / E - 1)
  };
}
function Q9() {
  var e = H9, t = Y9, n = Fe(0), i = null, r = X9, o = V9, a = K9, s = null, u = Ng(l);
  function l() {
    var c, f, d = +e.apply(this, arguments), h = +t.apply(this, arguments), p = r.apply(this, arguments) - Ph, g = o.apply(this, arguments) - Ph, m = wS(g - p), y = g > p;
    if (s || (s = c = u()), h < d && (f = h, h = d, d = f), !(h > Nt))
      s.moveTo(0, 0);
    else if (m > BT - Nt)
      s.moveTo(h * _a(p), h * Yi(p)), s.arc(0, 0, h, p, g, !y), d > Nt && (s.moveTo(d * _a(g), d * Yi(g)), s.arc(0, 0, d, g, p, y));
    else {
      var v = p, b = g, x = p, E = g, _ = m, w = m, S = a.apply(this, arguments) / 2, C = S > Nt && (i ? +i.apply(this, arguments) : qa(d * d + h * h)), $ = F0(wS(h - d) / 2, +n.apply(this, arguments)), A = $, M = $, F, O;
      if (C > Nt) {
        var k = ES(C / d * Yi(S)), T = ES(C / h * Yi(S));
        (_ -= k * 2) > Nt ? (k *= y ? 1 : -1, x += k, E -= k) : (_ = 0, x = E = (p + g) / 2), (w -= T * 2) > Nt ? (T *= y ? 1 : -1, v += T, b -= T) : (w = 0, v = b = (p + g) / 2);
      }
      var N = h * _a(v), L = h * Yi(v), z = d * _a(E), J = d * Yi(E);
      if ($ > Nt) {
        var le = h * _a(b), Ee = h * Yi(b), _e = d * _a(x), Ue = d * Yi(x), ye;
        if (m < Ou)
          if (ye = J9(N, L, _e, Ue, le, Ee, z, J)) {
            var Mt = N - ye[0], Gi = L - ye[1], Ht = le - ye[0], V = Ee - ye[1], ue = 1 / Yi(q9((Mt * Ht + Gi * V) / (qa(Mt * Mt + Gi * Gi) * qa(Ht * Ht + V * V))) / 2), de = qa(ye[0] * ye[0] + ye[1] * ye[1]);
            A = F0($, (d - de) / (ue - 1)), M = F0($, (h - de) / (ue + 1));
          } else
            A = M = 0;
      }
      w > Nt ? M > Nt ? (F = bd(_e, Ue, N, L, h, M, y), O = bd(le, Ee, z, J, h, M, y), s.moveTo(F.cx + F.x01, F.cy + F.y01), M < $ ? s.arc(F.cx, F.cy, M, Tt(F.y01, F.x01), Tt(O.y01, O.x01), !y) : (s.arc(F.cx, F.cy, M, Tt(F.y01, F.x01), Tt(F.y11, F.x11), !y), s.arc(0, 0, h, Tt(F.cy + F.y11, F.cx + F.x11), Tt(O.cy + O.y11, O.cx + O.x11), !y), s.arc(O.cx, O.cy, M, Tt(O.y11, O.x11), Tt(O.y01, O.x01), !y))) : (s.moveTo(N, L), s.arc(0, 0, h, v, b, !y)) : s.moveTo(N, L), !(d > Nt) || !(_ > Nt) ? s.lineTo(z, J) : A > Nt ? (F = bd(z, J, le, Ee, d, -A, y), O = bd(N, L, _e, Ue, d, -A, y), s.lineTo(F.cx + F.x01, F.cy + F.y01), A < $ ? s.arc(F.cx, F.cy, A, Tt(F.y01, F.x01), Tt(O.y01, O.x01), !y) : (s.arc(F.cx, F.cy, A, Tt(F.y01, F.x01), Tt(F.y11, F.x11), !y), s.arc(0, 0, d, Tt(F.cy + F.y11, F.cx + F.x11), Tt(O.cy + O.y11, O.cx + O.x11), y), s.arc(O.cx, O.cy, A, Tt(O.y11, O.x11), Tt(O.y01, O.x01), !y))) : s.arc(0, 0, d, E, x, y);
    }
    if (s.closePath(), c)
      return s = null, c + "" || null;
  }
  return l.centroid = function() {
    var c = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, f = (+r.apply(this, arguments) + +o.apply(this, arguments)) / 2 - Ou / 2;
    return [_a(f) * c, Yi(f) * c];
  }, l.innerRadius = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Fe(+c), l) : e;
  }, l.outerRadius = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : Fe(+c), l) : t;
  }, l.cornerRadius = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : Fe(+c), l) : n;
  }, l.padRadius = function(c) {
    return arguments.length ? (i = c == null ? null : typeof c == "function" ? c : Fe(+c), l) : i;
  }, l.startAngle = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : Fe(+c), l) : r;
  }, l.endAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : Fe(+c), l) : o;
  }, l.padAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : Fe(+c), l) : a;
  }, l.context = function(c) {
    return arguments.length ? (s = c == null ? null : c, l) : s;
  }, l;
}
function UT(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function qT(e) {
  this._context = e;
}
qT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function _x(e) {
  return new qT(e);
}
function WT(e) {
  return e[0];
}
function GT(e) {
  return e[1];
}
function HT(e, t) {
  var n = Fe(!0), i = null, r = _x, o = null, a = Ng(s);
  e = typeof e == "function" ? e : e === void 0 ? WT : Fe(e), t = typeof t == "function" ? t : t === void 0 ? GT : Fe(t);
  function s(u) {
    var l, c = (u = UT(u)).length, f, d = !1, h;
    for (i == null && (o = r(h = a())), l = 0; l <= c; ++l)
      !(l < c && n(f = u[l], l, u)) === d && ((d = !d) ? o.lineStart() : o.lineEnd()), d && o.point(+e(f, l, u), +t(f, l, u));
    if (h)
      return o = null, h + "" || null;
  }
  return s.x = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Fe(+u), s) : e;
  }, s.y = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Fe(+u), s) : t;
  }, s.defined = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Fe(!!u), s) : n;
  }, s.curve = function(u) {
    return arguments.length ? (r = u, i != null && (o = r(i)), s) : r;
  }, s.context = function(u) {
    return arguments.length ? (u == null ? i = o = null : o = r(i = u), s) : i;
  }, s;
}
function YT(e, t, n) {
  var i = null, r = Fe(!0), o = null, a = _x, s = null, u = Ng(l);
  e = typeof e == "function" ? e : e === void 0 ? WT : Fe(+e), t = typeof t == "function" ? t : Fe(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? GT : Fe(+n);
  function l(f) {
    var d, h, p, g = (f = UT(f)).length, m, y = !1, v, b = new Array(g), x = new Array(g);
    for (o == null && (s = a(v = u())), d = 0; d <= g; ++d) {
      if (!(d < g && r(m = f[d], d, f)) === y)
        if (y = !y)
          h = d, s.areaStart(), s.lineStart();
        else {
          for (s.lineEnd(), s.lineStart(), p = d - 1; p >= h; --p)
            s.point(b[p], x[p]);
          s.lineEnd(), s.areaEnd();
        }
      y && (b[d] = +e(m, d, f), x[d] = +t(m, d, f), s.point(i ? +i(m, d, f) : b[d], n ? +n(m, d, f) : x[d]));
    }
    if (v)
      return s = null, v + "" || null;
  }
  function c() {
    return HT().defined(r).curve(a).context(o);
  }
  return l.x = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Fe(+f), i = null, l) : e;
  }, l.x0 = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Fe(+f), l) : e;
  }, l.x1 = function(f) {
    return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Fe(+f), l) : i;
  }, l.y = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Fe(+f), n = null, l) : t;
  }, l.y0 = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Fe(+f), l) : t;
  }, l.y1 = function(f) {
    return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : Fe(+f), l) : n;
  }, l.lineX0 = l.lineY0 = function() {
    return c().x(e).y(t);
  }, l.lineY1 = function() {
    return c().x(e).y(n);
  }, l.lineX1 = function() {
    return c().x(i).y(t);
  }, l.defined = function(f) {
    return arguments.length ? (r = typeof f == "function" ? f : Fe(!!f), l) : r;
  }, l.curve = function(f) {
    return arguments.length ? (a = f, o != null && (s = a(o)), l) : a;
  }, l.context = function(f) {
    return arguments.length ? (f == null ? o = s = null : s = a(o = f), l) : o;
  }, l;
}
const Z9 = {
  draw(e, t) {
    const n = qa(t / Ou);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, BT);
  }
};
function e7(e, t) {
  let n = null, i = Ng(r);
  e = typeof e == "function" ? e : Fe(e || Z9), t = typeof t == "function" ? t : Fe(t === void 0 ? 64 : +t);
  function r() {
    let o;
    if (n || (n = o = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o)
      return n = null, o + "" || null;
  }
  return r.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Fe(o), r) : e;
  }, r.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Fe(+o), r) : t;
  }, r.context = function(o) {
    return arguments.length ? (n = o == null ? null : o, r) : n;
  }, r;
}
function Xo() {
}
function zh(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Dg(e) {
  this._context = e;
}
Dg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        zh(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        zh(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function t7(e) {
  return new Dg(e);
}
function XT(e) {
  this._context = e;
}
XT.prototype = {
  areaStart: Xo,
  areaEnd: Xo,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        zh(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function n7(e) {
  return new XT(e);
}
function VT(e) {
  this._context = e;
}
VT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
        break;
      case 3:
        this._point = 4;
      default:
        zh(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function i7(e) {
  return new VT(e);
}
function KT(e, t) {
  this._basis = new Dg(e), this._beta = t;
}
KT.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var i = e[0], r = t[0], o = e[n] - i, a = t[n] - r, s = -1, u; ++s <= n; )
        u = s / n, this._basis.point(
          this._beta * e[s] + (1 - this._beta) * (i + u * o),
          this._beta * t[s] + (1 - this._beta) * (r + u * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const r7 = function e(t) {
  function n(i) {
    return t === 1 ? new Dg(i) : new KT(i, t);
  }
  return n.beta = function(i) {
    return e(+i);
  }, n;
}(0.85);
function Bh(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function Sx(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Sx.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Bh(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        Bh(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const o7 = function e(t) {
  function n(i) {
    return new Sx(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function Ax(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Ax.prototype = {
  areaStart: Xo,
  areaEnd: Xo,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Bh(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const a7 = function e(t) {
  function n(i) {
    return new Ax(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function $x(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
$x.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Bh(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const s7 = function e(t) {
  function n(i) {
    return new $x(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function kx(e, t, n) {
  var i = e._x1, r = e._y1, o = e._x2, a = e._y2;
  if (e._l01_a > Nt) {
    var s = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, u = 3 * e._l01_a * (e._l01_a + e._l12_a);
    i = (i * s - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u, r = (r * s - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u;
  }
  if (e._l23_a > Nt) {
    var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, c = 3 * e._l23_a * (e._l23_a + e._l12_a);
    o = (o * l + e._x1 * e._l23_2a - t * e._l12_2a) / c, a = (a * l + e._y1 * e._l23_2a - n * e._l12_2a) / c;
  }
  e._context.bezierCurveTo(i, r, o, a, e._x2, e._y2);
}
function JT(e, t) {
  this._context = e, this._alpha = t;
}
JT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        kx(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const u7 = function e(t) {
  function n(i) {
    return t ? new JT(i, t) : new Sx(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function QT(e, t) {
  this._context = e, this._alpha = t;
}
QT.prototype = {
  areaStart: Xo,
  areaEnd: Xo,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        kx(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const l7 = function e(t) {
  function n(i) {
    return t ? new QT(i, t) : new Ax(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function ZT(e, t) {
  this._context = e, this._alpha = t;
}
ZT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        kx(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const c7 = function e(t) {
  function n(i) {
    return t ? new ZT(i, t) : new $x(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function e3(e) {
  this._context = e;
}
e3.prototype = {
  areaStart: Xo,
  areaEnd: Xo,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function f7(e) {
  return new e3(e);
}
function _S(e) {
  return e < 0 ? -1 : 1;
}
function SS(e, t, n) {
  var i = e._x1 - e._x0, r = t - e._x1, o = (e._y1 - e._y0) / (i || r < 0 && -0), a = (n - e._y1) / (r || i < 0 && -0), s = (o * r + a * i) / (i + r);
  return (_S(o) + _S(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0;
}
function AS(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function M0(e, t, n) {
  var i = e._x0, r = e._y0, o = e._x1, a = e._y1, s = (o - i) / 3;
  e._context.bezierCurveTo(i + s, r + s * t, o - s, a - s * n, o, a);
}
function jh(e) {
  this._context = e;
}
jh.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        M0(this, this._t0, AS(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, M0(this, AS(this, n = SS(this, e, t)), n);
          break;
        default:
          M0(this, this._t0, n = SS(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function t3(e) {
  this._context = new n3(e);
}
(t3.prototype = Object.create(jh.prototype)).point = function(e, t) {
  jh.prototype.point.call(this, t, e);
};
function n3(e) {
  this._context = e;
}
n3.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, i, r, o) {
    this._context.bezierCurveTo(t, e, i, n, o, r);
  }
};
function d7(e) {
  return new jh(e);
}
function h7(e) {
  return new t3(e);
}
function i3(e) {
  this._context = e;
}
i3.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var i = $S(e), r = $S(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(i[0][o], r[0][o], i[1][o], r[1][o], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function $S(e) {
  var t, n = e.length - 1, i, r = new Array(n), o = new Array(n), a = new Array(n);
  for (r[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    r[t] = 1, o[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (r[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    i = r[t] / o[t - 1], o[t] -= i, a[t] -= i * a[t - 1];
  for (r[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    r[t] = (a[t] - r[t + 1]) / o[t];
  for (o[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - r[t + 1];
  return [r, o];
}
function p7(e) {
  return new i3(e);
}
function Rg(e, t) {
  this._context = e, this._t = t;
}
Rg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function g7(e) {
  return new Rg(e, 0.5);
}
function m7(e) {
  return new Rg(e, 0);
}
function y7(e) {
  return new Rg(e, 1);
}
function Uo(e, t) {
  if (typeof document < "u" && document.createElement) {
    const n = document.createElement("canvas");
    if (n && n.getContext)
      return n.width = e, n.height = t, n;
  }
  return null;
}
const v7 = () => typeof Image < "u" ? Image : null;
function _r(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function la(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const dy = Symbol("implicit");
function Cx() {
  var e = new q_(), t = [], n = [], i = dy;
  function r(o) {
    let a = e.get(o);
    if (a === void 0) {
      if (i !== dy)
        return i;
      e.set(o, a = t.push(o) - 1);
    }
    return n[a % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new q_();
    for (const a of o)
      e.has(a) || e.set(a, t.push(a) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (i = o, r) : i;
  }, r.copy = function() {
    return Cx(t, n).unknown(i);
  }, _r.apply(r, arguments), r;
}
function yl(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Mf(e, t) {
  var n = Object.create(e.prototype);
  for (var i in t)
    n[i] = t[i];
  return n;
}
function ca() {
}
var as = 0.7, Nu = 1 / as, mu = "\\s*([+-]?\\d+)\\s*", Jc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", sr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", b7 = /^#([0-9a-f]{3,8})$/, x7 = new RegExp(`^rgb\\(${mu},${mu},${mu}\\)$`), w7 = new RegExp(`^rgb\\(${sr},${sr},${sr}\\)$`), E7 = new RegExp(`^rgba\\(${mu},${mu},${mu},${Jc}\\)$`), _7 = new RegExp(`^rgba\\(${sr},${sr},${sr},${Jc}\\)$`), S7 = new RegExp(`^hsl\\(${Jc},${sr},${sr}\\)$`), A7 = new RegExp(`^hsla\\(${Jc},${sr},${sr},${Jc}\\)$`), kS = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
yl(ca, Qc, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: CS,
  formatHex: CS,
  formatHex8: $7,
  formatHsl: k7,
  formatRgb: FS,
  toString: FS
});
function CS() {
  return this.rgb().formatHex();
}
function $7() {
  return this.rgb().formatHex8();
}
function k7() {
  return r3(this).formatHsl();
}
function FS() {
  return this.rgb().formatRgb();
}
function Qc(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = b7.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? MS(t) : n === 3 ? new ht(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? xd(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? xd(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = x7.exec(e)) ? new ht(t[1], t[2], t[3], 1) : (t = w7.exec(e)) ? new ht(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = E7.exec(e)) ? xd(t[1], t[2], t[3], t[4]) : (t = _7.exec(e)) ? xd(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = S7.exec(e)) ? NS(t[1], t[2] / 100, t[3] / 100, 1) : (t = A7.exec(e)) ? NS(t[1], t[2] / 100, t[3] / 100, t[4]) : kS.hasOwnProperty(e) ? MS(kS[e]) : e === "transparent" ? new ht(NaN, NaN, NaN, 0) : null;
}
function MS(e) {
  return new ht(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function xd(e, t, n, i) {
  return i <= 0 && (e = t = n = NaN), new ht(e, t, n, i);
}
function Fx(e) {
  return e instanceof ca || (e = Qc(e)), e ? (e = e.rgb(), new ht(e.r, e.g, e.b, e.opacity)) : new ht();
}
function Vo(e, t, n, i) {
  return arguments.length === 1 ? Fx(e) : new ht(e, t, n, i == null ? 1 : i);
}
function ht(e, t, n, i) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
}
yl(ht, Vo, Mf(ca, {
  brighter(e) {
    return e = e == null ? Nu : Math.pow(Nu, e), new ht(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? as : Math.pow(as, e), new ht(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ht(Ja(this.r), Ja(this.g), Ja(this.b), Uh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: TS,
  formatHex: TS,
  formatHex8: C7,
  formatRgb: OS,
  toString: OS
}));
function TS() {
  return `#${Wa(this.r)}${Wa(this.g)}${Wa(this.b)}`;
}
function C7() {
  return `#${Wa(this.r)}${Wa(this.g)}${Wa(this.b)}${Wa((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function OS() {
  const e = Uh(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ja(this.r)}, ${Ja(this.g)}, ${Ja(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Uh(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ja(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Wa(e) {
  return e = Ja(e), (e < 16 ? "0" : "") + e.toString(16);
}
function NS(e, t, n, i) {
  return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new yi(e, t, n, i);
}
function r3(e) {
  if (e instanceof yi)
    return new yi(e.h, e.s, e.l, e.opacity);
  if (e instanceof ca || (e = Qc(e)), !e)
    return new yi();
  if (e instanceof yi)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = Math.min(t, n, i), o = Math.max(t, n, i), a = NaN, s = o - r, u = (o + r) / 2;
  return s ? (t === o ? a = (n - i) / s + (n < i) * 6 : n === o ? a = (i - t) / s + 2 : a = (t - n) / s + 4, s /= u < 0.5 ? o + r : 2 - o - r, a *= 60) : s = u > 0 && u < 1 ? 0 : a, new yi(a, s, u, e.opacity);
}
function qh(e, t, n, i) {
  return arguments.length === 1 ? r3(e) : new yi(e, t, n, i == null ? 1 : i);
}
function yi(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
yl(yi, qh, Mf(ca, {
  brighter(e) {
    return e = e == null ? Nu : Math.pow(Nu, e), new yi(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? as : Math.pow(as, e), new yi(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - i;
    return new ht(
      T0(e >= 240 ? e - 240 : e + 120, r, i),
      T0(e, r, i),
      T0(e < 120 ? e + 240 : e - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new yi(DS(this.h), wd(this.s), wd(this.l), Uh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Uh(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${DS(this.h)}, ${wd(this.s) * 100}%, ${wd(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function DS(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function wd(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function T0(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const o3 = Math.PI / 180, a3 = 180 / Math.PI, Wh = 18, s3 = 0.96422, u3 = 1, l3 = 0.82521, c3 = 4 / 29, yu = 6 / 29, f3 = 3 * yu * yu, F7 = yu * yu * yu;
function d3(e) {
  if (e instanceof ur)
    return new ur(e.l, e.a, e.b, e.opacity);
  if (e instanceof Yr)
    return h3(e);
  e instanceof ht || (e = Fx(e));
  var t = R0(e.r), n = R0(e.g), i = R0(e.b), r = O0((0.2225045 * t + 0.7168786 * n + 0.0606169 * i) / u3), o, a;
  return t === n && n === i ? o = a = r : (o = O0((0.4360747 * t + 0.3850649 * n + 0.1430804 * i) / s3), a = O0((0.0139322 * t + 0.0971045 * n + 0.7141733 * i) / l3)), new ur(116 * r - 16, 500 * (o - r), 200 * (r - a), e.opacity);
}
function Gh(e, t, n, i) {
  return arguments.length === 1 ? d3(e) : new ur(e, t, n, i == null ? 1 : i);
}
function ur(e, t, n, i) {
  this.l = +e, this.a = +t, this.b = +n, this.opacity = +i;
}
yl(ur, Gh, Mf(ca, {
  brighter(e) {
    return new ur(this.l + Wh * (e == null ? 1 : e), this.a, this.b, this.opacity);
  },
  darker(e) {
    return new ur(this.l - Wh * (e == null ? 1 : e), this.a, this.b, this.opacity);
  },
  rgb() {
    var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, n = isNaN(this.b) ? e : e - this.b / 200;
    return t = s3 * N0(t), e = u3 * N0(e), n = l3 * N0(n), new ht(
      D0(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
      D0(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
      D0(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
      this.opacity
    );
  }
}));
function O0(e) {
  return e > F7 ? Math.pow(e, 1 / 3) : e / f3 + c3;
}
function N0(e) {
  return e > yu ? e * e * e : f3 * (e - c3);
}
function D0(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function R0(e) {
  return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function M7(e) {
  if (e instanceof Yr)
    return new Yr(e.h, e.c, e.l, e.opacity);
  if (e instanceof ur || (e = d3(e)), e.a === 0 && e.b === 0)
    return new Yr(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
  var t = Math.atan2(e.b, e.a) * a3;
  return new Yr(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
}
function Hh(e, t, n, i) {
  return arguments.length === 1 ? M7(e) : new Yr(e, t, n, i == null ? 1 : i);
}
function Yr(e, t, n, i) {
  this.h = +e, this.c = +t, this.l = +n, this.opacity = +i;
}
function h3(e) {
  if (isNaN(e.h))
    return new ur(e.l, 0, 0, e.opacity);
  var t = e.h * o3;
  return new ur(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
}
yl(Yr, Hh, Mf(ca, {
  brighter(e) {
    return new Yr(this.h, this.c, this.l + Wh * (e == null ? 1 : e), this.opacity);
  },
  darker(e) {
    return new Yr(this.h, this.c, this.l - Wh * (e == null ? 1 : e), this.opacity);
  },
  rgb() {
    return h3(this).rgb();
  }
}));
var p3 = -0.14861, Mx = 1.78277, Tx = -0.29227, Lg = -0.90649, Zc = 1.97294, RS = Zc * Lg, LS = Zc * Mx, IS = Mx * Tx - Lg * p3;
function T7(e) {
  if (e instanceof Qa)
    return new Qa(e.h, e.s, e.l, e.opacity);
  e instanceof ht || (e = Fx(e));
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = (IS * i + RS * t - LS * n) / (IS + RS - LS), o = i - r, a = (Zc * (n - r) - Tx * o) / Lg, s = Math.sqrt(a * a + o * o) / (Zc * r * (1 - r)), u = s ? Math.atan2(a, o) * a3 - 120 : NaN;
  return new Qa(u < 0 ? u + 360 : u, s, r, e.opacity);
}
function hy(e, t, n, i) {
  return arguments.length === 1 ? T7(e) : new Qa(e, t, n, i == null ? 1 : i);
}
function Qa(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
yl(Qa, hy, Mf(ca, {
  brighter(e) {
    return e = e == null ? Nu : Math.pow(Nu, e), new Qa(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? as : Math.pow(as, e), new Qa(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = isNaN(this.h) ? 0 : (this.h + 120) * o3, t = +this.l, n = isNaN(this.s) ? 0 : this.s * t * (1 - t), i = Math.cos(e), r = Math.sin(e);
    return new ht(
      255 * (t + n * (p3 * i + Mx * r)),
      255 * (t + n * (Tx * i + Lg * r)),
      255 * (t + n * (Zc * i)),
      this.opacity
    );
  }
}));
function g3(e, t, n, i, r) {
  var o = e * e, a = o * e;
  return ((1 - 3 * e + 3 * o - a) * t + (4 - 6 * o + 3 * a) * n + (1 + 3 * e + 3 * o - 3 * a) * i + a * r) / 6;
}
function m3(e) {
  var t = e.length - 1;
  return function(n) {
    var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), r = e[i], o = e[i + 1], a = i > 0 ? e[i - 1] : 2 * r - o, s = i < t - 1 ? e[i + 2] : 2 * o - r;
    return g3((n - i / t) * t, a, r, o, s);
  };
}
function y3(e) {
  var t = e.length;
  return function(n) {
    var i = Math.floor(((n %= 1) < 0 ? ++n : n) * t), r = e[(i + t - 1) % t], o = e[i % t], a = e[(i + 1) % t], s = e[(i + 2) % t];
    return g3((n - i / t) * t, r, o, a, s);
  };
}
const Ig = (e) => () => e;
function v3(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function O7(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(i) {
    return Math.pow(e + i * t, n);
  };
}
function Pg(e, t) {
  var n = t - e;
  return n ? v3(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : Ig(isNaN(e) ? t : e);
}
function N7(e) {
  return (e = +e) == 1 ? pt : function(t, n) {
    return n - t ? O7(t, n, e) : Ig(isNaN(t) ? n : t);
  };
}
function pt(e, t) {
  var n = t - e;
  return n ? v3(e, n) : Ig(isNaN(e) ? t : e);
}
const py = function e(t) {
  var n = N7(t);
  function i(r, o) {
    var a = n((r = Vo(r)).r, (o = Vo(o)).r), s = n(r.g, o.g), u = n(r.b, o.b), l = pt(r.opacity, o.opacity);
    return function(c) {
      return r.r = a(c), r.g = s(c), r.b = u(c), r.opacity = l(c), r + "";
    };
  }
  return i.gamma = e, i;
}(1);
function b3(e) {
  return function(t) {
    var n = t.length, i = new Array(n), r = new Array(n), o = new Array(n), a, s;
    for (a = 0; a < n; ++a)
      s = Vo(t[a]), i[a] = s.r || 0, r[a] = s.g || 0, o[a] = s.b || 0;
    return i = e(i), r = e(r), o = e(o), s.opacity = 1, function(u) {
      return s.r = i(u), s.g = r(u), s.b = o(u), s + "";
    };
  };
}
var D7 = b3(m3), R7 = b3(y3);
function Ox(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, i = t.slice(), r;
  return function(o) {
    for (r = 0; r < n; ++r)
      i[r] = e[r] * (1 - o) + t[r] * o;
    return i;
  };
}
function x3(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function L7(e, t) {
  return (x3(t) ? Ox : w3)(e, t);
}
function w3(e, t) {
  var n = t ? t.length : 0, i = e ? Math.min(n, e.length) : 0, r = new Array(i), o = new Array(n), a;
  for (a = 0; a < i; ++a)
    r[a] = fa(e[a], t[a]);
  for (; a < n; ++a)
    o[a] = t[a];
  return function(s) {
    for (a = 0; a < i; ++a)
      o[a] = r[a](s);
    return o;
  };
}
function E3(e, t) {
  var n = new Date();
  return e = +e, t = +t, function(i) {
    return n.setTime(e * (1 - i) + t * i), n;
  };
}
function gi(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function _3(e, t) {
  var n = {}, i = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = fa(e[r], t[r]) : i[r] = t[r];
  return function(o) {
    for (r in n)
      i[r] = n[r](o);
    return i;
  };
}
var gy = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, L0 = new RegExp(gy.source, "g");
function I7(e) {
  return function() {
    return e;
  };
}
function P7(e) {
  return function(t) {
    return e(t) + "";
  };
}
function S3(e, t) {
  var n = gy.lastIndex = L0.lastIndex = 0, i, r, o, a = -1, s = [], u = [];
  for (e = e + "", t = t + ""; (i = gy.exec(e)) && (r = L0.exec(t)); )
    (o = r.index) > n && (o = t.slice(n, o), s[a] ? s[a] += o : s[++a] = o), (i = i[0]) === (r = r[0]) ? s[a] ? s[a] += r : s[++a] = r : (s[++a] = null, u.push({ i: a, x: gi(i, r) })), n = L0.lastIndex;
  return n < t.length && (o = t.slice(n), s[a] ? s[a] += o : s[++a] = o), s.length < 2 ? u[0] ? P7(u[0].x) : I7(t) : (t = u.length, function(l) {
    for (var c = 0, f; c < t; ++c)
      s[(f = u[c]).i] = f.x(l);
    return s.join("");
  });
}
function fa(e, t) {
  var n = typeof t, i;
  return t == null || n === "boolean" ? Ig(t) : (n === "number" ? gi : n === "string" ? (i = Qc(t)) ? (t = i, py) : S3 : t instanceof Qc ? py : t instanceof Date ? E3 : x3(t) ? Ox : Array.isArray(t) ? w3 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? _3 : gi)(e, t);
}
function z7(e) {
  var t = e.length;
  return function(n) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
  };
}
function B7(e, t) {
  var n = Pg(+e, +t);
  return function(i) {
    var r = n(i);
    return r - 360 * Math.floor(r / 360);
  };
}
function Tf(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var PS = 180 / Math.PI, my = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function A3(e, t, n, i, r, o) {
  var a, s, u;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (u = e * n + t * i) && (n -= e * u, i -= t * u), (s = Math.sqrt(n * n + i * i)) && (n /= s, i /= s, u /= s), e * i < t * n && (e = -e, t = -t, u = -u, a = -a), {
    translateX: r,
    translateY: o,
    rotate: Math.atan2(t, e) * PS,
    skewX: Math.atan(u) * PS,
    scaleX: a,
    scaleY: s
  };
}
var Ed;
function j7(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? my : A3(t.a, t.b, t.c, t.d, t.e, t.f);
}
function U7(e) {
  return e == null || (Ed || (Ed = document.createElementNS("http://www.w3.org/2000/svg", "g")), Ed.setAttribute("transform", e), !(e = Ed.transform.baseVal.consolidate())) ? my : (e = e.matrix, A3(e.a, e.b, e.c, e.d, e.e, e.f));
}
function $3(e, t, n, i) {
  function r(l) {
    return l.length ? l.pop() + " " : "";
  }
  function o(l, c, f, d, h, p) {
    if (l !== f || c !== d) {
      var g = h.push("translate(", null, t, null, n);
      p.push({ i: g - 4, x: gi(l, f) }, { i: g - 2, x: gi(c, d) });
    } else
      (f || d) && h.push("translate(" + f + t + d + n);
  }
  function a(l, c, f, d) {
    l !== c ? (l - c > 180 ? c += 360 : c - l > 180 && (l += 360), d.push({ i: f.push(r(f) + "rotate(", null, i) - 2, x: gi(l, c) })) : c && f.push(r(f) + "rotate(" + c + i);
  }
  function s(l, c, f, d) {
    l !== c ? d.push({ i: f.push(r(f) + "skewX(", null, i) - 2, x: gi(l, c) }) : c && f.push(r(f) + "skewX(" + c + i);
  }
  function u(l, c, f, d, h, p) {
    if (l !== f || c !== d) {
      var g = h.push(r(h) + "scale(", null, ",", null, ")");
      p.push({ i: g - 4, x: gi(l, f) }, { i: g - 2, x: gi(c, d) });
    } else
      (f !== 1 || d !== 1) && h.push(r(h) + "scale(" + f + "," + d + ")");
  }
  return function(l, c) {
    var f = [], d = [];
    return l = e(l), c = e(c), o(l.translateX, l.translateY, c.translateX, c.translateY, f, d), a(l.rotate, c.rotate, f, d), s(l.skewX, c.skewX, f, d), u(l.scaleX, l.scaleY, c.scaleX, c.scaleY, f, d), l = c = null, function(h) {
      for (var p = -1, g = d.length, m; ++p < g; )
        f[(m = d[p]).i] = m.x(h);
      return f.join("");
    };
  };
}
var q7 = $3(j7, "px, ", "px)", "deg)"), W7 = $3(U7, ", ", ")", ")"), G7 = 1e-12;
function zS(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function H7(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Y7(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const X7 = function e(t, n, i) {
  function r(o, a) {
    var s = o[0], u = o[1], l = o[2], c = a[0], f = a[1], d = a[2], h = c - s, p = f - u, g = h * h + p * p, m, y;
    if (g < G7)
      y = Math.log(d / l) / t, m = function(w) {
        return [
          s + w * h,
          u + w * p,
          l * Math.exp(t * w * y)
        ];
      };
    else {
      var v = Math.sqrt(g), b = (d * d - l * l + i * g) / (2 * l * n * v), x = (d * d - l * l - i * g) / (2 * d * n * v), E = Math.log(Math.sqrt(b * b + 1) - b), _ = Math.log(Math.sqrt(x * x + 1) - x);
      y = (_ - E) / t, m = function(w) {
        var S = w * y, C = zS(E), $ = l / (n * v) * (C * Y7(t * S + E) - H7(E));
        return [
          s + $ * h,
          u + $ * p,
          l * C / zS(t * S + E)
        ];
      };
    }
    return m.duration = y * 1e3 * t / Math.SQRT2, m;
  }
  return r.rho = function(o) {
    var a = Math.max(1e-3, +o), s = a * a, u = s * s;
    return e(a, s, u);
  }, r;
}(Math.SQRT2, 2, 4);
function k3(e) {
  return function(t, n) {
    var i = e((t = qh(t)).h, (n = qh(n)).h), r = pt(t.s, n.s), o = pt(t.l, n.l), a = pt(t.opacity, n.opacity);
    return function(s) {
      return t.h = i(s), t.s = r(s), t.l = o(s), t.opacity = a(s), t + "";
    };
  };
}
const V7 = k3(Pg);
var K7 = k3(pt);
function J7(e, t) {
  var n = pt((e = Gh(e)).l, (t = Gh(t)).l), i = pt(e.a, t.a), r = pt(e.b, t.b), o = pt(e.opacity, t.opacity);
  return function(a) {
    return e.l = n(a), e.a = i(a), e.b = r(a), e.opacity = o(a), e + "";
  };
}
function C3(e) {
  return function(t, n) {
    var i = e((t = Hh(t)).h, (n = Hh(n)).h), r = pt(t.c, n.c), o = pt(t.l, n.l), a = pt(t.opacity, n.opacity);
    return function(s) {
      return t.h = i(s), t.c = r(s), t.l = o(s), t.opacity = a(s), t + "";
    };
  };
}
const Q7 = C3(Pg);
var Z7 = C3(pt);
function F3(e) {
  return function t(n) {
    n = +n;
    function i(r, o) {
      var a = e((r = hy(r)).h, (o = hy(o)).h), s = pt(r.s, o.s), u = pt(r.l, o.l), l = pt(r.opacity, o.opacity);
      return function(c) {
        return r.h = a(c), r.s = s(c), r.l = u(Math.pow(c, n)), r.opacity = l(c), r + "";
      };
    }
    return i.gamma = t, i;
  }(1);
}
const eB = F3(Pg);
var tB = F3(pt);
function Nx(e, t) {
  t === void 0 && (t = e, e = fa);
  for (var n = 0, i = t.length - 1, r = t[0], o = new Array(i < 0 ? 0 : i); n < i; )
    o[n] = e(r, r = t[++n]);
  return function(a) {
    var s = Math.max(0, Math.min(i - 1, Math.floor(a *= i)));
    return o[s](a - s);
  };
}
function nB(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e(i / (t - 1));
  return n;
}
const iB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolate: fa,
  interpolateArray: L7,
  interpolateBasis: m3,
  interpolateBasisClosed: y3,
  interpolateDate: E3,
  interpolateDiscrete: z7,
  interpolateHue: B7,
  interpolateNumber: gi,
  interpolateNumberArray: Ox,
  interpolateObject: _3,
  interpolateRound: Tf,
  interpolateString: S3,
  interpolateTransformCss: q7,
  interpolateTransformSvg: W7,
  interpolateZoom: X7,
  interpolateRgb: py,
  interpolateRgbBasis: D7,
  interpolateRgbBasisClosed: R7,
  interpolateHsl: V7,
  interpolateHslLong: K7,
  interpolateLab: J7,
  interpolateHcl: Q7,
  interpolateHclLong: Z7,
  interpolateCubehelix: eB,
  interpolateCubehelixLong: tB,
  piecewise: Nx,
  quantize: nB
}, Symbol.toStringTag, { value: "Module" }));
function rB(e) {
  return function() {
    return e;
  };
}
function yy(e) {
  return +e;
}
var BS = [0, 1];
function yn(e) {
  return e;
}
function vy(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : rB(isNaN(t) ? NaN : 0.5);
}
function oB(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(i) {
    return Math.max(e, Math.min(t, i));
  };
}
function aB(e, t, n) {
  var i = e[0], r = e[1], o = t[0], a = t[1];
  return r < i ? (i = vy(r, i), o = n(a, o)) : (i = vy(i, r), o = n(o, a)), function(s) {
    return o(i(s));
  };
}
function sB(e, t, n) {
  var i = Math.min(e.length, t.length) - 1, r = new Array(i), o = new Array(i), a = -1;
  for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < i; )
    r[a] = vy(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);
  return function(s) {
    var u = $f(e, s, 1, i) - 1;
    return o[u](r[u](s));
  };
}
function Of(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function zg() {
  var e = BS, t = BS, n = fa, i, r, o, a = yn, s, u, l;
  function c() {
    var d = Math.min(e.length, t.length);
    return a !== yn && (a = oB(e[0], e[d - 1])), s = d > 2 ? sB : aB, u = l = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? o : (u || (u = s(e.map(i), t, n)))(i(a(d)));
  }
  return f.invert = function(d) {
    return a(r((l || (l = s(t, e.map(i), gi)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (e = Array.from(d, yy), c()) : e.slice();
  }, f.range = function(d) {
    return arguments.length ? (t = Array.from(d), c()) : t.slice();
  }, f.rangeRound = function(d) {
    return t = Array.from(d), n = Tf, c();
  }, f.clamp = function(d) {
    return arguments.length ? (a = d ? !0 : yn, c()) : a !== yn;
  }, f.interpolate = function(d) {
    return arguments.length ? (n = d, c()) : n;
  }, f.unknown = function(d) {
    return arguments.length ? (o = d, f) : o;
  }, function(d, h) {
    return i = d, r = h, c();
  };
}
function M3() {
  return zg()(yn, yn);
}
function T3(e, t, n, i) {
  var r = Ho(e, t, n), o;
  switch (i = os(i == null ? ",f" : i), i.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return i.precision == null && !isNaN(o = iM(r, a)) && (i.precision = o), xb(i, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(o = rM(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = o - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(o = nM(r)) && (i.precision = o - (i.type === "%") * 2);
      break;
    }
  }
  return pg(i);
}
function Ts(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var i = t();
    return K1(i[0], i[i.length - 1], n == null ? 10 : n);
  }, e.tickFormat = function(n, i) {
    var r = t();
    return T3(r[0], r[r.length - 1], n == null ? 10 : n, i);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var i = t(), r = 0, o = i.length - 1, a = i[r], s = i[o], u, l, c = 10;
    for (s < a && (l = a, a = s, s = l, l = r, r = o, o = l); c-- > 0; ) {
      if (l = J1(a, s, n), l === u)
        return i[r] = a, i[o] = s, t(i);
      if (l > 0)
        a = Math.floor(a / l) * l, s = Math.ceil(s / l) * l;
      else if (l < 0)
        a = Math.ceil(a * l) / l, s = Math.floor(s * l) / l;
      else
        break;
      u = l;
    }
    return e;
  }, e;
}
function O3() {
  var e = M3();
  return e.copy = function() {
    return Of(e, O3());
  }, _r.apply(e, arguments), Ts(e);
}
function N3(e) {
  var t;
  function n(i) {
    return i == null || isNaN(i = +i) ? t : i;
  }
  return n.invert = n, n.domain = n.range = function(i) {
    return arguments.length ? (e = Array.from(i, yy), n) : e.slice();
  }, n.unknown = function(i) {
    return arguments.length ? (t = i, n) : t;
  }, n.copy = function() {
    return N3(e).unknown(t);
  }, e = arguments.length ? Array.from(e, yy) : [0, 1], Ts(n);
}
function D3(e, t) {
  e = e.slice();
  var n = 0, i = e.length - 1, r = e[n], o = e[i], a;
  return o < r && (a = n, n = i, i = a, a = r, r = o, o = a), e[n] = t.floor(r), e[i] = t.ceil(o), e;
}
function jS(e) {
  return Math.log(e);
}
function US(e) {
  return Math.exp(e);
}
function uB(e) {
  return -Math.log(-e);
}
function lB(e) {
  return -Math.exp(-e);
}
function cB(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function fB(e) {
  return e === 10 ? cB : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function dB(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function qS(e) {
  return (t, n) => -e(-t, n);
}
function Dx(e) {
  const t = e(jS, US), n = t.domain;
  let i = 10, r, o;
  function a() {
    return r = dB(i), o = fB(i), n()[0] < 0 ? (r = qS(r), o = qS(o), e(uB, lB)) : e(jS, US), t;
  }
  return t.base = function(s) {
    return arguments.length ? (i = +s, a()) : i;
  }, t.domain = function(s) {
    return arguments.length ? (n(s), a()) : n();
  }, t.ticks = (s) => {
    const u = n();
    let l = u[0], c = u[u.length - 1];
    const f = c < l;
    f && ([l, c] = [c, l]);
    let d = r(l), h = r(c), p, g;
    const m = s == null ? 10 : +s;
    let y = [];
    if (!(i % 1) && h - d < m) {
      if (d = Math.floor(d), h = Math.ceil(h), l > 0) {
        for (; d <= h; ++d)
          for (p = 1; p < i; ++p)
            if (g = d < 0 ? p / o(-d) : p * o(d), !(g < l)) {
              if (g > c)
                break;
              y.push(g);
            }
      } else
        for (; d <= h; ++d)
          for (p = i - 1; p >= 1; --p)
            if (g = d > 0 ? p / o(-d) : p * o(d), !(g < l)) {
              if (g > c)
                break;
              y.push(g);
            }
      y.length * 2 < m && (y = K1(l, c, m));
    } else
      y = K1(d, h, Math.min(h - d, m)).map(o);
    return f ? y.reverse() : y;
  }, t.tickFormat = (s, u) => {
    if (s == null && (s = 10), u == null && (u = i === 10 ? "s" : ","), typeof u != "function" && (!(i % 1) && (u = os(u)).precision == null && (u.trim = !0), u = pg(u)), s === 1 / 0)
      return u;
    const l = Math.max(1, i * s / t.ticks().length);
    return (c) => {
      let f = c / o(Math.round(r(c)));
      return f * i < i - 0.5 && (f *= i), f <= l ? u(c) : "";
    };
  }, t.nice = () => n(D3(n(), {
    floor: (s) => o(Math.floor(r(s))),
    ceil: (s) => o(Math.ceil(r(s)))
  })), t;
}
function R3() {
  const e = Dx(zg()).domain([1, 10]);
  return e.copy = () => Of(e, R3()).base(e.base()), _r.apply(e, arguments), e;
}
function WS(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function GS(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function Rx(e) {
  var t = 1, n = e(WS(t), GS(t));
  return n.constant = function(i) {
    return arguments.length ? e(WS(t = +i), GS(t)) : t;
  }, Ts(n);
}
function L3() {
  var e = Rx(zg());
  return e.copy = function() {
    return Of(e, L3()).constant(e.constant());
  }, _r.apply(e, arguments);
}
function HS(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function hB(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function pB(e) {
  return e < 0 ? -e * e : e * e;
}
function Lx(e) {
  var t = e(yn, yn), n = 1;
  function i() {
    return n === 1 ? e(yn, yn) : n === 0.5 ? e(hB, pB) : e(HS(n), HS(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, i()) : n;
  }, Ts(t);
}
function Ix() {
  var e = Lx(zg());
  return e.copy = function() {
    return Of(e, Ix()).exponent(e.exponent());
  }, _r.apply(e, arguments), e;
}
function gB() {
  return Ix.apply(null, arguments).exponent(0.5);
}
function I3() {
  var e = [], t = [], n = [], i;
  function r() {
    var a = 0, s = Math.max(1, t.length);
    for (n = new Array(s - 1); ++a < s; )
      n[a - 1] = KF(e, a / s);
    return o;
  }
  function o(a) {
    return a == null || isNaN(a = +a) ? i : t[$f(n, a)];
  }
  return o.invertExtent = function(a) {
    var s = t.indexOf(a);
    return s < 0 ? [NaN, NaN] : [
      s > 0 ? n[s - 1] : e[0],
      s < n.length ? n[s] : e[e.length - 1]
    ];
  }, o.domain = function(a) {
    if (!arguments.length)
      return e.slice();
    e = [];
    for (let s of a)
      s != null && !isNaN(s = +s) && e.push(s);
    return e.sort(Kr), r();
  }, o.range = function(a) {
    return arguments.length ? (t = Array.from(a), r()) : t.slice();
  }, o.unknown = function(a) {
    return arguments.length ? (i = a, o) : i;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return I3().domain(e).range(t).unknown(i);
  }, _r.apply(o, arguments);
}
function P3() {
  var e = 0, t = 1, n = 1, i = [0.5], r = [0, 1], o;
  function a(u) {
    return u != null && u <= u ? r[$f(i, u, 0, n)] : o;
  }
  function s() {
    var u = -1;
    for (i = new Array(n); ++u < n; )
      i[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, s()) : [e, t];
  }, a.range = function(u) {
    return arguments.length ? (n = (r = Array.from(u)).length - 1, s()) : r.slice();
  }, a.invertExtent = function(u) {
    var l = r.indexOf(u);
    return l < 0 ? [NaN, NaN] : l < 1 ? [e, i[0]] : l >= n ? [i[n - 1], t] : [i[l - 1], i[l]];
  }, a.unknown = function(u) {
    return arguments.length && (o = u), a;
  }, a.thresholds = function() {
    return i.slice();
  }, a.copy = function() {
    return P3().domain([e, t]).range(r).unknown(o);
  }, _r.apply(Ts(a), arguments);
}
function z3() {
  var e = [0.5], t = [0, 1], n, i = 1;
  function r(o) {
    return o != null && o <= o ? t[$f(e, o, 0, i)] : n;
  }
  return r.domain = function(o) {
    return arguments.length ? (e = Array.from(o), i = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(o) {
    return arguments.length ? (t = Array.from(o), i = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(o) {
    var a = t.indexOf(o);
    return [e[a - 1], e[a]];
  }, r.unknown = function(o) {
    return arguments.length ? (n = o, r) : n;
  }, r.copy = function() {
    return z3().domain(e).range(t).unknown(n);
  }, _r.apply(r, arguments);
}
function mB(e) {
  return new Date(e);
}
function yB(e) {
  return e instanceof Date ? +e : +new Date(+e);
}
function Px(e, t, n, i, r, o, a, s, u, l) {
  var c = M3(), f = c.invert, d = c.domain, h = l(".%L"), p = l(":%S"), g = l("%I:%M"), m = l("%I %p"), y = l("%a %d"), v = l("%b %d"), b = l("%B"), x = l("%Y");
  function E(_) {
    return (u(_) < _ ? h : s(_) < _ ? p : a(_) < _ ? g : o(_) < _ ? m : i(_) < _ ? r(_) < _ ? y : v : n(_) < _ ? b : x)(_);
  }
  return c.invert = function(_) {
    return new Date(f(_));
  }, c.domain = function(_) {
    return arguments.length ? d(Array.from(_, yB)) : d().map(mB);
  }, c.ticks = function(_) {
    var w = d();
    return e(w[0], w[w.length - 1], _ == null ? 10 : _);
  }, c.tickFormat = function(_, w) {
    return w == null ? E : l(w);
  }, c.nice = function(_) {
    var w = d();
    return (!_ || typeof _.range != "function") && (_ = t(w[0], w[w.length - 1], _ == null ? 10 : _)), _ ? d(D3(w, _)) : c;
  }, c.copy = function() {
    return Of(c, Px(e, t, n, i, r, o, a, s, u, l));
  }, c;
}
function vB() {
  return _r.apply(Px(SP, AP, pr, Hc, dl, Jr, yg, gg, Hr, Ab).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function bB() {
  return _r.apply(Px(EP, _P, gr, Yc, hl, Bo, vg, mg, Hr, $b).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function Bg() {
  var e = 0, t = 1, n, i, r, o, a = yn, s = !1, u;
  function l(f) {
    return f == null || isNaN(f = +f) ? u : a(r === 0 ? 0.5 : (f = (o(f) - n) * r, s ? Math.max(0, Math.min(1, f)) : f));
  }
  l.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = o(e = +e), i = o(t = +t), r = n === i ? 0 : 1 / (i - n), l) : [e, t];
  }, l.clamp = function(f) {
    return arguments.length ? (s = !!f, l) : s;
  }, l.interpolator = function(f) {
    return arguments.length ? (a = f, l) : a;
  };
  function c(f) {
    return function(d) {
      var h, p;
      return arguments.length ? ([h, p] = d, a = f(h, p), l) : [a(0), a(1)];
    };
  }
  return l.range = c(fa), l.rangeRound = c(Tf), l.unknown = function(f) {
    return arguments.length ? (u = f, l) : u;
  }, function(f) {
    return o = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), l;
  };
}
function da(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function zx() {
  var e = Ts(Bg()(yn));
  return e.copy = function() {
    return da(e, zx());
  }, la.apply(e, arguments);
}
function B3() {
  var e = Dx(Bg()).domain([1, 10]);
  return e.copy = function() {
    return da(e, B3()).base(e.base());
  }, la.apply(e, arguments);
}
function j3() {
  var e = Rx(Bg());
  return e.copy = function() {
    return da(e, j3()).constant(e.constant());
  }, la.apply(e, arguments);
}
function Bx() {
  var e = Lx(Bg());
  return e.copy = function() {
    return da(e, Bx()).exponent(e.exponent());
  }, la.apply(e, arguments);
}
function xB() {
  return Bx.apply(null, arguments).exponent(0.5);
}
function jg() {
  var e = 0, t = 0.5, n = 1, i = 1, r, o, a, s, u, l = yn, c, f = !1, d;
  function h(g) {
    return isNaN(g = +g) ? d : (g = 0.5 + ((g = +c(g)) - o) * (i * g < i * o ? s : u), l(f ? Math.max(0, Math.min(1, g)) : g));
  }
  h.domain = function(g) {
    return arguments.length ? ([e, t, n] = g, r = c(e = +e), o = c(t = +t), a = c(n = +n), s = r === o ? 0 : 0.5 / (o - r), u = o === a ? 0 : 0.5 / (a - o), i = o < r ? -1 : 1, h) : [e, t, n];
  }, h.clamp = function(g) {
    return arguments.length ? (f = !!g, h) : f;
  }, h.interpolator = function(g) {
    return arguments.length ? (l = g, h) : l;
  };
  function p(g) {
    return function(m) {
      var y, v, b;
      return arguments.length ? ([y, v, b] = m, l = Nx(g, [y, v, b]), h) : [l(0), l(0.5), l(1)];
    };
  }
  return h.range = p(fa), h.rangeRound = p(Tf), h.unknown = function(g) {
    return arguments.length ? (d = g, h) : d;
  }, function(g) {
    return c = g, r = g(e), o = g(t), a = g(n), s = r === o ? 0 : 0.5 / (o - r), u = o === a ? 0 : 0.5 / (a - o), i = o < r ? -1 : 1, h;
  };
}
function U3() {
  var e = Ts(jg()(yn));
  return e.copy = function() {
    return da(e, U3());
  }, la.apply(e, arguments);
}
function q3() {
  var e = Dx(jg()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return da(e, q3()).base(e.base());
  }, la.apply(e, arguments);
}
function W3() {
  var e = Rx(jg());
  return e.copy = function() {
    return da(e, W3()).constant(e.constant());
  }, la.apply(e, arguments);
}
function jx() {
  var e = Lx(jg());
  return e.copy = function() {
    return da(e, jx()).exponent(e.exponent());
  }, la.apply(e, arguments);
}
function wB() {
  return jx.apply(null, arguments).exponent(0.5);
}
function Ux(e, t, n) {
  const i = e - t + n * 2;
  return e ? i > 0 ? i : 1 : 0;
}
const EB = "identity", Du = "linear", ro = "log", Nf = "pow", Df = "sqrt", Ug = "symlog", ss = "time", us = "utc", lr = "sequential", vl = "diverging", Ru = "quantile", qg = "quantize", Wg = "threshold", qx = "ordinal", by = "point", G3 = "band", Wx = "bin-ordinal", ct = "continuous", Rf = "discrete", Lf = "discretizing", ai = "interpolating", Gx = "temporal";
function _B(e) {
  return function(t) {
    let n = t[0], i = t[1], r;
    return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
  };
}
function SB(e) {
  return function(t) {
    const n = e.range();
    let i = t[0], r = t[1], o = -1, a, s, u, l;
    for (r < i && (s = i, i = r, r = s), u = 0, l = n.length; u < l; ++u)
      n[u] >= i && n[u] <= r && (o < 0 && (o = u), a = u);
    if (!(o < 0))
      return i = e.invertExtent(n[o]), r = e.invertExtent(n[a]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
  };
}
function Hx() {
  const e = Cx().unknown(void 0), t = e.domain, n = e.range;
  let i = [0, 1], r, o, a = !1, s = 0, u = 0, l = 0.5;
  delete e.unknown;
  function c() {
    const f = t().length, d = i[1] < i[0], h = i[1 - d], p = Ux(f, s, u);
    let g = i[d - 0];
    r = (h - g) / (p || 1), a && (r = Math.floor(r)), g += (h - g - r * (f - s)) * l, o = r * (1 - s), a && (g = Math.round(g), o = Math.round(o));
    const m = Pn(f).map((y) => g + r * y);
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), c()) : t();
  }, e.range = function(f) {
    return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
  }, e.rangeRound = function(f) {
    return i = [+f[0], +f[1]], a = !0, c();
  }, e.bandwidth = function() {
    return o;
  }, e.step = function() {
    return r;
  }, e.round = function(f) {
    return arguments.length ? (a = !!f, c()) : a;
  }, e.padding = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), s = u, c()) : s;
  }, e.paddingInner = function(f) {
    return arguments.length ? (s = Math.max(0, Math.min(1, f)), c()) : s;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
  }, e.align = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
  }, e.invertRange = function(f) {
    if (f[0] == null || f[1] == null)
      return;
    const d = i[1] < i[0], h = d ? n().reverse() : n(), p = h.length - 1;
    let g = +f[0], m = +f[1], y, v, b;
    if (!(g !== g || m !== m) && (m < g && (b = g, g = m, m = b), !(m < h[0] || g > i[1 - d])))
      return y = Math.max(0, Mh(h, g) - 1), v = g === m ? y : Mh(h, m) - 1, g - h[y] > o + 1e-10 && ++y, d && (b = y, y = p - v, v = p - b), y > v ? void 0 : t().slice(y, v + 1);
  }, e.invert = function(f) {
    const d = e.invertRange([f, f]);
    return d && d[0];
  }, e.copy = function() {
    return Hx().domain(t()).range(i).round(a).paddingInner(s).paddingOuter(u).align(l);
  }, c();
}
function H3(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return H3(t());
  }, e;
}
function AB() {
  return H3(Hx().paddingInner(1));
}
var $B = Array.prototype.map;
function kB(e) {
  return $B.call(e, It);
}
const CB = Array.prototype.slice;
function Y3() {
  let e = [], t = [];
  function n(i) {
    return i == null || i !== i ? void 0 : t[($f(e, i) - 1) % t.length];
  }
  return n.domain = function(i) {
    return arguments.length ? (e = kB(i), n) : e.slice();
  }, n.range = function(i) {
    return arguments.length ? (t = CB.call(i), n) : t.slice();
  }, n.tickFormat = function(i, r) {
    return T3(e[0], xe(e), i == null ? 10 : i, r);
  }, n.copy = function() {
    return Y3().domain(n.domain()).range(n.range());
  }, n;
}
const Yh = /* @__PURE__ */ new Map(), X3 = Symbol("vega_scale");
function V3(e) {
  return e[X3] = !0, e;
}
function FB(e) {
  return e && e[X3] === !0;
}
function MB(e, t, n) {
  const i = function() {
    const o = t();
    return o.invertRange || (o.invertRange = o.invert ? _B(o) : o.invertExtent ? SB(o) : void 0), o.type = e, V3(o);
  };
  return i.metadata = Oi(X(n)), i;
}
function $e(e, t, n) {
  return arguments.length > 1 ? (Yh.set(e, MB(e, t, n)), this) : K3(e) ? Yh.get(e) : void 0;
}
$e(EB, N3);
$e(Du, O3, ct);
$e(ro, R3, [ct, ro]);
$e(Nf, Ix, ct);
$e(Df, gB, ct);
$e(Ug, L3, ct);
$e(ss, vB, [ct, Gx]);
$e(us, bB, [ct, Gx]);
$e(lr, zx, [ct, ai]);
$e(`${lr}-${Du}`, zx, [ct, ai]);
$e(`${lr}-${ro}`, B3, [ct, ai, ro]);
$e(`${lr}-${Nf}`, Bx, [ct, ai]);
$e(`${lr}-${Df}`, xB, [ct, ai]);
$e(`${lr}-${Ug}`, j3, [ct, ai]);
$e(`${vl}-${Du}`, U3, [ct, ai]);
$e(`${vl}-${ro}`, q3, [ct, ai, ro]);
$e(`${vl}-${Nf}`, jx, [ct, ai]);
$e(`${vl}-${Df}`, wB, [ct, ai]);
$e(`${vl}-${Ug}`, W3, [ct, ai]);
$e(Ru, I3, [Lf, Ru]);
$e(qg, P3, Lf);
$e(Wg, z3, Lf);
$e(Wx, Y3, [Rf, Lf]);
$e(qx, Cx, Rf);
$e(G3, Hx, Rf);
$e(by, AB, Rf);
function K3(e) {
  return Yh.has(e);
}
function Os(e, t) {
  const n = Yh.get(e);
  return n && n.metadata[t];
}
function Yx(e) {
  return Os(e, ct);
}
function Lu(e) {
  return Os(e, Rf);
}
function xy(e) {
  return Os(e, Lf);
}
function J3(e) {
  return Os(e, ro);
}
function TB(e) {
  return Os(e, Gx);
}
function Q3(e) {
  return Os(e, ai);
}
function Z3(e) {
  return Os(e, Ru);
}
const OB = ["clamp", "base", "constant", "exponent"];
function eO(e, t) {
  const n = t[0], i = xe(t) - n;
  return function(r) {
    return e(n + r * i);
  };
}
function Gg(e, t, n) {
  return Nx(Xx(t || "rgb", n), e);
}
function tO(e, t) {
  const n = new Array(t), i = t + 1;
  for (let r = 0; r < t; )
    n[r] = e(++r / i);
  return n;
}
function nO(e, t, n) {
  const i = n - t;
  let r, o, a;
  return !i || !Number.isFinite(i) ? Gt(0.5) : (r = (o = e.type).indexOf("-"), o = r < 0 ? o : o.slice(r + 1), a = $e(o)().domain([t, n]).range([0, 1]), OB.forEach((s) => e[s] ? a[s](e[s]()) : 0), a);
}
function Xx(e, t) {
  const n = iB[NB(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function NB(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const DB = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, RB = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function iO(e) {
  const t = e.length / 6 | 0, n = new Array(t);
  for (let i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
function rO(e, t) {
  for (const n in e)
    Vx(n, t(e[n]));
}
const YS = {};
rO(RB, iO);
rO(DB, (e) => Gg(iO(e)));
function Vx(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (YS[e] = t, this) : YS[e];
}
const oh = "symbol", LB = "discrete", IB = "gradient", PB = (e) => P(e) ? e.map((t) => String(t)) : String(e), zB = (e, t) => e[1] - t[1], BB = (e, t) => t[1] - e[1];
function Kx(e, t, n) {
  let i;
  return Oe(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(Sf(e.domain()) / n || 1)))), K(t) && (i = t.step, t = t.interval), Y(t) && (t = e.type === ss ? pl(t) : e.type == us ? gl(t) : I("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t;
}
function oO(e, t, n) {
  let i = e.range(), r = i[0], o = xe(i), a = zB;
  if (r > o && (i = o, o = r, r = i, a = BB), r = Math.floor(r), o = Math.ceil(o), t = t.map((s) => [s, e(s)]).filter((s) => r <= s[1] && s[1] <= o).sort(a).map((s) => s[0]), n > 0 && t.length > 1) {
    const s = [t[0], xe(t)];
    for (; t.length > n && t.length >= 3; )
      t = t.filter((u, l) => !(l % 2));
    t.length < 3 && (t = s);
  }
  return t;
}
function Jx(e, t) {
  return e.bins ? oO(e, e.bins) : e.ticks ? e.ticks(t) : e.domain();
}
function aO(e, t, n, i, r, o) {
  const a = t.type;
  let s = PB;
  if (a === ss || r === ss)
    s = e.timeFormat(i);
  else if (a === us || r === us)
    s = e.utcFormat(i);
  else if (J3(a)) {
    const u = e.formatFloat(i);
    if (o || t.bins)
      s = u;
    else {
      const l = sO(t, n, !1);
      s = (c) => l(c) ? u(c) : "";
    }
  } else if (t.tickFormat) {
    const u = t.domain();
    s = e.formatSpan(u[0], u[u.length - 1], n, i);
  } else
    i && (s = e.format(i));
  return s;
}
function sO(e, t, n) {
  const i = Jx(e, t), r = e.base(), o = Math.log(r), a = Math.max(1, r * t / i.length), s = (u) => {
    let l = u / Math.pow(r, Math.round(Math.log(u) / o));
    return l * r < r - 0.5 && (l *= r), l <= a;
  };
  return n ? i.filter(s) : s;
}
const wy = {
  [Ru]: "quantiles",
  [qg]: "thresholds",
  [Wg]: "domain"
}, uO = {
  [Ru]: "quantiles",
  [qg]: "domain"
};
function lO(e, t) {
  return e.bins ? qB(e.bins) : e.type === ro ? sO(e, t, !0) : wy[e.type] ? UB(e[wy[e.type]]()) : Jx(e, t);
}
function jB(e, t, n) {
  const i = t[uO[t.type]](), r = i.length;
  let o = r > 1 ? i[1] - i[0] : i[0], a;
  for (a = 1; a < r; ++a)
    o = Math.min(o, i[a] - i[a - 1]);
  return e.formatSpan(0, o, 3 * 10, n);
}
function UB(e) {
  const t = [-1 / 0].concat(e);
  return t.max = 1 / 0, t;
}
function qB(e) {
  const t = e.slice(0, -1);
  return t.max = xe(e), t;
}
const WB = (e) => wy[e.type] || e.bins;
function cO(e, t, n, i, r, o, a) {
  const s = uO[t.type] && o !== ss && o !== us ? jB(e, t, r) : aO(e, t, n, r, o, a);
  return i === oh && WB(t) ? GB(s) : i === LB ? HB(s) : YB(s);
}
const GB = (e) => (t, n, i) => {
  const r = XS(i[n + 1], XS(i.max, 1 / 0)), o = VS(t, e), a = VS(r, e);
  return o && a ? o + " \u2013 " + a : a ? "< " + a : "\u2265 " + o;
}, XS = (e, t) => e != null ? e : t, HB = (e) => (t, n) => n ? e(t) : null, YB = (e) => (t) => e(t), VS = (e, t) => Number.isFinite(e) ? t(e) : null;
function XB(e) {
  const t = e.domain(), n = t.length - 1;
  let i = +t[0], r = +xe(t), o = r - i;
  if (e.type === Wg) {
    const a = n ? o / n : 0.1;
    i -= a, r += a, o = r - i;
  }
  return (a) => (a - i) / o;
}
function VB(e, t, n, i) {
  const r = i || t.type;
  return Y(n) && TB(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === ss ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === us ? e.utcFormat("%A, %d %B %Y, %X UTC") : cO(e, t, 5, null, n, i, !0);
}
function fO(e, t, n) {
  n = n || {};
  const i = Math.max(3, n.maxlen || 7), r = VB(e, t, n.format, n.formatType);
  if (xy(t.type)) {
    const o = lO(t).slice(1).map(r), a = o.length;
    return `${a} boundar${a === 1 ? "y" : "ies"}: ${o.join(", ")}`;
  } else if (Lu(t.type)) {
    const o = t.domain(), a = o.length, s = a > i ? o.slice(0, i - 2).map(r).join(", ") + ", ending with " + o.slice(-1).map(r) : o.map(r).join(", ");
    return `${a} value${a === 1 ? "" : "s"}: ${s}`;
  } else {
    const o = t.domain();
    return `values from ${r(o[0])} to ${r(xe(o))}`;
  }
}
let dO = 0;
function KB() {
  dO = 0;
}
const Xh = "p_";
function Qx(e) {
  return e && e.gradient;
}
function hO(e, t, n) {
  const i = e.gradient;
  let r = e.id, o = i === "radial" ? Xh : "";
  return r || (r = e.id = "gradient_" + dO++, i === "radial" ? (e.x1 = Xi(e.x1, 0.5), e.y1 = Xi(e.y1, 0.5), e.r1 = Xi(e.r1, 0), e.x2 = Xi(e.x2, 0.5), e.y2 = Xi(e.y2, 0.5), e.r2 = Xi(e.r2, 0.5), o = Xh) : (e.x1 = Xi(e.x1, 0), e.y1 = Xi(e.y1, 0), e.x2 = Xi(e.x2, 1), e.y2 = Xi(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + o + r + ")";
}
function Xi(e, t) {
  return e != null ? e : t;
}
function pO(e, t) {
  var n = [], i;
  return i = {
    gradient: "linear",
    x1: e ? e[0] : 0,
    y1: e ? e[1] : 0,
    x2: t ? t[0] : 1,
    y2: t ? t[1] : 0,
    stops: n,
    stop: function(r, o) {
      return n.push({
        offset: r,
        color: o
      }), i;
    }
  };
}
const KS = {
  basis: {
    curve: t7
  },
  "basis-closed": {
    curve: n7
  },
  "basis-open": {
    curve: i7
  },
  bundle: {
    curve: r7,
    tension: "beta",
    value: 0.85
  },
  cardinal: {
    curve: o7,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: s7,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: a7,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: u7,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: l7,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: c7,
    tension: "alpha",
    value: 0.5
  },
  linear: {
    curve: _x
  },
  "linear-closed": {
    curve: f7
  },
  monotone: {
    horizontal: h7,
    vertical: d7
  },
  natural: {
    curve: p7
  },
  step: {
    curve: g7
  },
  "step-after": {
    curve: y7
  },
  "step-before": {
    curve: m7
  }
};
function Zx(e, t, n) {
  var i = ie(KS, e) && KS[e], r = null;
  return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r;
}
const JB = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
}, QB = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, ZB = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, ej = /^((\s+,?\s*)|(,\s*))/, tj = /^[01]/;
function Iu(e) {
  const t = [];
  return (e.match(QB) || []).forEach((i) => {
    let r = i[0];
    const o = r.toLowerCase(), a = JB[o], s = nj(o, a, i.slice(1).trim()), u = s.length;
    if (u < a || u && u % a !== 0)
      throw Error("Invalid SVG path, incorrect parameter count");
    if (t.push([r, ...s.slice(0, a)]), u !== a) {
      o === "m" && (r = r === "M" ? "L" : "l");
      for (let l = a; l < u; l += a)
        t.push([r, ...s.slice(l, l + a)]);
    }
  }), t;
}
function nj(e, t, n) {
  const i = [];
  for (let r = 0; t && r < n.length; )
    for (let o = 0; o < t; ++o) {
      const a = e === "a" && (o === 3 || o === 4) ? tj : ZB, s = n.slice(r).match(a);
      if (s === null)
        throw Error("Invalid SVG path, incorrect parameter type");
      r += s[0].length, i.push(+s[0]);
      const u = n.slice(r).match(ej);
      u !== null && (r += u[0].length);
    }
  return i;
}
const Ko = Math.PI / 180, ij = 1e-14, Pa = Math.PI / 2, er = Math.PI * 2, Xs = Math.sqrt(3) / 2;
var I0 = {}, P0 = {}, gO = [].join;
function rj(e, t, n, i, r, o, a, s, u) {
  const l = gO.call(arguments);
  if (I0[l])
    return I0[l];
  const c = a * Ko, f = Math.sin(c), d = Math.cos(c);
  n = Math.abs(n), i = Math.abs(i);
  const h = d * (s - e) * 0.5 + f * (u - t) * 0.5, p = d * (u - t) * 0.5 - f * (s - e) * 0.5;
  let g = h * h / (n * n) + p * p / (i * i);
  g > 1 && (g = Math.sqrt(g), n *= g, i *= g);
  const m = d / n, y = f / n, v = -f / i, b = d / i, x = m * s + y * u, E = v * s + b * u, _ = m * e + y * t, w = v * e + b * t;
  let C = 1 / ((_ - x) * (_ - x) + (w - E) * (w - E)) - 0.25;
  C < 0 && (C = 0);
  let $ = Math.sqrt(C);
  o == r && ($ = -$);
  const A = 0.5 * (x + _) - $ * (w - E), M = 0.5 * (E + w) + $ * (_ - x), F = Math.atan2(E - M, x - A);
  let k = Math.atan2(w - M, _ - A) - F;
  k < 0 && o === 1 ? k += er : k > 0 && o === 0 && (k -= er);
  const T = Math.ceil(Math.abs(k / (Pa + 1e-3))), N = [];
  for (let L = 0; L < T; ++L) {
    const z = F + L * k / T, J = F + (L + 1) * k / T;
    N[L] = [A, M, z, J, n, i, f, d];
  }
  return I0[l] = N;
}
function oj(e) {
  const t = gO.call(e);
  if (P0[t])
    return P0[t];
  var n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], s = e[5], u = e[6], l = e[7];
  const c = l * a, f = -u * s, d = u * a, h = l * s, p = Math.cos(r), g = Math.sin(r), m = Math.cos(o), y = Math.sin(o), v = 0.5 * (o - r), b = Math.sin(v * 0.5), x = 8 / 3 * b * b / Math.sin(v), E = n + p - x * g, _ = i + g + x * p, w = n + m, S = i + y, C = w + x * y, $ = S - x * m;
  return P0[t] = [c * E + f * _, d * E + h * _, c * C + f * $, d * C + h * $, c * w + f * S, d * w + h * S];
}
const Hn = ["l", 0, 0, 0, 0, 0, 0, 0];
function aj(e, t, n) {
  const i = Hn[0] = e[0];
  if (i === "a" || i === "A")
    Hn[1] = t * e[1], Hn[2] = n * e[2], Hn[3] = e[3], Hn[4] = e[4], Hn[5] = e[5], Hn[6] = t * e[6], Hn[7] = n * e[7];
  else if (i === "h" || i === "H")
    Hn[1] = t * e[1];
  else if (i === "v" || i === "V")
    Hn[1] = n * e[1];
  else
    for (var r = 1, o = e.length; r < o; ++r)
      Hn[r] = (r % 2 == 1 ? t : n) * e[r];
  return Hn;
}
function ef(e, t, n, i, r, o) {
  var a, s = null, u = 0, l = 0, c = 0, f = 0, d, h, p, g, m = 0, y = 0;
  n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), o == null && (o = r), e.beginPath && e.beginPath();
  for (var v = 0, b = t.length; v < b; ++v) {
    switch (a = t[v], (r !== 1 || o !== 1) && (a = aj(a, r, o)), a[0]) {
      case "l":
        u += a[1], l += a[2], e.lineTo(u + n, l + i);
        break;
      case "L":
        u = a[1], l = a[2], e.lineTo(u + n, l + i);
        break;
      case "h":
        u += a[1], e.lineTo(u + n, l + i);
        break;
      case "H":
        u = a[1], e.lineTo(u + n, l + i);
        break;
      case "v":
        l += a[1], e.lineTo(u + n, l + i);
        break;
      case "V":
        l = a[1], e.lineTo(u + n, l + i);
        break;
      case "m":
        u += a[1], l += a[2], m = u, y = l, e.moveTo(u + n, l + i);
        break;
      case "M":
        u = a[1], l = a[2], m = u, y = l, e.moveTo(u + n, l + i);
        break;
      case "c":
        d = u + a[5], h = l + a[6], c = u + a[3], f = l + a[4], e.bezierCurveTo(
          u + a[1] + n,
          l + a[2] + i,
          c + n,
          f + i,
          d + n,
          h + i
        ), u = d, l = h;
        break;
      case "C":
        u = a[5], l = a[6], c = a[3], f = a[4], e.bezierCurveTo(a[1] + n, a[2] + i, c + n, f + i, u + n, l + i);
        break;
      case "s":
        d = u + a[3], h = l + a[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, u + a[1] + n, l + a[2] + i, d + n, h + i), c = u + a[1], f = l + a[2], u = d, l = h;
        break;
      case "S":
        d = a[3], h = a[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, a[1] + n, a[2] + i, d + n, h + i), u = d, l = h, c = a[1], f = a[2];
        break;
      case "q":
        d = u + a[3], h = l + a[4], c = u + a[1], f = l + a[2], e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
        break;
      case "Q":
        d = a[3], h = a[4], e.quadraticCurveTo(a[1] + n, a[2] + i, d + n, h + i), u = d, l = h, c = a[1], f = a[2];
        break;
      case "t":
        d = u + a[1], h = l + a[2], s[0].match(/[QqTt]/) === null ? (c = u, f = l) : s[0] === "t" ? (c = 2 * u - p, f = 2 * l - g) : s[0] === "q" && (c = 2 * u - c, f = 2 * l - f), p = c, g = f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h, c = u + a[1], f = l + a[2];
        break;
      case "T":
        d = a[1], h = a[2], c = 2 * u - c, f = 2 * l - f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
        break;
      case "a":
        JS(e, u + n, l + i, [a[1], a[2], a[3], a[4], a[5], a[6] + u + n, a[7] + l + i]), u += a[6], l += a[7];
        break;
      case "A":
        JS(e, u + n, l + i, [a[1], a[2], a[3], a[4], a[5], a[6] + n, a[7] + i]), u = a[6], l = a[7];
        break;
      case "z":
      case "Z":
        u = m, l = y, e.closePath();
        break;
    }
    s = a;
  }
}
function JS(e, t, n, i) {
  const r = rj(
    i[5],
    i[6],
    i[0],
    i[1],
    i[3],
    i[4],
    i[2],
    t,
    n
  );
  for (let o = 0; o < r.length; ++o) {
    const a = oj(r[o]);
    e.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
  }
}
const QS = 0.5773502691896257, ZS = {
  circle: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(n, 0), e.arc(0, 0, n, 0, er);
    }
  },
  cross: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 2.5;
      e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath();
    }
  },
  diamond: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath();
    }
  },
  square: {
    draw: function(e, t) {
      var n = Math.sqrt(t), i = -n / 2;
      e.rect(i, i, n, n);
    }
  },
  arrow: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 7, r = n / 2.5, o = n / 8;
      e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -o), e.lineTo(r, -o), e.lineTo(0, -n), e.lineTo(-r, -o), e.lineTo(-i, -o), e.closePath();
    }
  },
  wedge: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Xs * n, r = i - n * QS, o = n / 4;
      e.moveTo(0, -i - r), e.lineTo(-o, i - r), e.lineTo(o, i - r), e.closePath();
    }
  },
  triangle: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Xs * n, r = i - n * QS;
      e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath();
    }
  },
  "triangle-up": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Xs * n;
      e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath();
    }
  },
  "triangle-down": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Xs * n;
      e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath();
    }
  },
  "triangle-right": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Xs * n;
      e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath();
    }
  },
  "triangle-left": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Xs * n;
      e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath();
    }
  },
  stroke: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(n, 0);
    }
  }
};
function mO(e) {
  return ie(ZS, e) ? ZS[e] : sj(e);
}
var z0 = {};
function sj(e) {
  if (!ie(z0, e)) {
    const t = Iu(e);
    z0[e] = {
      draw: function(n, i) {
        ef(n, t, 0, 0, Math.sqrt(i) / 2);
      }
    };
  }
  return z0[e];
}
const bo = 0.448084975506;
function uj(e) {
  return e.x;
}
function lj(e) {
  return e.y;
}
function cj(e) {
  return e.width;
}
function fj(e) {
  return e.height;
}
function Dr(e) {
  return typeof e == "function" ? e : () => +e;
}
function _d(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
function yO() {
  var e = uj, t = lj, n = cj, i = fj, r = Dr(0), o = r, a = r, s = r, u = null;
  function l(c, f, d) {
    var h, p = f != null ? f : +e.call(this, c), g = d != null ? d : +t.call(this, c), m = +n.call(this, c), y = +i.call(this, c), v = Math.min(m, y) / 2, b = _d(+r.call(this, c), 0, v), x = _d(+o.call(this, c), 0, v), E = _d(+a.call(this, c), 0, v), _ = _d(+s.call(this, c), 0, v);
    if (u || (u = h = Og()), b <= 0 && x <= 0 && E <= 0 && _ <= 0)
      u.rect(p, g, m, y);
    else {
      var w = p + m, S = g + y;
      u.moveTo(p + b, g), u.lineTo(w - x, g), u.bezierCurveTo(w - bo * x, g, w, g + bo * x, w, g + x), u.lineTo(w, S - _), u.bezierCurveTo(w, S - bo * _, w - bo * _, S, w - _, S), u.lineTo(p + E, S), u.bezierCurveTo(p + bo * E, S, p, S - bo * E, p, S - E), u.lineTo(p, g + b), u.bezierCurveTo(p, g + bo * b, p + bo * b, g, p + b, g), u.closePath();
    }
    if (h)
      return u = null, h + "" || null;
  }
  return l.x = function(c) {
    return arguments.length ? (e = Dr(c), l) : e;
  }, l.y = function(c) {
    return arguments.length ? (t = Dr(c), l) : t;
  }, l.width = function(c) {
    return arguments.length ? (n = Dr(c), l) : n;
  }, l.height = function(c) {
    return arguments.length ? (i = Dr(c), l) : i;
  }, l.cornerRadius = function(c, f, d, h) {
    return arguments.length ? (r = Dr(c), o = f != null ? Dr(f) : r, s = d != null ? Dr(d) : r, a = h != null ? Dr(h) : o, l) : r;
  }, l.context = function(c) {
    return arguments.length ? (u = c == null ? null : c, l) : u;
  }, l;
}
function vO() {
  var e, t, n, i, r = null, o, a, s, u;
  function l(f, d, h) {
    const p = h / 2;
    if (o) {
      var g = s - d, m = f - a;
      if (g || m) {
        var y = Math.sqrt(g * g + m * m), v = (g /= y) * u, b = (m /= y) * u, x = Math.atan2(m, g);
        r.moveTo(a - v, s - b), r.lineTo(f - g * p, d - m * p), r.arc(f, d, p, x - Math.PI, x), r.lineTo(a + v, s + b), r.arc(a, s, u, x, x + Math.PI);
      } else
        r.arc(f, d, p, 0, er);
      r.closePath();
    } else
      o = 1;
    a = f, s = d, u = p;
  }
  function c(f) {
    var d, h = f.length, p, g = !1, m;
    for (r == null && (r = m = Og()), d = 0; d <= h; ++d)
      !(d < h && i(p = f[d], d, f)) === g && (g = !g) && (o = 0), g && l(+e(p, d, f), +t(p, d, f), +n(p, d, f));
    if (m)
      return r = null, m + "" || null;
  }
  return c.x = function(f) {
    return arguments.length ? (e = f, c) : e;
  }, c.y = function(f) {
    return arguments.length ? (t = f, c) : t;
  }, c.size = function(f) {
    return arguments.length ? (n = f, c) : n;
  }, c.defined = function(f) {
    return arguments.length ? (i = f, c) : i;
  }, c.context = function(f) {
    return arguments.length ? (f == null ? r = null : r = f, c) : r;
  }, c;
}
function If(e, t) {
  return e != null ? e : t;
}
const Pf = (e) => e.x || 0, zf = (e) => e.y || 0, dj = (e) => e.width || 0, hj = (e) => e.height || 0, pj = (e) => (e.x || 0) + (e.width || 0), gj = (e) => (e.y || 0) + (e.height || 0), mj = (e) => e.startAngle || 0, yj = (e) => e.endAngle || 0, vj = (e) => e.padAngle || 0, bj = (e) => e.innerRadius || 0, xj = (e) => e.outerRadius || 0, wj = (e) => e.cornerRadius || 0, Ej = (e) => If(e.cornerRadiusTopLeft, e.cornerRadius) || 0, _j = (e) => If(e.cornerRadiusTopRight, e.cornerRadius) || 0, Sj = (e) => If(e.cornerRadiusBottomRight, e.cornerRadius) || 0, Aj = (e) => If(e.cornerRadiusBottomLeft, e.cornerRadius) || 0, $j = (e) => If(e.size, 64), kj = (e) => e.size || 1, Hg = (e) => e.defined !== !1, Cj = (e) => mO(e.shape || "circle"), Fj = Q9().startAngle(mj).endAngle(yj).padAngle(vj).innerRadius(bj).outerRadius(xj).cornerRadius(wj), Mj = YT().x(Pf).y1(zf).y0(gj).defined(Hg), Tj = YT().y(zf).x1(Pf).x0(pj).defined(Hg), Oj = HT().x(Pf).y(zf).defined(Hg), Nj = yO().x(Pf).y(zf).width(dj).height(hj).cornerRadius(Ej, _j, Sj, Aj), Dj = e7().type(Cj).size($j), Rj = vO().x(Pf).y(zf).defined(Hg).size(kj);
function e2(e) {
  return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
}
function Lj(e, t) {
  return Fj.context(e)(t);
}
function Ij(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return (n.orient === "horizontal" ? Tj : Mj).curve(Zx(i, n.orient, n.tension)).context(e)(t);
}
function Pj(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return Oj.curve(Zx(i, n.orient, n.tension)).context(e)(t);
}
function bl(e, t, n, i) {
  return Nj.context(e)(t, n, i);
}
function zj(e, t) {
  return (t.mark.shape || t.shape).context(e)(t);
}
function Bj(e, t) {
  return Dj.context(e)(t);
}
function jj(e, t) {
  return Rj.context(e)(t);
}
var bO = 1;
function xO() {
  bO = 1;
}
function t2(e, t, n) {
  var i = t.clip, r = e._defs, o = t.clip_id || (t.clip_id = "clip" + bO++), a = r.clipping[o] || (r.clipping[o] = {
    id: o
  });
  return fe(i) ? a.path = i(null) : e2(n) ? a.path = bl(null, n, 0, 0) : (a.width = n.width || 0, a.height = n.height || 0), "url(#" + o + ")";
}
function nt(e) {
  this.clear(), e && this.union(e);
}
nt.prototype = {
  clone() {
    return new nt(this);
  },
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(e) {
    return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2;
  },
  set(e, t, n, i) {
    return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this;
  },
  add(e, t) {
    return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this;
  },
  expand(e) {
    return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this;
  },
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  },
  scale(e) {
    return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this;
  },
  translate(e, t) {
    return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this;
  },
  rotate(e, t, n) {
    const i = this.rotatedPoints(e, t, n);
    return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7]);
  },
  rotatedPoints(e, t, n) {
    var {
      x1: i,
      y1: r,
      x2: o,
      y2: a
    } = this, s = Math.cos(e), u = Math.sin(e), l = t - t * s + n * u, c = n - t * u - n * s;
    return [s * i - u * r + l, u * i + s * r + c, s * i - u * a + l, u * i + s * a + c, s * o - u * r + l, u * o + s * r + c, s * o - u * a + l, u * o + s * a + c];
  },
  union(e) {
    return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this;
  },
  intersect(e) {
    return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this;
  },
  encloses(e) {
    return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2;
  },
  alignsWith(e) {
    return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2);
  },
  intersects(e) {
    return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2);
  },
  contains(e, t) {
    return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Yg(e) {
  this.mark = e, this.bounds = this.bounds || new nt();
}
function Xg(e) {
  Yg.call(this, e), this.items = this.items || [];
}
G(Xg, Yg);
function n2(e) {
  this._pending = 0, this._loader = e || xg();
}
function eA(e) {
  e._pending += 1;
}
function Wl(e) {
  e._pending -= 1;
}
n2.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(e) {
    const t = this;
    return eA(t), t._loader.sanitize(e, {
      context: "href"
    }).then((n) => (Wl(t), n)).catch(() => (Wl(t), null));
  },
  loadImage(e) {
    const t = this, n = v7();
    return eA(t), t._loader.sanitize(e, {
      context: "image"
    }).then((i) => {
      const r = i.href;
      if (!r || !n)
        throw {
          url: r
        };
      const o = new n(), a = ie(i, "crossOrigin") ? i.crossOrigin : "anonymous";
      return a != null && (o.crossOrigin = a), o.onload = () => Wl(t), o.onerror = () => Wl(t), o.src = r, o;
    }).catch((i) => (Wl(t), {
      complete: !1,
      width: 0,
      height: 0,
      src: i && i.url || ""
    }));
  },
  ready() {
    const e = this;
    return new Promise((t) => {
      function n(i) {
        e.pending() ? setTimeout(() => {
          n(!0);
        }, 10) : t(i);
      }
      n(!1);
    });
  }
};
function uo(e, t, n) {
  if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
    const i = t.strokeWidth != null ? +t.strokeWidth : 1;
    e.expand(i + (n ? Uj(t, i) : 0));
  }
  return e;
}
function Uj(e, t) {
  return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
}
const qj = er - 1e-8;
let Vg, ah, sh, Ga, Ey, uh, _y, Sy;
const Mo = (e, t) => Vg.add(e, t), lh = (e, t) => Mo(ah = e, sh = t), tA = (e) => Mo(e, Vg.y1), nA = (e) => Mo(Vg.x1, e), za = (e, t) => Ey * e + _y * t, Ba = (e, t) => uh * e + Sy * t, B0 = (e, t) => Mo(za(e, t), Ba(e, t)), j0 = (e, t) => lh(za(e, t), Ba(e, t));
function Bf(e, t) {
  return Vg = e, t ? (Ga = t * Ko, Ey = Sy = Math.cos(Ga), uh = Math.sin(Ga), _y = -uh) : (Ey = Sy = 1, Ga = uh = _y = 0), Wj;
}
const Wj = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: j0,
  lineTo: j0,
  rect(e, t, n, i) {
    Ga ? (B0(e + n, t), B0(e + n, t + i), B0(e, t + i), j0(e, t)) : (Mo(e + n, t + i), lh(e, t));
  },
  quadraticCurveTo(e, t, n, i) {
    const r = za(e, t), o = Ba(e, t), a = za(n, i), s = Ba(n, i);
    iA(ah, r, a, tA), iA(sh, o, s, nA), lh(a, s);
  },
  bezierCurveTo(e, t, n, i, r, o) {
    const a = za(e, t), s = Ba(e, t), u = za(n, i), l = Ba(n, i), c = za(r, o), f = Ba(r, o);
    rA(ah, a, u, c, tA), rA(sh, s, l, f, nA), lh(c, f);
  },
  arc(e, t, n, i, r, o) {
    if (i += Ga, r += Ga, ah = n * Math.cos(r) + e, sh = n * Math.sin(r) + t, Math.abs(r - i) > qj)
      Mo(e - n, t - n), Mo(e + n, t + n);
    else {
      const a = (l) => Mo(n * Math.cos(l) + e, n * Math.sin(l) + t);
      let s, u;
      if (a(i), a(r), r !== i)
        if (i = i % er, i < 0 && (i += er), r = r % er, r < 0 && (r += er), r < i && (o = !o, s = i, i = r, r = s), o)
          for (r -= er, s = i - i % Pa, u = 0; u < 4 && s > r; ++u, s -= Pa)
            a(s);
        else
          for (s = i - i % Pa + Pa, u = 0; u < 4 && s < r; ++u, s = s + Pa)
            a(s);
    }
  }
};
function iA(e, t, n, i) {
  const r = (e - t) / (e + n - 2 * t);
  0 < r && r < 1 && i(e + (t - e) * r);
}
function rA(e, t, n, i, r) {
  const o = i - e + 3 * t - 3 * n, a = e + n - 2 * t, s = e - t;
  let u = 0, l = 0, c;
  Math.abs(o) > ij ? (c = a * a + s * o, c >= 0 && (c = Math.sqrt(c), u = (-a + c) / o, l = (-a - c) / o)) : u = 0.5 * s / a, 0 < u && u < 1 && r(oA(u, e, t, n, i)), 0 < l && l < 1 && r(oA(l, e, t, n, i));
}
function oA(e, t, n, i, r) {
  const o = 1 - e, a = o * o, s = e * e;
  return a * o * t + 3 * a * e * n + 3 * o * s * i + s * e * r;
}
var qo = (qo = Uo(1, 1)) ? qo.getContext("2d") : null;
const Ay = new nt();
function i2(e) {
  return function(t, n) {
    if (!qo)
      return !0;
    e(qo, t), Ay.clear().union(t.bounds).intersect(n).round();
    const {
      x1: i,
      y1: r,
      x2: o,
      y2: a
    } = Ay;
    for (let s = r; s <= a; ++s)
      for (let u = i; u <= o; ++u)
        if (qo.isPointInPath(u, s))
          return !0;
    return !1;
  };
}
function r2(e, t) {
  return t.contains(e.x || 0, e.y || 0);
}
function wO(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.width || 0, o = e.height || 0;
  return t.intersects(Ay.set(n, i, n + r, i + o));
}
function EO(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.x2 != null ? e.x2 : n, o = e.y2 != null ? e.y2 : i;
  return cu(t, n, i, r, o);
}
function cu(e, t, n, i, r) {
  const {
    x1: o,
    y1: a,
    x2: s,
    y2: u
  } = e, l = i - t, c = r - n;
  let f = 0, d = 1, h, p, g, m;
  for (m = 0; m < 4; ++m) {
    if (m === 0 && (h = -l, p = -(o - t)), m === 1 && (h = l, p = s - t), m === 2 && (h = -c, p = -(a - n)), m === 3 && (h = c, p = u - n), Math.abs(h) < 1e-10 && p < 0)
      return !1;
    if (g = p / h, h < 0) {
      if (g > d)
        return !1;
      g > f && (f = g);
    } else if (h > 0) {
      if (g < f)
        return !1;
      g < d && (d = g);
    }
  }
  return !0;
}
function Pu(e, t) {
  e.globalCompositeOperation = t.blend || "source-over";
}
function ci(e, t) {
  return e == null ? t : e;
}
function aA(e, t) {
  const n = t.length;
  for (let i = 0; i < n; ++i)
    e.addColorStop(t[i].offset, t[i].color);
  return e;
}
function Gj(e, t, n) {
  const i = n.width(), r = n.height();
  let o;
  if (t.gradient === "radial")
    o = e.createRadialGradient(n.x1 + ci(t.x1, 0.5) * i, n.y1 + ci(t.y1, 0.5) * r, Math.max(i, r) * ci(t.r1, 0), n.x1 + ci(t.x2, 0.5) * i, n.y1 + ci(t.y2, 0.5) * r, Math.max(i, r) * ci(t.r2, 0.5));
  else {
    const a = ci(t.x1, 0), s = ci(t.y1, 0), u = ci(t.x2, 1), l = ci(t.y2, 0);
    if (a === u || s === l || i === r)
      o = e.createLinearGradient(n.x1 + a * i, n.y1 + s * r, n.x1 + u * i, n.y1 + l * r);
    else {
      const c = Uo(Math.ceil(i), Math.ceil(r)), f = c.getContext("2d");
      return f.scale(i, r), f.fillStyle = aA(f.createLinearGradient(a, s, u, l), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
    }
  }
  return aA(o, t.stops);
}
function _O(e, t, n) {
  return Qx(n) ? Gj(e, n, t.bounds) : n;
}
function Vh(e, t, n) {
  return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = _O(e, t, t.fill), !0) : !1;
}
var Hj = [];
function zu(e, t, n) {
  var i = (i = t.strokeWidth) != null ? i : 1;
  return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = _O(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || Hj), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1);
}
function Yj(e, t) {
  return e.zindex - t.zindex || e.index - t.index;
}
function o2(e) {
  if (!e.zdirty)
    return e.zitems;
  var t = e.items, n = [], i, r, o;
  for (r = 0, o = t.length; r < o; ++r)
    i = t[r], i.index = r, i.zindex && n.push(i);
  return e.zdirty = !1, e.zitems = n.sort(Yj);
}
function Di(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return;
  const o = o2(e);
  if (o && o.length) {
    for (i = 0, r = n.length; i < r; ++i)
      n[i].zindex || t(n[i]);
    n = o;
  }
  for (i = 0, r = n.length; i < r; ++i)
    t(n[i]);
}
function Kh(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return null;
  const o = o2(e);
  for (o && o.length && (n = o), r = n.length; --r >= 0; )
    if (i = t(n[r]))
      return i;
  if (n === o) {
    for (n = e.items, r = n.length; --r >= 0; )
      if (!n[r].zindex && (i = t(n[r])))
        return i;
  }
  return null;
}
function a2(e) {
  return function(t, n, i) {
    Di(n, (r) => {
      (!i || i.intersects(r.bounds)) && SO(e, t, r, r);
    });
  };
}
function Xj(e) {
  return function(t, n, i) {
    n.items.length && (!i || i.intersects(n.bounds)) && SO(e, t, n.items[0], n.items);
  };
}
function SO(e, t, n, i) {
  var r = n.opacity == null ? 1 : n.opacity;
  r !== 0 && (e(t, i) || (Pu(t, n), n.fill && Vh(t, n, r) && t.fill(), n.stroke && zu(t, n, r) && t.stroke()));
}
function Kg(e) {
  return e = e || ei, function(t, n, i, r, o, a) {
    return i *= t.pixelRatio, r *= t.pixelRatio, Kh(n, (s) => {
      const u = s.bounds;
      if (!(u && !u.contains(o, a) || !u) && e(t, s, i, r, o, a))
        return s;
    });
  };
}
function jf(e, t) {
  return function(n, i, r, o) {
    var a = Array.isArray(i) ? i[0] : i, s = t == null ? a.fill : t, u = a.stroke && n.isPointInStroke, l, c;
    return u && (l = a.strokeWidth, c = a.strokeCap, n.lineWidth = l != null ? l : 1, n.lineCap = c != null ? c : "butt"), e(n, i) ? !1 : s && n.isPointInPath(r, o) || u && n.isPointInStroke(r, o);
  };
}
function s2(e) {
  return Kg(jf(e));
}
function Za(e, t) {
  return "translate(" + e + "," + t + ")";
}
function u2(e) {
  return "rotate(" + e + ")";
}
function Vj(e, t) {
  return "scale(" + e + "," + t + ")";
}
function AO(e) {
  return Za(e.x || 0, e.y || 0);
}
function Kj(e) {
  return Za(e.x || 0, e.y || 0) + (e.angle ? " " + u2(e.angle) : "");
}
function Jj(e) {
  return Za(e.x || 0, e.y || 0) + (e.angle ? " " + u2(e.angle) : "") + (e.scaleX || e.scaleY ? " " + Vj(e.scaleX || 1, e.scaleY || 1) : "");
}
function l2(e, t, n) {
  function i(a, s) {
    a("transform", Kj(s)), a("d", t(null, s));
  }
  function r(a, s) {
    return t(Bf(a, s.angle), s), uo(a, s).translate(s.x || 0, s.y || 0);
  }
  function o(a, s) {
    var u = s.x || 0, l = s.y || 0, c = s.angle || 0;
    a.translate(u, l), c && a.rotate(c *= Ko), a.beginPath(), t(a, s), c && a.rotate(-c), a.translate(-u, -l);
  }
  return {
    type: e,
    tag: "path",
    nested: !1,
    attr: i,
    bound: r,
    draw: a2(o),
    pick: s2(o),
    isect: n || i2(o)
  };
}
var Qj = l2("arc", Lj);
function Zj(e, t) {
  for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, o = 1 / 0, a, s; --r >= 0; )
    e[r].defined !== !1 && (s = Math.abs(e[r][i] - n), s < o && (o = s, a = e[r]));
  return a;
}
function eU(e, t) {
  for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, o, a; --i >= 0; )
    if (e[i].defined !== !1 && (r = e[i].x - t[0], o = e[i].y - t[1], a = r * r + o * o, a < n))
      return e[i];
  return null;
}
function tU(e, t) {
  for (var n = e.length, i, r, o; --n >= 0; )
    if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], o = i * i + r * r, i = e[n].size || 1, o < i * i))
      return e[n];
  return null;
}
function c2(e, t, n) {
  function i(u, l) {
    var c = l.mark.items;
    c.length && u("d", t(null, c));
  }
  function r(u, l) {
    var c = l.items;
    return c.length === 0 ? u : (t(Bf(u), c), uo(u, c[0]));
  }
  function o(u, l) {
    u.beginPath(), t(u, l);
  }
  const a = jf(o);
  function s(u, l, c, f, d, h) {
    var p = l.items, g = l.bounds;
    return !p || !p.length || g && !g.contains(d, h) ? null : (c *= u.pixelRatio, f *= u.pixelRatio, a(u, p, c, f) ? p[0] : null);
  }
  return {
    type: e,
    tag: "path",
    nested: !0,
    attr: i,
    bound: r,
    draw: Xj(o),
    pick: s,
    isect: r2,
    tip: n
  };
}
var nU = c2("area", Ij, Zj);
function iU(e, t) {
  var n = t.clip;
  e.save(), fe(n) ? (e.beginPath(), n(e), e.clip()) : $O(e, t.group);
}
function $O(e, t) {
  e.beginPath(), e2(t) ? bl(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip();
}
function kO(e) {
  const t = ci(e.strokeWidth, 1);
  return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > 0.5 && t < 1.5 ? 0.5 - Math.abs(t - 1) : 0;
}
function rU(e, t) {
  e("transform", AO(t));
}
function CO(e, t) {
  const n = kO(t);
  e("d", bl(null, t, n, n));
}
function oU(e, t) {
  e("class", "background"), e("aria-hidden", !0), CO(e, t);
}
function aU(e, t) {
  e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? CO(e, t) : e("d", "");
}
function sU(e, t, n) {
  const i = t.clip ? t2(n, t, t) : null;
  e("clip-path", i);
}
function uU(e, t) {
  if (!t.clip && t.items) {
    const n = t.items, i = n.length;
    for (let r = 0; r < i; ++r)
      e.union(n[r].bounds);
  }
  return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), uo(e, t), e.translate(t.x || 0, t.y || 0);
}
function tf(e, t, n, i) {
  const r = kO(t);
  e.beginPath(), bl(e, t, (n || 0) + r, (i || 0) + r);
}
const lU = jf(tf), cU = jf(tf, !1), fU = jf(tf, !0);
function dU(e, t, n) {
  Di(t, (i) => {
    const r = i.x || 0, o = i.y || 0, a = i.strokeForeground, s = i.opacity == null ? 1 : i.opacity;
    (i.stroke || i.fill) && s && (tf(e, i, r, o), Pu(e, i), i.fill && Vh(e, i, s) && e.fill(), i.stroke && !a && zu(e, i, s) && e.stroke()), e.save(), e.translate(r, o), i.clip && $O(e, i), n && n.translate(-r, -o), Di(i, (u) => {
      this.draw(e, u, n);
    }), n && n.translate(r, o), e.restore(), a && i.stroke && s && (tf(e, i, r, o), Pu(e, i), zu(e, i, s) && e.stroke());
  });
}
function hU(e, t, n, i, r, o) {
  if (t.bounds && !t.bounds.contains(r, o) || !t.items)
    return null;
  const a = n * e.pixelRatio, s = i * e.pixelRatio;
  return Kh(t, (u) => {
    let l, c, f;
    const d = u.bounds;
    if (d && !d.contains(r, o))
      return;
    c = u.x || 0, f = u.y || 0;
    const h = c + (u.width || 0), p = f + (u.height || 0), g = u.clip;
    if (g && (r < c || r > h || o < f || o > p))
      return;
    if (e.save(), e.translate(c, f), c = r - c, f = o - f, g && e2(u) && !fU(e, u, a, s))
      return e.restore(), null;
    const m = u.strokeForeground, y = t.interactive !== !1;
    return y && m && u.stroke && cU(e, u, a, s) ? (e.restore(), u) : (l = Kh(u, (v) => pU(v, c, f) ? this.pick(v, n, i, c, f) : null), !l && y && (u.fill || !m && u.stroke) && lU(e, u, a, s) && (l = u), e.restore(), l || null);
  });
}
function pU(e, t, n) {
  return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n);
}
var gU = {
  type: "group",
  tag: "g",
  nested: !1,
  attr: rU,
  bound: uU,
  draw: dU,
  pick: hU,
  isect: wO,
  content: sU,
  background: oU,
  foreground: aU
}, nf = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  version: "1.1"
};
function f2(e, t) {
  var n = e.image;
  return (!n || e.url && e.url !== n.url) && (n = {
    complete: !1,
    width: 0,
    height: 0
  }, t.loadImage(e.url).then((i) => {
    e.image = i, e.image.url = e.url;
  })), n;
}
function d2(e, t) {
  return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
}
function h2(e, t) {
  return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
}
function Jg(e, t) {
  return e === "center" ? t / 2 : e === "right" ? t : 0;
}
function Qg(e, t) {
  return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
}
function mU(e, t, n) {
  const i = f2(t, n), r = d2(t, i), o = h2(t, i), a = (t.x || 0) - Jg(t.align, r), s = (t.y || 0) - Qg(t.baseline, o), u = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
  e("href", u, nf["xmlns:xlink"], "xlink:href"), e("transform", Za(a, s)), e("width", r), e("height", o), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
}
function yU(e, t) {
  const n = t.image, i = d2(t, n), r = h2(t, n), o = (t.x || 0) - Jg(t.align, i), a = (t.y || 0) - Qg(t.baseline, r);
  return e.set(o, a, o + i, a + r);
}
function vU(e, t, n) {
  Di(t, (i) => {
    if (n && !n.intersects(i.bounds))
      return;
    const r = f2(i, this);
    let o = d2(i, r), a = h2(i, r);
    if (o === 0 || a === 0)
      return;
    let s = (i.x || 0) - Jg(i.align, o), u = (i.y || 0) - Qg(i.baseline, a), l, c, f, d;
    i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (d = o / c, u += (a - d) / 2, a = d) : (d = a * c, s += (o - d) / 2, o = d))), (r.complete || r.toDataURL) && (Pu(e, i), e.globalAlpha = (l = i.opacity) != null ? l : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, s, u, o, a));
  });
}
var bU = {
  type: "image",
  tag: "image",
  nested: !1,
  attr: mU,
  bound: yU,
  draw: vU,
  pick: Kg(),
  isect: ei,
  get: f2,
  xOffset: Jg,
  yOffset: Qg
}, xU = c2("line", Pj, eU);
function wU(e, t) {
  var n = t.scaleX || 1, i = t.scaleY || 1;
  (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", Jj(t)), e("d", t.path);
}
function ch(e, t) {
  var n = t.path;
  if (n == null)
    return !0;
  var i = t.x || 0, r = t.y || 0, o = t.scaleX || 1, a = t.scaleY || 1, s = (t.angle || 0) * Ko, u = t.pathCache;
  (!u || u.path !== n) && ((t.pathCache = u = Iu(n)).path = n), s && e.rotate && e.translate ? (e.translate(i, r), e.rotate(s), ef(e, u, 0, 0, o, a), e.rotate(-s), e.translate(-i, -r)) : ef(e, u, i, r, o, a);
}
function EU(e, t) {
  return ch(Bf(e, t.angle), t) ? e.set(0, 0, 0, 0) : uo(e, t, !0);
}
var _U = {
  type: "path",
  tag: "path",
  nested: !1,
  attr: wU,
  bound: EU,
  draw: a2(ch),
  pick: s2(ch),
  isect: i2(ch)
};
function SU(e, t) {
  e("d", bl(null, t));
}
function AU(e, t) {
  var n, i;
  return uo(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t);
}
function sA(e, t) {
  e.beginPath(), bl(e, t);
}
var $U = {
  type: "rect",
  tag: "path",
  nested: !1,
  attr: SU,
  bound: AU,
  draw: a2(sA),
  pick: s2(sA),
  isect: wO
};
function kU(e, t) {
  e("transform", AO(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
}
function CU(e, t) {
  var n, i;
  return uo(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t);
}
function FO(e, t, n) {
  var i, r, o, a;
  return t.stroke && zu(e, t, n) ? (i = t.x || 0, r = t.y || 0, o = t.x2 != null ? t.x2 : i, a = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(o, a), !0) : !1;
}
function FU(e, t, n) {
  Di(t, (i) => {
    if (!(n && !n.intersects(i.bounds))) {
      var r = i.opacity == null ? 1 : i.opacity;
      r && FO(e, i, r) && (Pu(e, i), e.stroke());
    }
  });
}
function MU(e, t, n, i) {
  return e.isPointInStroke ? FO(e, t, 1) && e.isPointInStroke(n, i) : !1;
}
var TU = {
  type: "rule",
  tag: "line",
  nested: !1,
  attr: kU,
  bound: CU,
  draw: FU,
  pick: Kg(MU),
  isect: EO
}, OU = l2("shape", zj), NU = l2("symbol", Bj, r2);
const uA = IF();
var Ci = {
  height: Sr,
  measureWidth: p2,
  estimateWidth: $y,
  width: $y,
  canvas: MO
};
MO(!0);
function MO(e) {
  Ci.width = e && qo ? p2 : $y;
}
function $y(e, t) {
  return TO(Qo(e, t), Sr(e));
}
function TO(e, t) {
  return ~~(0.8 * e.length * t);
}
function p2(e, t) {
  return Sr(e) <= 0 || !(t = Qo(e, t)) ? 0 : OO(t, Zg(e));
}
function OO(e, t) {
  const n = `(${t}) ${e}`;
  let i = uA.get(n);
  return i === void 0 && (qo.font = t, i = qo.measureText(e).width, uA.set(n, i)), i;
}
function Sr(e) {
  return e.fontSize != null ? +e.fontSize || 0 : 11;
}
function Jo(e) {
  return e.lineHeight != null ? e.lineHeight : Sr(e) + 2;
}
function DU(e) {
  return P(e) ? e.length > 1 ? e : e[0] : e;
}
function Uf(e) {
  return DU(e.lineBreak && e.text && !P(e.text) ? e.text.split(e.lineBreak) : e.text);
}
function g2(e) {
  const t = Uf(e);
  return (P(t) ? t.length - 1 : 0) * Jo(e);
}
function Qo(e, t) {
  const n = t == null ? "" : (t + "").trim();
  return e.limit > 0 && n.length ? LU(e, n) : n;
}
function RU(e) {
  if (Ci.width === p2) {
    const t = Zg(e);
    return (n) => OO(n, t);
  } else {
    const t = Sr(e);
    return (n) => TO(n, t);
  }
}
function LU(e, t) {
  var n = +e.limit, i = RU(e);
  if (i(t) < n)
    return t;
  var r = e.ellipsis || "\u2026", o = e.dir === "rtl", a = 0, s = t.length, u;
  if (n -= i(r), o) {
    for (; a < s; )
      u = a + s >>> 1, i(t.slice(u)) > n ? a = u + 1 : s = u;
    return r + t.slice(a);
  } else {
    for (; a < s; )
      u = 1 + (a + s >>> 1), i(t.slice(0, u)) < n ? a = u : s = u - 1;
    return t.slice(0, a) + r;
  }
}
function qf(e, t) {
  var n = e.font;
  return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
}
function Zg(e, t) {
  return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + Sr(e) + "px " + qf(e, t);
}
function m2(e) {
  var t = e.baseline, n = Sr(e);
  return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * Jo(e) : t === "line-bottom" ? 0.29 * n - 0.5 * Jo(e) : 0);
}
const IU = {
  left: "start",
  center: "middle",
  right: "end"
}, Mc = new nt();
function em(e) {
  var t = e.x || 0, n = e.y || 0, i = e.radius || 0, r;
  return i && (r = (e.theta || 0) - Pa, t += i * Math.cos(r), n += i * Math.sin(r)), Mc.x1 = t, Mc.y1 = n, Mc;
}
function PU(e, t) {
  var n = t.dx || 0, i = (t.dy || 0) + m2(t), r = em(t), o = r.x1, a = r.y1, s = t.angle || 0, u;
  e("text-anchor", IU[t.align] || "start"), s ? (u = Za(o, a) + " " + u2(s), (n || i) && (u += " " + Za(n, i))) : u = Za(o + n, a + i), e("transform", u);
}
function y2(e, t, n) {
  var i = Ci.height(t), r = t.align, o = em(t), a = o.x1, s = o.y1, u = t.dx || 0, l = (t.dy || 0) + m2(t) - Math.round(0.8 * i), c = Uf(t), f;
  if (P(c) ? (i += Jo(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, Ci.width(t, h)), 0)) : f = Ci.width(t, c), r === "center" ? u -= f / 2 : r === "right" && (u -= f), e.set(u += a, l += s, u + f, l + i), t.angle && !n)
    e.rotate(t.angle * Ko, a, s);
  else if (n === 2)
    return e.rotatedPoints(t.angle * Ko, a, s);
  return e;
}
function zU(e, t, n) {
  Di(t, (i) => {
    var r = i.opacity == null ? 1 : i.opacity, o, a, s, u, l, c, f;
    if (!(n && !n.intersects(i.bounds) || r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
      if (e.font = Zg(i), e.textAlign = i.align || "left", o = em(i), a = o.x1, s = o.y1, i.angle && (e.save(), e.translate(a, s), e.rotate(i.angle * Ko), a = s = 0), a += i.dx || 0, s += (i.dy || 0) + m2(i), c = Uf(i), Pu(e, i), P(c))
        for (l = Jo(i), u = 0; u < c.length; ++u)
          f = Qo(i, c[u]), i.fill && Vh(e, i, r) && e.fillText(f, a, s), i.stroke && zu(e, i, r) && e.strokeText(f, a, s), s += l;
      else
        f = Qo(i, c), i.fill && Vh(e, i, r) && e.fillText(f, a, s), i.stroke && zu(e, i, r) && e.strokeText(f, a, s);
      i.angle && e.restore();
    }
  });
}
function BU(e, t, n, i, r, o) {
  if (t.fontSize <= 0)
    return !1;
  if (!t.angle)
    return !0;
  var a = em(t), s = a.x1, u = a.y1, l = y2(Mc, t, 1), c = -t.angle * Ko, f = Math.cos(c), d = Math.sin(c), h = f * r - d * o + (s - f * s + d * u), p = d * r + f * o + (u - d * s - f * u);
  return l.contains(h, p);
}
function jU(e, t) {
  const n = y2(Mc, e, 2);
  return cu(t, n[0], n[1], n[2], n[3]) || cu(t, n[0], n[1], n[4], n[5]) || cu(t, n[4], n[5], n[6], n[7]) || cu(t, n[2], n[3], n[6], n[7]);
}
var UU = {
  type: "text",
  tag: "text",
  nested: !1,
  attr: PU,
  bound: y2,
  draw: zU,
  pick: Kg(BU),
  isect: jU
}, qU = c2("trail", jj, tU), Un = {
  arc: Qj,
  area: nU,
  group: gU,
  image: bU,
  line: xU,
  path: _U,
  rect: $U,
  rule: TU,
  shape: OU,
  symbol: NU,
  text: UU,
  trail: qU
};
function ky(e, t, n) {
  var i = Un[e.mark.marktype], r = t || i.bound;
  return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new nt()), e, n);
}
var lA = {
  mark: null
};
function NO(e, t, n) {
  var i = Un[e.marktype], r = i.bound, o = e.items, a = o && o.length, s, u, l, c;
  if (i.nested)
    return a ? l = o[0] : (lA.mark = e, l = lA), c = ky(l, r, n), t = t && t.union(c) || c, t;
  if (t = t || e.bounds && e.bounds.clear() || new nt(), a)
    for (s = 0, u = o.length; s < u; ++s)
      t.union(ky(o[s], r, n));
  return e.bounds = t;
}
const WU = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  "strokeDash",
  "strokeDashOffset",
  "strokeForeground",
  "strokeOffset",
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  "cornerRadius",
  "padAngle",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  "url",
  "aspect",
  "smooth",
  "path",
  "scaleX",
  "scaleY",
  "x2",
  "y2",
  "size",
  "shape",
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
];
function DO(e, t) {
  return JSON.stringify(e, WU, t);
}
function RO(e) {
  const t = typeof e == "string" ? JSON.parse(e) : e;
  return LO(t);
}
function LO(e) {
  var t = e.marktype, n = e.items, i, r, o;
  if (n)
    for (r = 0, o = n.length; r < o; ++r)
      i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && LO(n[r]);
  return t && NO(e), e;
}
function v2(e) {
  arguments.length ? this.root = RO(e) : (this.root = IO({
    marktype: "group",
    name: "root",
    role: "frame"
  }), this.root.items = [new Xg(this.root)]);
}
v2.prototype = {
  toJSON(e) {
    return DO(this.root, e || 0);
  },
  mark(e, t, n) {
    t = t || this.root.items[0];
    const i = IO(e, t);
    return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i;
  }
};
function IO(e, t) {
  const n = {
    bounds: new nt(),
    clip: !!e.clip,
    group: t,
    interactive: e.interactive !== !1,
    items: [],
    marktype: e.marktype,
    name: e.name || void 0,
    role: e.role || void 0,
    zindex: e.zindex || 0
  };
  return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n;
}
function To(e, t, n) {
  return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null;
}
function b2(e, t) {
  t = t.toLowerCase();
  for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
    if (n[i].tagName.toLowerCase() === t)
      return n[i];
}
function gn(e, t, n, i) {
  var r = e.childNodes[t], o;
  return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (o = r || null, r = To(e.ownerDocument, n, i), e.insertBefore(r, o)), r;
}
function vi(e, t) {
  for (var n = e.childNodes, i = n.length; i > t; )
    e.removeChild(n[--i]);
  return e;
}
function PO(e) {
  return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "");
}
function tm(e, t) {
  const n = t.getBoundingClientRect();
  return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)];
}
function GU(e, t, n, i) {
  var r = e && e.mark, o, a;
  if (r && (o = Un[r.marktype]).tip) {
    for (a = tm(t, n), a[0] -= i[0], a[1] -= i[1]; e = e.mark.group; )
      a[0] -= e.x || 0, a[1] -= e.y || 0;
    e = o.tip(r.items, a);
  }
  return e;
}
function Zo(e, t) {
  this._active = null, this._handlers = {}, this._loader = e || xg(), this._tooltip = t || HU;
}
function HU(e, t, n, i) {
  e.element().setAttribute("title", i || "");
}
Zo.prototype = {
  initialize(e, t, n) {
    return this._el = e, this._obj = n || null, this.origin(t);
  },
  element() {
    return this._el;
  },
  canvas() {
    return this._el && this._el.firstChild;
  },
  origin(e) {
    return arguments.length ? (this._origin = e || [0, 0], this) : this._origin.slice();
  },
  scene(e) {
    return arguments.length ? (this._scene = e, this) : this._scene;
  },
  on() {
  },
  off() {
  },
  _handlerIndex(e, t, n) {
    for (let i = e ? e.length : 0; --i >= 0; )
      if (e[i].type === t && (!n || e[i].handler === n))
        return i;
    return -1;
  },
  handlers(e) {
    const t = this._handlers, n = [];
    if (e)
      n.push(...t[this.eventName(e)]);
    else
      for (const i in t)
        n.push(...t[i]);
    return n;
  },
  eventName(e) {
    const t = e.indexOf(".");
    return t < 0 ? e : e.slice(0, t);
  },
  handleHref(e, t, n) {
    this._loader.sanitize(n, {
      context: "href"
    }).then((i) => {
      const r = new MouseEvent(e.type, e), o = To(null, "a");
      for (const a in i)
        o.setAttribute(a, i[a]);
      o.dispatchEvent(r);
    }).catch(() => {
    });
  },
  handleTooltip(e, t, n) {
    if (t && t.tooltip != null) {
      t = GU(t, e, this.canvas(), this._origin);
      const i = n && t && t.tooltip || null;
      this._tooltip.call(this._obj, this, e, t, i);
    }
  },
  getItemBoundingClientRect(e) {
    const t = this.canvas();
    if (!t)
      return;
    const n = t.getBoundingClientRect(), i = this._origin, r = e.bounds, o = r.width(), a = r.height();
    let s = r.x1 + i[0] + n.left, u = r.y1 + i[1] + n.top;
    for (; e.mark && (e = e.mark.group); )
      s += e.x || 0, u += e.y || 0;
    return {
      x: s,
      y: u,
      width: o,
      height: a,
      left: s,
      top: u,
      right: s + o,
      bottom: u + a
    };
  }
};
function Ar(e) {
  this._el = null, this._bgcolor = null, this._loader = new n2(e);
}
Ar.prototype = {
  initialize(e, t, n, i, r) {
    return this._el = e, this.resize(t, n, i, r);
  },
  element() {
    return this._el;
  },
  canvas() {
    return this._el && this._el.firstChild;
  },
  background(e) {
    return arguments.length === 0 ? this._bgcolor : (this._bgcolor = e, this);
  },
  resize(e, t, n, i) {
    return this._width = e, this._height = t, this._origin = n || [0, 0], this._scale = i || 1, this;
  },
  dirty() {
  },
  render(e) {
    const t = this;
    return t._call = function() {
      t._render(e);
    }, t._call(), t._call = null, t;
  },
  _render() {
  },
  renderAsync(e) {
    const t = this.render(e);
    return this._ready ? this._ready.then(() => t) : Promise.resolve(t);
  },
  _load(e, t) {
    var n = this, i = n._loader[e](t);
    if (!n._ready) {
      const r = n._call;
      n._ready = n._loader.ready().then((o) => {
        o && r(), n._ready = null;
      });
    }
    return i;
  },
  sanitizeURL(e) {
    return this._load("sanitizeURL", e);
  },
  loadImage(e) {
    return this._load("loadImage", e);
  }
};
const YU = "keydown", XU = "keypress", VU = "keyup", zO = "dragenter", fh = "dragleave", BO = "dragover", Cy = "mousedown", KU = "mouseup", Jh = "mousemove", Tc = "mouseout", jO = "mouseover", Qh = "click", JU = "dblclick", QU = "wheel", UO = "mousewheel", Zh = "touchstart", ep = "touchmove", tp = "touchend", ZU = [YU, XU, VU, zO, fh, BO, Cy, KU, Jh, Tc, jO, Qh, JU, QU, UO, Zh, ep, tp], Fy = Jh, rf = Tc, My = Qh;
function Wf(e, t) {
  Zo.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {};
}
const eq = (e) => e === Zh || e === ep || e === tp ? [Zh, ep, tp] : [e];
function cA(e, t) {
  eq(t).forEach((n) => tq(e, n));
}
function tq(e, t) {
  const n = e.canvas();
  n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (i) => e[t](i) : (i) => e.fire(t, i)));
}
function fA(e, t, n) {
  return function(i) {
    const r = this._active, o = this.pickEvent(i);
    o === r ? this.fire(e, i) : ((!r || !r.exit) && this.fire(n, i), this._active = o, this.fire(t, i), this.fire(e, i));
  };
}
function dA(e) {
  return function(t) {
    this.fire(e, t), this._active = null;
  };
}
G(Wf, Zo, {
  initialize(e, t, n) {
    return this._canvas = e && b2(e, "canvas"), [Qh, Cy, Jh, Tc, fh].forEach((i) => cA(this, i)), Zo.prototype.initialize.call(this, e, t, n);
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._canvas.getContext("2d");
  },
  events: ZU,
  DOMMouseScroll(e) {
    this.fire(UO, e);
  },
  mousemove: fA(Jh, jO, Tc),
  dragover: fA(BO, zO, fh),
  mouseout: dA(Tc),
  dragleave: dA(fh),
  mousedown(e) {
    this._down = this._active, this.fire(Cy, e);
  },
  click(e) {
    this._down === this._active && (this.fire(Qh, e), this._down = null);
  },
  touchstart(e) {
    this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(Zh, e, !0);
  },
  touchmove(e) {
    this.fire(ep, e, !0);
  },
  touchend(e) {
    this.fire(tp, e, !0), this._touch = null;
  },
  fire(e, t, n) {
    const i = n ? this._touch : this._active, r = this._handlers[e];
    if (t.vegaType = e, e === My && i && i.href ? this.handleHref(t, i, i.href) : (e === Fy || e === rf) && this.handleTooltip(t, i, e !== rf), r)
      for (let o = 0, a = r.length; o < a; ++o)
        r[o].handler.call(this._obj, t, i);
  },
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    return this._handlerIndex(i[n], e, t) < 0 && (cA(this, e), (i[n] || (i[n] = [])).push({
      type: e,
      handler: t
    })), this;
  },
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && i.splice(r, 1), this;
  },
  pickEvent(e) {
    const t = tm(e, this._canvas), n = this._origin;
    return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1]);
  },
  pick(e, t, n, i, r) {
    const o = this.context();
    return Un[e.marktype].pick.call(this, o, e, t, n, i, r);
  }
});
function nq() {
  return typeof window < "u" && window.devicePixelRatio || 1;
}
var iq = nq();
function rq(e, t, n, i, r, o) {
  const a = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null, s = e.getContext("2d"), u = a ? iq : r;
  e.width = t * u, e.height = n * u;
  for (const l in o)
    s[l] = o[l];
  return a && u !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), s.pixelRatio = u, s.setTransform(u, 0, 0, u, u * i[0], u * i[1]), e;
}
function np(e) {
  Ar.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new nt(), this._tempb = new nt();
}
const hA = Ar.prototype, oq = (e, t, n) => new nt().set(0, 0, t, n).translate(-e[0], -e[1]);
function aq(e, t, n) {
  return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
}
G(np, Ar, {
  initialize(e, t, n, i, r, o) {
    return this._options = o || {}, this._canvas = this._options.externalContext ? null : Uo(1, 1, this._options.type), e && this._canvas && (vi(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), hA.initialize.call(this, e, t, n, i, r);
  },
  resize(e, t, n, i) {
    if (hA.resize.call(this, e, t, n, i), this._canvas)
      rq(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    else {
      const r = this._options.externalContext;
      r || I("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1]);
    }
    return this._redraw = !0, this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(e) {
    const t = this._tempb.clear().union(e.bounds);
    let n = e.mark.group;
    for (; n; )
      t.translate(n.x || 0, n.y || 0), n = n.mark.group;
    this._dirty.union(t);
  },
  _render(e) {
    const t = this.context(), n = this._origin, i = this._width, r = this._height, o = this._dirty, a = oq(n, i, r);
    t.save();
    const s = this._redraw || o.empty() ? (this._redraw = !1, a.expand(1)) : aq(t, a.intersect(o), n);
    return this.clear(-n[0], -n[1], i, r), this.draw(t, e, s), t.restore(), o.clear(), this;
  },
  draw(e, t, n) {
    const i = Un[t.marktype];
    t.clip && iU(e, t), i.draw.call(this, e, t, n), t.clip && e.restore();
  },
  clear(e, t, n, i) {
    const r = this._options, o = this.context();
    r.type !== "pdf" && !r.externalContext && o.clearRect(e, t, n, i), this._bgcolor != null && (o.fillStyle = this._bgcolor, o.fillRect(e, t, n, i));
  }
});
function x2(e, t) {
  Zo.call(this, e, t);
  const n = this;
  n._hrefHandler = Ty(n, (i, r) => {
    r && r.href && n.handleHref(i, r, r.href);
  }), n._tooltipHandler = Ty(n, (i, r) => {
    n.handleTooltip(i, r, i.type !== rf);
  });
}
const Ty = (e, t) => (n) => {
  let i = n.target.__data__;
  i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i);
};
G(x2, Zo, {
  initialize(e, t, n) {
    let i = this._svg;
    return i && (i.removeEventListener(My, this._hrefHandler), i.removeEventListener(Fy, this._tooltipHandler), i.removeEventListener(rf, this._tooltipHandler)), this._svg = i = e && b2(e, "svg"), i && (i.addEventListener(My, this._hrefHandler), i.addEventListener(Fy, this._tooltipHandler), i.addEventListener(rf, this._tooltipHandler)), Zo.prototype.initialize.call(this, e, t, n);
  },
  canvas() {
    return this._svg;
  },
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    if (this._handlerIndex(i[n], e, t) < 0) {
      const o = {
        type: e,
        handler: t,
        listener: Ty(this, t)
      };
      (i[n] || (i[n] = [])).push(o), this._svg && this._svg.addEventListener(n, o.listener);
    }
    return this;
  },
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this;
  }
});
const qO = "aria-hidden", w2 = "aria-label", E2 = "role", _2 = "aria-roledescription", WO = "graphics-object", S2 = "graphics-symbol", GO = (e, t, n) => ({
  [E2]: e,
  [_2]: t,
  [w2]: n || void 0
}), sq = Oi(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]), pA = {
  axis: {
    desc: "axis",
    caption: cq
  },
  legend: {
    desc: "legend",
    caption: fq
  },
  "title-text": {
    desc: "title",
    caption: (e) => `Title text '${mA(e)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (e) => `Subtitle text '${mA(e)}'`
  }
}, gA = {
  ariaRole: E2,
  ariaRoleDescription: _2,
  description: w2
};
function HO(e, t) {
  const n = t.aria === !1;
  if (e(qO, n || void 0), n || t.description == null)
    for (const i in gA)
      e(gA[i], void 0);
  else {
    const i = t.mark.marktype;
    e(w2, t.description), e(E2, t.ariaRole || (i === "group" ? WO : S2)), e(_2, t.ariaRoleDescription || `${i} mark`);
  }
}
function YO(e) {
  return e.aria === !1 ? {
    [qO]: !0
  } : sq[e.role] ? null : pA[e.role] ? lq(e, pA[e.role]) : uq(e);
}
function uq(e) {
  const t = e.marktype, n = t === "group" || t === "text" || e.items.some((i) => i.description != null && i.aria !== !1);
  return GO(n ? WO : S2, `${t} mark container`, e.description);
}
function lq(e, t) {
  try {
    const n = e.items[0], i = t.caption || (() => "");
    return GO(t.role || S2, t.desc, n.description || i(n));
  } catch {
    return null;
  }
}
function mA(e) {
  return X(e.text).join(" ");
}
function cq(e) {
  const t = e.datum, n = e.orient, i = t.title ? XO(e) : null, r = e.context, o = r.scales[t.scale].value, a = r.dataflow.locale(), s = o.type;
  return `${n === "left" || n === "right" ? "Y" : "X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${Lu(s) ? "discrete" : s} scale with ${fO(a, o, e)}`;
}
function fq(e) {
  const t = e.datum, n = t.title ? XO(e) : null, i = `${t.type || ""} legend`.trim(), r = t.scales, o = Object.keys(r), a = e.context, s = a.scales[r[o[0]]].value, u = a.dataflow.locale();
  return hq(i) + (n ? ` titled '${n}'` : "") + ` for ${dq(o)} with ${fO(u, s, e)}`;
}
function XO(e) {
  try {
    return X(xe(e.items).items[0].text).join(" ");
  } catch {
    return null;
  }
}
function dq(e) {
  return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + xe(e);
}
function hq(e) {
  return e.length ? e[0].toUpperCase() + e.slice(1) : e;
}
const VO = (e) => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), pq = (e) => VO(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function A2() {
  let e = "", t = "", n = "";
  const i = [], r = () => t = n = "", o = (u) => {
    t && (e += `${t}>${n}`, r()), i.push(u);
  }, a = (u, l) => (l != null && (t += ` ${u}="${pq(l)}"`), s), s = {
    open(u) {
      o(u), t = "<" + u;
      for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)
        c[f - 1] = arguments[f];
      for (const d of c)
        for (const h in d)
          a(h, d[h]);
      return s;
    },
    close() {
      const u = i.pop();
      return t ? e += t + (n ? `>${n}</${u}>` : "/>") : e += `</${u}>`, r(), s;
    },
    attr: a,
    text: (u) => (n += VO(u), s),
    toString: () => e
  };
  return s;
}
const KO = (e) => JO(A2(), e) + "";
function JO(e, t) {
  if (e.open(t.tagName), t.hasAttributes()) {
    const n = t.attributes, i = n.length;
    for (let r = 0; r < i; ++r)
      e.attr(n[r].name, n[r].value);
  }
  if (t.hasChildNodes()) {
    const n = t.childNodes;
    for (const i of n)
      i.nodeType === 3 ? e.text(i.nodeValue) : JO(e, i);
  }
  return e.close();
}
const ip = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
}, rp = {
  blend: "mix-blend-mode"
}, QO = {
  fill: "none",
  "stroke-miterlimit": 10
}, Gl = 0, yA = "http://www.w3.org/2000/xmlns/", ot = nf.xmlns;
function $2(e) {
  Ar.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
}
const U0 = Ar.prototype;
G($2, Ar, {
  initialize(e, t, n, i, r) {
    return this._defs = {}, this._clearDefs(), e && (this._svg = gn(e, 0, "svg", ot), this._svg.setAttributeNS(yA, "xmlns", ot), this._svg.setAttributeNS(yA, "xmlns:xlink", nf["xmlns:xlink"]), this._svg.setAttribute("version", nf.version), this._svg.setAttribute("class", "marks"), vi(e, 1), this._root = gn(this._svg, Gl, "g", ot), Oo(this._root, QO), vi(this._svg, Gl + 1)), this.background(this._bgcolor), U0.initialize.call(this, e, t, n, i, r);
  },
  background(e) {
    return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), U0.background.apply(this, arguments);
  },
  resize(e, t, n, i) {
    return U0.resize.call(this, e, t, n, i), this._svg && (Oo(this._svg, {
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
  },
  canvas() {
    return this._svg;
  },
  svg() {
    const e = this._svg, t = this._bgcolor;
    if (!e)
      return null;
    let n;
    t && (e.removeAttribute("style"), n = gn(e, Gl, "rect", ot), Oo(n, {
      width: this._width,
      height: this._height,
      fill: t
    }));
    const i = KO(e);
    return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i;
  },
  _render(e) {
    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e), vi(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
  },
  dirty(e) {
    e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e));
  },
  isDirty(e) {
    return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID;
  },
  _dirtyCheck() {
    this._dirtyAll = !0;
    const e = this._dirty;
    if (!e.length || !this._dirtyID)
      return !0;
    const t = ++this._dirtyID;
    let n, i, r, o, a, s, u;
    for (a = 0, s = e.length; a < s; ++a)
      if (n = e[a], i = n.mark, i.marktype !== r && (r = i.marktype, o = Un[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, vA(n, t), i.items.forEach((l) => {
        l.dirty = t;
      })), !i.zdirty) {
        if (n.exit) {
          o.nested && i.items.length ? (u = i.items[0], u._svg && this._update(o, u._svg, u)) : n._svg && (u = n._svg.parentNode, u && u.removeChild(n._svg)), n._svg = null;
          continue;
        }
        n = o.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, vA(n, t)) : this._update(o, n._svg, n), n._update = t);
      }
    return !this._dirtyAll;
  },
  mark(e, t, n) {
    if (!this.isDirty(t))
      return t._svg;
    const i = this._svg, r = Un[t.marktype], o = t.interactive === !1 ? "none" : null, a = r.tag === "g", s = bA(t, e, n, "g", i);
    s.setAttribute("class", PO(t));
    const u = YO(t);
    for (const d in u)
      Vt(s, d, u[d]);
    a || Vt(s, "pointer-events", o), Vt(s, "clip-path", t.clip ? t2(this, t, t.group) : null);
    let l = null, c = 0;
    const f = (d) => {
      const h = this.isDirty(d), p = bA(d, s, l, r.tag, i);
      h && (this._update(r, p, d), a && yq(this, p, d)), l = p, ++c;
    };
    return r.nested ? t.items.length && f(t.items[0]) : Di(t, f), vi(s, c), s;
  },
  _update(e, t, n) {
    Xr = t, Rt = t.__values__, HO(Oc, n), e.attr(Oc, n, this);
    const i = bq[e.type];
    i && i.call(this, e, t, n), Xr && this.style(Xr, n);
  },
  style(e, t) {
    if (t != null) {
      for (const n in ip) {
        let i = n === "font" ? qf(t) : t[n];
        if (i === Rt[n])
          continue;
        const r = ip[n];
        i == null ? e.removeAttribute(r) : (Qx(i) && (i = hO(i, this._defs.gradient, ZO())), e.setAttribute(r, i + "")), Rt[n] = i;
      }
      for (const n in rp)
        dh(e, rp[n], t[n]);
    }
  },
  defs() {
    const e = this._svg, t = this._defs;
    let n = t.el, i = 0;
    for (const r in t.gradient)
      n || (t.el = n = gn(e, Gl + 1, "defs", ot)), i = gq(n, t.gradient[r], i);
    for (const r in t.clipping)
      n || (t.el = n = gn(e, Gl + 1, "defs", ot)), i = mq(n, t.clipping[r], i);
    n && (i === 0 ? (e.removeChild(n), t.el = null) : vi(n, i));
  },
  _clearDefs() {
    const e = this._defs;
    e.gradient = {}, e.clipping = {};
  }
});
function vA(e, t) {
  for (; e && e.dirty !== t; e = e.mark.group)
    if (e.dirty = t, e.mark && e.mark.dirty !== t)
      e.mark.dirty = t;
    else
      return;
}
function gq(e, t, n) {
  let i, r, o;
  if (t.gradient === "radial") {
    let a = gn(e, n++, "pattern", ot);
    Oo(a, {
      id: Xh + t.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    }), a = gn(a, 0, "rect", ot), Oo(a, {
      width: 1,
      height: 1,
      fill: `url(${ZO()}#${t.id})`
    }), e = gn(e, n++, "radialGradient", ot), Oo(e, {
      id: t.id,
      fx: t.x1,
      fy: t.y1,
      fr: t.r1,
      cx: t.x2,
      cy: t.y2,
      r: t.r2
    });
  } else
    e = gn(e, n++, "linearGradient", ot), Oo(e, {
      id: t.id,
      x1: t.x1,
      x2: t.x2,
      y1: t.y1,
      y2: t.y2
    });
  for (i = 0, r = t.stops.length; i < r; ++i)
    o = gn(e, i, "stop", ot), o.setAttribute("offset", t.stops[i].offset), o.setAttribute("stop-color", t.stops[i].color);
  return vi(e, i), n;
}
function mq(e, t, n) {
  let i;
  return e = gn(e, n, "clipPath", ot), e.setAttribute("id", t.id), t.path ? (i = gn(e, 0, "path", ot), i.setAttribute("d", t.path)) : (i = gn(e, 0, "rect", ot), Oo(i, {
    x: 0,
    y: 0,
    width: t.width,
    height: t.height
  })), vi(e, 1), n + 1;
}
function yq(e, t, n) {
  t = t.lastChild.previousSibling;
  let i, r = 0;
  Di(n, (o) => {
    i = e.mark(t, o, i), ++r;
  }), vi(t, 1 + r);
}
function bA(e, t, n, i, r) {
  let o = e._svg, a;
  if (!o && (a = t.ownerDocument, o = To(a, i, ot), e._svg = o, e.mark && (o.__data__ = e, o.__values__ = {
    fill: "default"
  }, i === "g"))) {
    const s = To(a, "path", ot);
    o.appendChild(s), s.__data__ = e;
    const u = To(a, "g", ot);
    o.appendChild(u), u.__data__ = e;
    const l = To(a, "path", ot);
    o.appendChild(l), l.__data__ = e, l.__values__ = {
      fill: "default"
    };
  }
  return (o.ownerSVGElement !== r || vq(o, n)) && t.insertBefore(o, n ? n.nextSibling : t.firstChild), o;
}
function vq(e, t) {
  return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
}
let Xr = null, Rt = null;
const bq = {
  group(e, t, n) {
    const i = Xr = t.childNodes[2];
    Rt = i.__values__, e.foreground(Oc, n, this), Rt = t.__values__, Xr = t.childNodes[1], e.content(Oc, n, this);
    const r = Xr = t.childNodes[0];
    e.background(Oc, n, this);
    const o = n.mark.interactive === !1 ? "none" : null;
    if (o !== Rt.events && (Vt(i, "pointer-events", o), Vt(r, "pointer-events", o), Rt.events = o), n.strokeForeground && n.stroke) {
      const a = n.fill;
      Vt(i, "display", null), this.style(r, n), Vt(r, "stroke", null), a && (n.fill = null), Rt = i.__values__, this.style(i, n), a && (n.fill = a), Xr = null;
    } else
      Vt(i, "display", "none");
  },
  image(e, t, n) {
    n.smooth === !1 ? (dh(t, "image-rendering", "optimizeSpeed"), dh(t, "image-rendering", "pixelated")) : dh(t, "image-rendering", null);
  },
  text(e, t, n) {
    const i = Uf(n);
    let r, o, a, s;
    P(i) ? (o = i.map((u) => Qo(n, u)), r = o.join(`
`), r !== Rt.text && (vi(t, 0), a = t.ownerDocument, s = Jo(n), o.forEach((u, l) => {
      const c = To(a, "tspan", ot);
      c.__data__ = n, c.textContent = u, l && (c.setAttribute("x", 0), c.setAttribute("dy", s)), t.appendChild(c);
    }), Rt.text = r)) : (o = Qo(n, i), o !== Rt.text && (t.textContent = o, Rt.text = o)), Vt(t, "font-family", qf(n)), Vt(t, "font-size", Sr(n) + "px"), Vt(t, "font-style", n.fontStyle), Vt(t, "font-variant", n.fontVariant), Vt(t, "font-weight", n.fontWeight);
  }
};
function Oc(e, t, n) {
  t !== Rt[e] && (n ? xq(Xr, e, t, n) : Vt(Xr, e, t), Rt[e] = t);
}
function dh(e, t, n) {
  n !== Rt[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), Rt[t] = n);
}
function Oo(e, t) {
  for (const n in t)
    Vt(e, n, t[n]);
}
function Vt(e, t, n) {
  n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
}
function xq(e, t, n, i) {
  n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t);
}
function ZO() {
  let e;
  return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href;
}
function k2(e) {
  Ar.call(this, e), this._text = null, this._defs = {
    gradient: {},
    clipping: {}
  };
}
G(k2, Ar, {
  svg() {
    return this._text;
  },
  _render(e) {
    const t = A2();
    t.open("svg", ce({}, nf, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const n = this._bgcolor;
    return n && n !== "transparent" && n !== "none" && t.open("rect", {
      width: this._width,
      height: this._height,
      fill: n
    }).close(), t.open("g", QO, {
      transform: "translate(" + this._origin + ")"
    }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this;
  },
  mark(e, t) {
    const n = Un[t.marktype], i = n.tag, r = [HO, n.attr];
    e.open("g", {
      class: PO(t),
      "clip-path": t.clip ? t2(this, t, t.group) : null
    }, YO(t), {
      "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
    });
    const o = (a) => {
      const s = this.href(a);
      if (s && e.open("a", s), e.open(i, this.attr(t, a, r, i !== "g" ? i : null)), i === "text") {
        const u = Uf(a);
        if (P(u)) {
          const l = {
            x: 0,
            dy: Jo(a)
          };
          for (let c = 0; c < u.length; ++c)
            e.open("tspan", c ? l : null).text(Qo(a, u[c])).close();
        } else
          e.text(Qo(a, u));
      } else if (i === "g") {
        const u = a.strokeForeground, l = a.fill, c = a.stroke;
        u && c && (a.stroke = null), e.open("path", this.attr(t, a, n.background, "bgrect")).close(), e.open("g", this.attr(t, a, n.content)), Di(a, (f) => this.mark(e, f)), e.close(), u && c ? (l && (a.fill = null), a.stroke = c, e.open("path", this.attr(t, a, n.foreground, "bgrect")).close(), l && (a.fill = l)) : e.open("path", this.attr(t, a, n.foreground, "bgfore")).close();
      }
      e.close(), s && e.close();
    };
    return n.nested ? t.items && t.items.length && o(t.items[0]) : Di(t, o), e.close();
  },
  href(e) {
    const t = e.href;
    let n;
    if (t) {
      if (n = this._hrefs && this._hrefs[t])
        return n;
      this.sanitizeURL(t).then((i) => {
        i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i;
      });
    }
    return null;
  },
  attr(e, t, n, i) {
    const r = {}, o = (a, s, u, l) => {
      r[l || a] = s;
    };
    return Array.isArray(n) ? n.forEach((a) => a(o, t, this)) : n(o, t, this), i && wq(r, t, e, i, this._defs), r;
  },
  defs(e) {
    const t = this._defs.gradient, n = this._defs.clipping;
    if (Object.keys(t).length + Object.keys(n).length !== 0) {
      e.open("defs");
      for (const r in t) {
        const o = t[r], a = o.stops;
        o.gradient === "radial" ? (e.open("pattern", {
          id: Xh + r,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        }), e.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + r + ")"
        }).close(), e.close(), e.open("radialGradient", {
          id: r,
          fx: o.x1,
          fy: o.y1,
          fr: o.r1,
          cx: o.x2,
          cy: o.y2,
          r: o.r2
        })) : e.open("linearGradient", {
          id: r,
          x1: o.x1,
          x2: o.x2,
          y1: o.y1,
          y2: o.y2
        });
        for (let s = 0; s < a.length; ++s)
          e.open("stop", {
            offset: a[s].offset,
            "stop-color": a[s].color
          }).close();
        e.close();
      }
      for (const r in n) {
        const o = n[r];
        e.open("clipPath", {
          id: r
        }), o.path ? e.open("path", {
          d: o.path
        }).close() : e.open("rect", {
          x: 0,
          y: 0,
          width: o.width,
          height: o.height
        }).close(), e.close();
      }
      e.close();
    }
  }
});
function wq(e, t, n, i, r) {
  let o;
  if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
    return e;
  i === "image" && t.smooth === !1 && (o = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = qf(t), e["font-size"] = Sr(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
  for (const a in ip) {
    let s = t[a];
    const u = ip[a];
    s === "transparent" && (u === "fill" || u === "stroke") || s != null && (Qx(s) && (s = hO(s, r.gradient, "")), e[u] = s);
  }
  for (const a in rp) {
    const s = t[a];
    s != null && (o = o || [], o.push(`${rp[a]}: ${s};`));
  }
  return o && (e.style = o.join(" ")), e;
}
const eN = "canvas", tN = "png", nN = "svg", iN = "none", No = {
  Canvas: eN,
  PNG: tN,
  SVG: nN,
  None: iN
}, Bu = {};
Bu[eN] = Bu[tN] = {
  renderer: np,
  headless: np,
  handler: Wf
};
Bu[nN] = {
  renderer: $2,
  headless: k2,
  handler: x2
};
Bu[iN] = {};
function nm(e, t) {
  return e = String(e || "").toLowerCase(), arguments.length > 1 ? (Bu[e] = t, this) : Bu[e];
}
function rN(e, t, n) {
  const i = [], r = new nt().union(t), o = e.marktype;
  return o ? oN(e, r, n, i) : o === "group" ? aN(e, r, n, i) : I("Intersect scene must be mark node or group item.");
}
function oN(e, t, n, i) {
  if (Eq(e, t, n)) {
    const r = e.items, o = e.marktype, a = r.length;
    let s = 0;
    if (o === "group")
      for (; s < a; ++s)
        aN(r[s], t, n, i);
    else
      for (const u = Un[o].isect; s < a; ++s) {
        const l = r[s];
        sN(l, t, u) && i.push(l);
      }
  }
  return i;
}
function Eq(e, t, n) {
  return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)));
}
function aN(e, t, n, i) {
  n && n(e.mark) && sN(e, t, Un.group.isect) && i.push(e);
  const r = e.items, o = r && r.length;
  if (o) {
    const a = e.x || 0, s = e.y || 0;
    t.translate(-a, -s);
    for (let u = 0; u < o; ++u)
      oN(r[u], t, n, i);
    t.translate(a, s);
  }
  return i;
}
function sN(e, t, n) {
  const i = e.bounds;
  return t.encloses(i) || t.intersects(i) && n(e, t);
}
const q0 = new nt();
function uN(e) {
  const t = e.clip;
  if (fe(t))
    t(Bf(q0.clear()));
  else if (t)
    q0.set(0, 0, e.group.width, e.group.height);
  else
    return;
  e.bounds.intersect(q0);
}
const _q = 1e-9;
function C2(e, t, n) {
  return e === t ? !0 : n === "path" ? lN(e, t) : e instanceof Date && t instanceof Date ? +e == +t : Oe(e) && Oe(t) ? Math.abs(e - t) <= _q : !e || !t || !K(e) && !K(t) ? e == t : Sq(e, t);
}
function lN(e, t) {
  return C2(Iu(e), Iu(t));
}
function Sq(e, t) {
  var n = Object.keys(e), i = Object.keys(t), r, o;
  if (n.length !== i.length)
    return !1;
  for (n.sort(), i.sort(), o = n.length - 1; o >= 0; o--)
    if (n[o] != i[o])
      return !1;
  for (o = n.length - 1; o >= 0; o--)
    if (r = n[o], !C2(e[r], t[r], r))
      return !1;
  return typeof e == typeof t;
}
function Aq() {
  xO(), KB();
}
const ju = "top", bi = "left", _i = "right", ea = "bottom", $q = "top-left", kq = "top-right", Cq = "bottom-left", Fq = "bottom-right", F2 = "start", Oy = "middle", Kt = "end", Mq = "x", Tq = "y", im = "group", M2 = "axis", T2 = "title", Oq = "frame", Nq = "scope", O2 = "legend", cN = "row-header", fN = "row-footer", dN = "row-title", hN = "column-header", pN = "column-footer", gN = "column-title", Dq = "padding", Rq = "symbol", mN = "fit", yN = "fit-x", vN = "fit-y", Lq = "pad", N2 = "none", Sd = "all", Ny = "each", D2 = "flush", Do = "column", Ro = "row";
function bN(e) {
  D.call(this, null, e);
}
G(bN, D, {
  transform(e, t) {
    const n = t.dataflow, i = e.mark, r = i.marktype, o = Un[r], a = o.bound;
    let s = i.bounds, u;
    if (o.nested)
      i.items.length && n.dirty(i.items[0]), s = Ad(i, a), i.items.forEach((l) => {
        l.bounds.clear().union(s);
      });
    else if (r === im || e.modified())
      switch (t.visit(t.MOD, (l) => n.dirty(l)), s.clear(), i.items.forEach((l) => s.union(Ad(l, a))), i.role) {
        case M2:
        case O2:
        case T2:
          t.reflow();
      }
    else
      u = t.changed(t.REM), t.visit(t.ADD, (l) => {
        s.union(Ad(l, a));
      }), t.visit(t.MOD, (l) => {
        u = u || s.alignsWith(l.bounds), n.dirty(l), s.union(Ad(l, a));
      }), u && (s.clear(), i.items.forEach((l) => s.union(l.bounds)));
    return uN(i), t.modifies("bounds");
  }
});
function Ad(e, t, n) {
  return t(e.bounds.clear(), e, n);
}
const xA = ":vega_identifier:";
function R2(e) {
  D.call(this, 0, e);
}
R2.Definition = {
  type: "Identifier",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "as",
    type: "string",
    required: !0
  }]
};
G(R2, D, {
  transform(e, t) {
    const n = Iq(t.dataflow), i = e.as;
    let r = n.value;
    return t.visit(t.ADD, (o) => o[i] = o[i] || ++r), n.set(this.value = r), t;
  }
});
function Iq(e) {
  return e._signals[xA] || (e._signals[xA] = e.add(0));
}
function xN(e) {
  D.call(this, null, e);
}
G(xN, D, {
  transform(e, t) {
    let n = this.value;
    n || (n = t.dataflow.scenegraph().mark(e.markdef, Pq(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
    const i = n.marktype === im ? Xg : Yg;
    return t.visit(t.ADD, (r) => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t;
  }
});
function Pq(e) {
  const t = e.groups, n = e.parent;
  return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null;
}
function wN(e) {
  D.call(this, null, e);
}
const wA = {
  parity: (e) => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
  greedy: (e, t) => {
    let n;
    return e.filter((i, r) => !r || !EN(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0);
  }
}, EN = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2), EA = (e, t) => {
  for (var n = 1, i = e.length, r = e[0].bounds, o; n < i; r = o, ++n)
    if (EN(r, o = e[n].bounds, t))
      return !0;
}, zq = (e) => {
  const t = e.bounds;
  return t.width() > 1 && t.height() > 1;
}, Bq = (e, t, n) => {
  var i = e.range(), r = new nt();
  return t === ju || t === ea ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), (o) => r.encloses(o.bounds);
}, _A = (e) => (e.forEach((t) => t.opacity = 1), e), SA = (e, t) => e.reflow(t.modified()).modifies("opacity");
G(wN, D, {
  transform(e, t) {
    const n = wA[e.method] || wA.parity, i = e.separation || 0;
    let r = t.materialize(t.SOURCE).source, o, a;
    if (!r || !r.length)
      return;
    if (!e.method)
      return e.modified("method") && (_A(r), t = SA(t, e)), t;
    if (r = r.filter(zq), !r.length)
      return;
    if (e.sort && (r = r.slice().sort(e.sort)), o = _A(r), t = SA(t, e), o.length >= 3 && EA(o, i)) {
      do
        o = n(o, i);
      while (o.length >= 3 && EA(o, i));
      o.length < 3 && !xe(r).opacity && (o.length > 1 && (xe(o).opacity = 0), xe(r).opacity = 1);
    }
    e.boundScale && e.boundTolerance >= 0 && (a = Bq(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach((u) => {
      a(u) || (u.opacity = 0);
    }));
    const s = o[0].mark.bounds.clear();
    return r.forEach((u) => {
      u.opacity && s.union(u.bounds);
    }), t;
  }
});
function _N(e) {
  D.call(this, null, e);
}
G(_N, D, {
  transform(e, t) {
    const n = t.dataflow;
    if (t.visit(t.ALL, (i) => n.dirty(i)), t.fields && t.fields.zindex) {
      const i = t.source && t.source[0];
      i && (i.mark.zdirty = !0);
    }
  }
});
const Dt = new nt();
function fu(e, t, n) {
  return e[t] === n ? 0 : (e[t] = n, 1);
}
function jq(e) {
  var t = e.items[0].orient;
  return t === bi || t === _i;
}
function Uq(e) {
  let t = +e.grid;
  return [
    e.ticks ? t++ : -1,
    e.labels ? t++ : -1,
    t + +e.domain
  ];
}
function qq(e, t, n, i) {
  var r = t.items[0], o = r.datum, a = r.translate != null ? r.translate : 0.5, s = r.orient, u = Uq(o), l = r.range, c = r.offset, f = r.position, d = r.minExtent, h = r.maxExtent, p = o.title && r.items[u[2]].items[0], g = r.titlePadding, m = r.bounds, y = p && g2(p), v = 0, b = 0, x, E;
  switch (Dt.clear().union(m), m.clear(), (x = u[0]) > -1 && m.union(r.items[x].bounds), (x = u[1]) > -1 && m.union(r.items[x].bounds), s) {
    case ju:
      v = f || 0, b = -c, E = Math.max(d, Math.min(h, -m.y1)), m.add(0, -E).add(l, 0), p && $d(e, p, E, g, y, 0, -1, m);
      break;
    case bi:
      v = -c, b = f || 0, E = Math.max(d, Math.min(h, -m.x1)), m.add(-E, 0).add(0, l), p && $d(e, p, E, g, y, 1, -1, m);
      break;
    case _i:
      v = n + c, b = f || 0, E = Math.max(d, Math.min(h, m.x2)), m.add(0, 0).add(E, l), p && $d(e, p, E, g, y, 1, 1, m);
      break;
    case ea:
      v = f || 0, b = i + c, E = Math.max(d, Math.min(h, m.y2)), m.add(0, 0).add(l, E), p && $d(e, p, E, g, 0, 0, 1, m);
      break;
    default:
      v = r.x, b = r.y;
  }
  return uo(m.translate(v, b), r), fu(r, "x", v + a) | fu(r, "y", b + a) && (r.bounds = Dt, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m);
}
function $d(e, t, n, i, r, o, a, s) {
  const u = t.bounds;
  if (t.auto) {
    const l = a * (n + r + i);
    let c = 0, f = 0;
    e.dirty(t), o ? c = (t.x || 0) - (t.x = l) : f = (t.y || 0) - (t.y = l), t.mark.bounds.clear().union(u.translate(-c, -f)), e.dirty(t);
  }
  s.union(u);
}
const AA = (e, t) => Math.floor(Math.min(e, t)), $A = (e, t) => Math.ceil(Math.max(e, t));
function Wq(e) {
  var t = e.items, n = t.length, i = 0, r, o;
  const a = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i)
    if (r = t[i], o = r.items, r.marktype === im)
      switch (r.role) {
        case M2:
        case O2:
        case T2:
          break;
        case cN:
          a.rowheaders.push(...o);
          break;
        case fN:
          a.rowfooters.push(...o);
          break;
        case hN:
          a.colheaders.push(...o);
          break;
        case pN:
          a.colfooters.push(...o);
          break;
        case dN:
          a.rowtitle = o[0];
          break;
        case gN:
          a.coltitle = o[0];
          break;
        default:
          a.marks.push(...o);
      }
  return a;
}
function Gq(e) {
  return new nt().set(0, 0, e.width || 0, e.height || 0);
}
function Hq(e) {
  const t = e.bounds.clone();
  return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0));
}
function qe(e, t, n) {
  const i = K(e) ? e[t] : e;
  return i != null ? i : n !== void 0 ? n : 0;
}
function kA(e) {
  return e < 0 ? Math.ceil(-e) : 0;
}
function SN(e, t, n) {
  var i = !n.nodirty, r = n.bounds === D2 ? Gq : Hq, o = Dt.set(0, 0, 0, 0), a = qe(n.align, Do), s = qe(n.align, Ro), u = qe(n.padding, Do), l = qe(n.padding, Ro), c = n.columns || t.length, f = c <= 0 ? 1 : Math.ceil(t.length / c), d = t.length, h = Array(d), p = Array(c), g = 0, m = Array(d), y = Array(f), v = 0, b = Array(d), x = Array(d), E = Array(d), _, w, S, C, $, A, M, F, O, k, T;
  for (w = 0; w < c; ++w)
    p[w] = 0;
  for (w = 0; w < f; ++w)
    y[w] = 0;
  for (w = 0; w < d; ++w)
    A = t[w], $ = E[w] = r(A), A.x = A.x || 0, b[w] = 0, A.y = A.y || 0, x[w] = 0, S = w % c, C = ~~(w / c), g = Math.max(g, M = Math.ceil($.x2)), v = Math.max(v, F = Math.ceil($.y2)), p[S] = Math.max(p[S], M), y[C] = Math.max(y[C], F), h[w] = u + kA($.x1), m[w] = l + kA($.y1), i && e.dirty(t[w]);
  for (w = 0; w < d; ++w)
    w % c === 0 && (h[w] = 0), w < c && (m[w] = 0);
  if (a === Ny)
    for (S = 1; S < c; ++S) {
      for (T = 0, w = S; w < d; w += c)
        T < h[w] && (T = h[w]);
      for (w = S; w < d; w += c)
        h[w] = T + p[S - 1];
    }
  else if (a === Sd) {
    for (T = 0, w = 0; w < d; ++w)
      w % c && T < h[w] && (T = h[w]);
    for (w = 0; w < d; ++w)
      w % c && (h[w] = T + g);
  } else
    for (a = !1, S = 1; S < c; ++S)
      for (w = S; w < d; w += c)
        h[w] += p[S - 1];
  if (s === Ny)
    for (C = 1; C < f; ++C) {
      for (T = 0, w = C * c, _ = w + c; w < _; ++w)
        T < m[w] && (T = m[w]);
      for (w = C * c; w < _; ++w)
        m[w] = T + y[C - 1];
    }
  else if (s === Sd) {
    for (T = 0, w = c; w < d; ++w)
      T < m[w] && (T = m[w]);
    for (w = c; w < d; ++w)
      m[w] = T + v;
  } else
    for (s = !1, C = 1; C < f; ++C)
      for (w = C * c, _ = w + c; w < _; ++w)
        m[w] += y[C - 1];
  for (O = 0, w = 0; w < d; ++w)
    O = h[w] + (w % c ? O : 0), b[w] += O - t[w].x;
  for (S = 0; S < c; ++S)
    for (k = 0, w = S; w < d; w += c)
      k += m[w], x[w] += k - t[w].y;
  if (a && qe(n.center, Do) && f > 1)
    for (w = 0; w < d; ++w)
      $ = a === Sd ? g : p[w % c], O = $ - E[w].x2 - t[w].x - b[w], O > 0 && (b[w] += O / 2);
  if (s && qe(n.center, Ro) && c !== 1)
    for (w = 0; w < d; ++w)
      $ = s === Sd ? v : y[~~(w / c)], k = $ - E[w].y2 - t[w].y - x[w], k > 0 && (x[w] += k / 2);
  for (w = 0; w < d; ++w)
    o.union(E[w].translate(b[w], x[w]));
  switch (O = qe(n.anchor, Mq), k = qe(n.anchor, Tq), qe(n.anchor, Do)) {
    case Kt:
      O -= o.width();
      break;
    case Oy:
      O -= o.width() / 2;
  }
  switch (qe(n.anchor, Ro)) {
    case Kt:
      k -= o.height();
      break;
    case Oy:
      k -= o.height() / 2;
  }
  for (O = Math.round(O), k = Math.round(k), o.clear(), w = 0; w < d; ++w)
    t[w].mark.bounds.clear();
  for (w = 0; w < d; ++w)
    A = t[w], A.x += b[w] += O, A.y += x[w] += k, o.union(A.mark.bounds.union(A.bounds.translate(b[w], x[w]))), i && e.dirty(A);
  return o;
}
function Yq(e, t, n) {
  var i = Wq(t), r = i.marks, o = n.bounds === D2 ? Xq : Vq, a = n.offset, s = n.columns || r.length, u = s <= 0 ? 1 : Math.ceil(r.length / s), l = u * s, c, f, d, h, p, g, m;
  const y = SN(e, r, n);
  y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (g = qe(n.headerBand, Ro, null), c = kd(e, i.rowheaders, r, s, u, -qe(a, "rowHeader"), AA, 0, o, "x1", 0, s, 1, g)), i.colheaders && (g = qe(n.headerBand, Do, null), f = kd(e, i.colheaders, r, s, s, -qe(a, "columnHeader"), AA, 1, o, "y1", 0, 1, s, g)), i.rowfooters && (g = qe(n.footerBand, Ro, null), d = kd(e, i.rowfooters, r, s, u, qe(a, "rowFooter"), $A, 0, o, "x2", s - 1, s, 1, g)), i.colfooters && (g = qe(n.footerBand, Do, null), h = kd(e, i.colfooters, r, s, s, qe(a, "columnFooter"), $A, 1, o, "y2", l - s, 1, s, g)), i.rowtitle && (p = qe(n.titleAnchor, Ro), m = qe(a, "rowTitle"), m = p === Kt ? d + m : c - m, g = qe(n.titleBand, Ro, 0.5), CA(e, i.rowtitle, m, 0, y, g)), i.coltitle && (p = qe(n.titleAnchor, Do), m = qe(a, "columnTitle"), m = p === Kt ? h + m : f - m, g = qe(n.titleBand, Do, 0.5), CA(e, i.coltitle, m, 1, y, g));
}
function Xq(e, t) {
  return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0;
}
function Vq(e, t) {
  return e.bounds[t];
}
function kd(e, t, n, i, r, o, a, s, u, l, c, f, d, h) {
  var p = n.length, g = 0, m = 0, y, v, b, x, E, _, w, S, C;
  if (!p)
    return g;
  for (y = c; y < p; y += f)
    n[y] && (g = a(g, u(n[y], l)));
  if (!t.length)
    return g;
  for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), g += o, v = 0, x = t.length; v < x; ++v)
    e.dirty(t[v]), t[v].mark.bounds.clear();
  for (y = c, v = 0, x = t.length; v < x; ++v, y += f) {
    for (_ = t[v], E = _.mark.bounds, b = y; b >= 0 && (w = n[b]) == null; b -= d)
      ;
    s ? (S = h == null ? w.x : Math.round(w.bounds.x1 + h * w.bounds.width()), C = g) : (S = g, C = h == null ? w.y : Math.round(w.bounds.y1 + h * w.bounds.height())), E.union(_.bounds.translate(S - (_.x || 0), C - (_.y || 0))), _.x = S, _.y = C, e.dirty(_), m = a(m, E[l]);
  }
  return m;
}
function CA(e, t, n, i, r, o) {
  if (!!t) {
    e.dirty(t);
    var a = n, s = n;
    i ? a = Math.round(r.x1 + o * r.width()) : s = Math.round(r.y1 + o * r.height()), t.bounds.translate(a - (t.x || 0), s - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = a, t.y = s, e.dirty(t);
  }
}
function Kq(e, t) {
  const n = e[t] || {};
  return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r;
}
function Jq(e, t) {
  let n = -1 / 0;
  return e.forEach((i) => {
    i.offset != null && (n = Math.max(n, i.offset));
  }), n > -1 / 0 ? n : t;
}
function Qq(e, t, n, i, r, o, a) {
  const s = Kq(n, t), u = Jq(e, s("offset", 0)), l = s("anchor", F2), c = l === Kt ? 1 : l === Oy ? 0.5 : 0, f = {
    align: Ny,
    bounds: s("bounds", D2),
    columns: s("direction") === "vertical" ? 1 : e.length,
    padding: s("margin", 8),
    center: s("center"),
    nodirty: !0
  };
  switch (t) {
    case bi:
      f.anchor = {
        x: Math.floor(i.x1) - u,
        column: Kt,
        y: c * (a || i.height() + 2 * i.y1),
        row: l
      };
      break;
    case _i:
      f.anchor = {
        x: Math.ceil(i.x2) + u,
        y: c * (a || i.height() + 2 * i.y1),
        row: l
      };
      break;
    case ju:
      f.anchor = {
        y: Math.floor(r.y1) - u,
        row: Kt,
        x: c * (o || r.width() + 2 * r.x1),
        column: l
      };
      break;
    case ea:
      f.anchor = {
        y: Math.ceil(r.y2) + u,
        x: c * (o || r.width() + 2 * r.x1),
        column: l
      };
      break;
    case $q:
      f.anchor = {
        x: u,
        y: u
      };
      break;
    case kq:
      f.anchor = {
        x: o - u,
        y: u,
        column: Kt
      };
      break;
    case Cq:
      f.anchor = {
        x: u,
        y: a - u,
        row: Kt
      };
      break;
    case Fq:
      f.anchor = {
        x: o - u,
        y: a - u,
        column: Kt,
        row: Kt
      };
      break;
  }
  return f;
}
function Zq(e, t) {
  var n = t.items[0], i = n.datum, r = n.orient, o = n.bounds, a = n.x, s = n.y, u, l;
  return n._bounds ? n._bounds.clear().union(o) : n._bounds = o.clone(), o.clear(), tW(e, n, n.items[0].items[0]), o = eW(n, o), u = 2 * n.padding, l = 2 * n.padding, o.empty() || (u = Math.ceil(o.width() + u), l = Math.ceil(o.height() + l)), i.type === Rq && nW(n.items[0].items[0].items[0].items), r !== N2 && (n.x = a = 0, n.y = s = 0), n.width = u, n.height = l, uo(o.set(a, s, a + u, s + l), n), n.mark.bounds.clear().union(o), n;
}
function eW(e, t) {
  return e.items.forEach((n) => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t;
}
function tW(e, t, n) {
  var i = t.padding, r = i - n.x, o = i - n.y;
  if (!t.datum.title)
    (r || o) && Hl(e, n, r, o);
  else {
    var a = t.items[1].items[0], s = a.anchor, u = t.titlePadding || 0, l = i - a.x, c = i - a.y;
    switch (a.orient) {
      case bi:
        r += Math.ceil(a.bounds.width()) + u;
        break;
      case _i:
      case ea:
        break;
      default:
        o += a.bounds.height() + u;
    }
    switch ((r || o) && Hl(e, n, r, o), a.orient) {
      case bi:
        c += Vs(t, n, a, s, 1, 1);
        break;
      case _i:
        l += Vs(t, n, a, Kt, 0, 0) + u, c += Vs(t, n, a, s, 1, 1);
        break;
      case ea:
        l += Vs(t, n, a, s, 0, 0), c += Vs(t, n, a, Kt, -1, 0, 1) + u;
        break;
      default:
        l += Vs(t, n, a, s, 0, 0);
    }
    (l || c) && Hl(e, a, l, c), (l = Math.round(a.bounds.x1 - i)) < 0 && (Hl(e, n, -l, 0), Hl(e, a, -l, 0));
  }
}
function Vs(e, t, n, i, r, o, a) {
  const s = e.datum.type !== "symbol", u = n.datum.vgrad, l = s && (o || !u) && !a ? t.items[0] : t, c = l.bounds[r ? "y2" : "x2"] - e.padding, f = u && o ? c : 0, d = u && o ? 0 : c, h = r <= 0 ? 0 : g2(n);
  return Math.round(i === F2 ? f : i === Kt ? d - h : 0.5 * (c - h));
}
function Hl(e, t, n, i) {
  t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t);
}
function nW(e) {
  const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
  e.forEach((n) => {
    n.width = t[n.column], n.height = n.bounds.y2 - n.y;
  });
}
function iW(e, t, n, i, r) {
  var o = t.items[0], a = o.frame, s = o.orient, u = o.anchor, l = o.offset, c = o.padding, f = o.items[0].items[0], d = o.items[1] && o.items[1].items[0], h = s === bi || s === _i ? i : n, p = 0, g = 0, m = 0, y = 0, v = 0, b;
  if (a !== im ? s === bi ? (p = r.y2, h = r.y1) : s === _i ? (p = r.y1, h = r.y2) : (p = r.x1, h = r.x2) : s === bi && (p = i, h = 0), b = u === F2 ? p : u === Kt ? h : (p + h) / 2, d && d.text) {
    switch (s) {
      case ju:
      case ea:
        v = f.bounds.height() + c;
        break;
      case bi:
        y = f.bounds.width() + c;
        break;
      case _i:
        y = -f.bounds.width() - c;
        break;
    }
    Dt.clear().union(d.bounds), Dt.translate(y - (d.x || 0), v - (d.y || 0)), fu(d, "x", y) | fu(d, "y", v) && (e.dirty(d), d.bounds.clear().union(Dt), d.mark.bounds.clear().union(Dt), e.dirty(d)), Dt.clear().union(d.bounds);
  } else
    Dt.clear();
  switch (Dt.union(f.bounds), s) {
    case ju:
      g = b, m = r.y1 - Dt.height() - l;
      break;
    case bi:
      g = r.x1 - Dt.width() - l, m = b;
      break;
    case _i:
      g = r.x2 + Dt.width() + l, m = b;
      break;
    case ea:
      g = b, m = r.y2 + l;
      break;
    default:
      g = o.x, m = o.y;
  }
  return fu(o, "x", g) | fu(o, "y", m) && (Dt.translate(g, m), e.dirty(o), o.bounds.clear().union(Dt), t.bounds.clear().union(Dt), e.dirty(o)), o.bounds;
}
function AN(e) {
  D.call(this, null, e);
}
G(AN, D, {
  transform(e, t) {
    const n = t.dataflow;
    return e.mark.items.forEach((i) => {
      e.layout && Yq(n, i, e.layout), oW(n, i, e);
    }), rW(e.mark.group) ? t.reflow() : t;
  }
});
function rW(e) {
  return e && e.mark.role !== "legend-entry";
}
function oW(e, t, n) {
  var i = t.items, r = Math.max(0, t.width || 0), o = Math.max(0, t.height || 0), a = new nt().set(0, 0, r, o), s = a.clone(), u = a.clone(), l = [], c, f, d, h, p, g;
  for (p = 0, g = i.length; p < g; ++p)
    switch (f = i[p], f.role) {
      case M2:
        h = jq(f) ? s : u, h.union(qq(e, f, r, o));
        break;
      case T2:
        c = f;
        break;
      case O2:
        l.push(Zq(e, f));
        break;
      case Oq:
      case Nq:
      case cN:
      case fN:
      case dN:
      case hN:
      case pN:
      case gN:
        s.union(f.bounds), u.union(f.bounds);
        break;
      default:
        a.union(f.bounds);
    }
  if (l.length) {
    const m = {};
    l.forEach((y) => {
      d = y.orient || _i, d !== N2 && (m[d] || (m[d] = [])).push(y);
    });
    for (const y in m) {
      const v = m[y];
      SN(e, v, Qq(v, y, n.legends, s, u, r, o));
    }
    l.forEach((y) => {
      const v = y.bounds;
      if (v.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = v, e.dirty(y)), n.autosize && (n.autosize.type === mN || n.autosize.type === yN || n.autosize.type === vN))
        switch (y.orient) {
          case bi:
          case _i:
            a.add(v.x1, 0).add(v.x2, 0);
            break;
          case ju:
          case ea:
            a.add(0, v.y1).add(0, v.y2);
        }
      else
        a.union(v);
    });
  }
  a.union(s).union(u), c && a.union(iW(e, c, r, o, a)), t.clip && a.set(0, 0, t.width || 0, t.height || 0), aW(e, t, a, n);
}
function aW(e, t, n, i) {
  const r = i.autosize || {}, o = r.type;
  if (e._autosize < 1 || !o)
    return;
  let a = e._width, s = e._height, u = Math.max(0, t.width || 0), l = Math.max(0, Math.ceil(-n.x1)), c = Math.max(0, t.height || 0), f = Math.max(0, Math.ceil(-n.y1));
  const d = Math.max(0, Math.ceil(n.x2 - u)), h = Math.max(0, Math.ceil(n.y2 - c));
  if (r.contains === Dq) {
    const p = e.padding();
    a -= p.left + p.right, s -= p.top + p.bottom;
  }
  o === N2 ? (l = 0, f = 0, u = a, c = s) : o === mN ? (u = Math.max(0, a - l - d), c = Math.max(0, s - f - h)) : o === yN ? (u = Math.max(0, a - l - d), s = c + f + h) : o === vN ? (a = u + l + d, c = Math.max(0, s - f - h)) : o === Lq && (a = u + l + d, s = c + f + h), e._resizeView(a, s, u, c, [l, f], r.resize);
}
const sW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bound: bN,
  identifier: R2,
  mark: xN,
  overlap: wN,
  render: _N,
  viewlayout: AN
}, Symbol.toStringTag, { value: "Module" }));
function $N(e) {
  D.call(this, null, e);
}
G($N, D, {
  transform(e, t) {
    if (this.value && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, o = e.scale, a = e.count == null ? e.values ? e.values.length : 10 : e.count, s = Kx(o, a, e.minstep), u = e.format || aO(n, o, s, e.formatSpecifier, e.formatType, !!e.values), l = e.values ? oO(o, e.values, s) : Jx(o, s);
    return r && (i.rem = r), r = l.map((c, f) => Ce({
      index: f / (l.length - 1 || 1),
      value: c,
      label: u(c)
    })), e.extra && r.length && r.push(Ce({
      index: -1,
      extra: {
        value: r[0].value
      },
      label: ""
    })), i.source = r, i.add = r, this.value = r, i;
  }
});
function kN(e) {
  D.call(this, null, e);
}
function uW() {
  return Ce({});
}
function lW(e) {
  const t = fl().test((n) => n.exit);
  return t.lookup = (n) => t.get(e(n)), t;
}
G(kN, D, {
  transform(e, t) {
    var n = t.dataflow, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.item || uW, o = e.key || te, a = this.value;
    return P(i.encode) && (i.encode = null), a && (e.modified("key") || t.modified(o)) && I("DataJoin does not support modified key function or fields."), a || (t = t.addAll(), this.value = a = lW(o)), t.visit(t.ADD, (s) => {
      const u = o(s);
      let l = a.get(u);
      l ? l.exit ? (a.empty--, i.add.push(l)) : i.mod.push(l) : (l = r(s), a.set(u, l), i.add.push(l)), l.datum = s, l.exit = !1;
    }), t.visit(t.MOD, (s) => {
      const u = o(s), l = a.get(u);
      l && (l.datum = s, i.mod.push(l));
    }), t.visit(t.REM, (s) => {
      const u = o(s), l = a.get(u);
      s === l.datum && !l.exit && (i.rem.push(l), l.exit = !0, ++a.empty);
    }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && a.empty > n.cleanThreshold) && n.runAfter(a.clean), i;
  }
});
function CN(e) {
  D.call(this, null, e);
}
G(CN, D, {
  transform(e, t) {
    var n = t.fork(t.ADD_REM), i = e.mod || !1, r = e.encoders, o = t.encode;
    if (P(o))
      if (n.changed() || o.every((f) => r[f]))
        o = o[0], n.encode = null;
      else
        return t.StopPropagation;
    var a = o === "enter", s = r.update || xo, u = r.enter || xo, l = r.exit || xo, c = (o && !a ? r[o] : s) || xo;
    if (t.changed(t.ADD) && (t.visit(t.ADD, (f) => {
      u(f, e), s(f, e);
    }), n.modifies(u.output), n.modifies(s.output), c !== xo && c !== s && (t.visit(t.ADD, (f) => {
      c(f, e);
    }), n.modifies(c.output))), t.changed(t.REM) && l !== xo && (t.visit(t.REM, (f) => {
      l(f, e);
    }), n.modifies(l.output)), a || c !== xo) {
      const f = t.MOD | (e.modified() ? t.REFLOW : 0);
      a ? (t.visit(f, (d) => {
        const h = u(d, e) || i;
        (c(d, e) || h) && n.mod.push(d);
      }), n.mod.length && n.modifies(u.output)) : t.visit(f, (d) => {
        (c(d, e) || i) && n.mod.push(d);
      }), n.mod.length && n.modifies(c.output);
    }
    return n.changed() ? n : t.StopPropagation;
  }
});
function FN(e) {
  D.call(this, [], e);
}
G(FN, D, {
  transform(e, t) {
    if (this.value != null && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, o = e.type || oh, a = e.scale, s = +e.limit, u = Kx(a, e.count == null ? 5 : e.count, e.minstep), l = !!e.values || o === oh, c = e.format || cO(n, a, u, o, e.formatSpecifier, e.formatType, l), f = e.values || lO(a, u), d, h, p, g, m;
    return r && (i.rem = r), o === oh ? (s && f.length > s ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, s - 1), m = !0) : r = f, fe(p = e.size) ? (!e.values && a(r[0]) === 0 && (r = r.slice(1)), g = r.reduce((y, v) => Math.max(y, p(v, e)), 0)) : p = Gt(g = p || 8), r = r.map((y, v) => Ce({
      index: v,
      label: c(y, v, r),
      value: y,
      offset: g,
      size: p(y, e)
    })), m && (m = f[r.length], r.push(Ce({
      index: r.length,
      label: `\u2026${f.length - r.length} entries`,
      value: m,
      offset: g,
      size: p(m, e)
    })))) : o === IB ? (d = a.domain(), h = nO(a, d[0], xe(d)), f.length < 3 && !e.values && d[0] !== xe(d) && (f = [d[0], xe(d)]), r = f.map((y, v) => Ce({
      index: v,
      label: c(y, v, f),
      value: y,
      perc: h(y)
    }))) : (p = f.length - 1, h = XB(a), r = f.map((y, v) => Ce({
      index: v,
      label: c(y, v, f),
      value: y,
      perc: v ? h(y) : 0,
      perc2: v === p ? 1 : h(f[v + 1])
    }))), i.source = r, i.add = r, this.value = r, i;
  }
});
const cW = (e) => e.source.x, fW = (e) => e.source.y, dW = (e) => e.target.x, hW = (e) => e.target.y;
function L2(e) {
  D.call(this, {}, e);
}
L2.Definition = {
  type: "LinkPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sourceX",
    type: "field",
    default: "source.x"
  }, {
    name: "sourceY",
    type: "field",
    default: "source.y"
  }, {
    name: "targetX",
    type: "field",
    default: "target.x"
  }, {
    name: "targetY",
    type: "field",
    default: "target.y"
  }, {
    name: "orient",
    type: "enum",
    default: "vertical",
    values: ["horizontal", "vertical", "radial"]
  }, {
    name: "shape",
    type: "enum",
    default: "line",
    values: ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    name: "require",
    type: "signal"
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
G(L2, D, {
  transform(e, t) {
    var n = e.sourceX || cW, i = e.sourceY || fW, r = e.targetX || dW, o = e.targetY || hW, a = e.as || "path", s = e.orient || "vertical", u = e.shape || "line", l = FA.get(u + "-" + s) || FA.get(u);
    return l || I("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (c) => {
      c[a] = l(n(c), i(c), r(c), o(c));
    }), t.reflow(e.modified()).modifies(a);
  }
});
const MN = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i, pW = (e, t, n, i) => MN(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), TN = (e, t, n, i) => {
  var r = n - e, o = i - t, a = Math.hypot(r, o) / 2, s = 180 * Math.atan2(o, r) / Math.PI;
  return "M" + e + "," + t + "A" + a + "," + a + " " + s + " 0 1 " + n + "," + i;
}, gW = (e, t, n, i) => TN(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), ON = (e, t, n, i) => {
  const r = n - e, o = i - t, a = 0.2 * (r + o), s = 0.2 * (o - r);
  return "M" + e + "," + t + "C" + (e + a) + "," + (t + s) + " " + (n + s) + "," + (i - a) + " " + n + "," + i;
}, mW = (e, t, n, i) => ON(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), yW = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n, vW = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i, bW = (e, t, n, i) => {
  const r = Math.cos(e), o = Math.sin(e), a = Math.cos(n), s = Math.sin(n), u = Math.abs(n - e) > Math.PI ? n <= e : n > e;
  return "M" + t * r + "," + t * o + "A" + t + "," + t + " 0 0," + (u ? 1 : 0) + " " + t * a + "," + t * s + "L" + i * a + "," + i * s;
}, xW = (e, t, n, i) => {
  const r = (e + n) / 2;
  return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i;
}, wW = (e, t, n, i) => {
  const r = (t + i) / 2;
  return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i;
}, EW = (e, t, n, i) => {
  const r = Math.cos(e), o = Math.sin(e), a = Math.cos(n), s = Math.sin(n), u = (t + i) / 2;
  return "M" + t * r + "," + t * o + "C" + u * r + "," + u * o + " " + u * a + "," + u * s + " " + i * a + "," + i * s;
}, FA = fl({
  line: MN,
  "line-radial": pW,
  arc: TN,
  "arc-radial": gW,
  curve: ON,
  "curve-radial": mW,
  "orthogonal-horizontal": yW,
  "orthogonal-vertical": vW,
  "orthogonal-radial": bW,
  "diagonal-horizontal": xW,
  "diagonal-vertical": wW,
  "diagonal-radial": EW
});
function I2(e) {
  D.call(this, null, e);
}
I2.Definition = {
  type: "Pie",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "startAngle",
    type: "number",
    default: 0
  }, {
    name: "endAngle",
    type: "number",
    default: 6.283185307179586
  }, {
    name: "sort",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["startAngle", "endAngle"]
  }]
};
G(I2, D, {
  transform(e, t) {
    var n = e.as || ["startAngle", "endAngle"], i = n[0], r = n[1], o = e.field || ul, a = e.startAngle || 0, s = e.endAngle != null ? e.endAngle : 2 * Math.PI, u = t.source, l = u.map(o), c = l.length, f = a, d = (s - a) / ZF(l), h = Pn(c), p, g, m;
    for (e.sort && h.sort((y, v) => l[y] - l[v]), p = 0; p < c; ++p)
      m = l[h[p]], g = u[h[p]], g[i] = f, g[r] = f += m * d;
    return this.value = l, t.reflow(e.modified()).modifies(n);
  }
});
const _W = 5;
function SW(e) {
  const t = e.type;
  return !e.bins && (t === Du || t === Nf || t === Df);
}
function NN(e) {
  return Yx(e) && e !== lr;
}
const AW = Oi(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function DN(e) {
  D.call(this, null, e), this.modified(!0);
}
G(DN, D, {
  transform(e, t) {
    var n = t.dataflow, i = this.value, r = $W(e);
    (!i || r !== i.type) && (this.value = i = $e(r)());
    for (r in e)
      if (!AW[r]) {
        if (r === "padding" && NN(i.type))
          continue;
        fe(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r);
      }
    return OW(i, e, TW(i, e, CW(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function $W(e) {
  var t = e.type, n = "", i;
  return t === lr ? lr + "-" + Du : (kW(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? lr + "-" : i === 3 ? vl + "-" : ""), (n + t || Du).toLowerCase());
}
function kW(e) {
  const t = e.type;
  return Yx(t) && t !== ss && t !== us && (e.scheme || e.range && e.range.length && e.range.every(Y));
}
function CW(e, t, n) {
  const i = FW(e, t.domainRaw, n);
  if (i > -1)
    return i;
  var r = t.domain, o = e.type, a = t.zero || t.zero === void 0 && SW(e), s, u;
  if (!r)
    return 0;
  if (NN(o) && t.padding && r[0] !== xe(r) && (r = MW(o, r, t.range, t.padding, t.exponent, t.constant)), (a || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (s = (r = r.slice()).length - 1 || 1, a && (r[0] > 0 && (r[0] = 0), r[s] < 0 && (r[s] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[s] = t.domainMax), t.domainMid != null)) {
    u = t.domainMid;
    const l = u > r[s] ? s + 1 : u < r[0] ? 0 : s;
    l !== s && n.warn("Scale domainMid exceeds domain min or max.", u), r.splice(l, 0, u);
  }
  return e.domain(RN(o, r, n)), o === qx && e.unknown(t.domainImplicit ? dy : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && Kx(e, t.nice) || null), r.length;
}
function FW(e, t, n) {
  return t ? (e.domain(RN(e.type, t, n)), t.length) : -1;
}
function MW(e, t, n, i, r, o) {
  var a = Math.abs(xe(n) - n[0]), s = a / (a - 2 * i), u = e === ro ? fb(t, null, s) : e === Df ? Fh(t, null, s, 0.5) : e === Nf ? Fh(t, null, s, r || 1) : e === Ug ? db(t, null, s, o || 1) : cb(t, null, s);
  return t = t.slice(), t[0] = u[0], t[t.length - 1] = u[1], t;
}
function RN(e, t, n) {
  if (J3(e)) {
    var i = Math.abs(t.reduce((r, o) => r + (o < 0 ? -1 : o > 0 ? 1 : 0), 0));
    i !== t.length && n.warn("Log scale domain includes zero: " + W(t));
  }
  return t;
}
function TW(e, t, n) {
  let i = t.bins;
  if (i && !P(i)) {
    const r = e.domain(), o = r[0], a = xe(r), s = i.step;
    let u = i.start == null ? o : i.start, l = i.stop == null ? a : i.stop;
    s || I("Scale bins parameter missing step property."), u < o && (u = s * Math.ceil(o / s)), l > a && (l = s * Math.floor(a / s)), i = Pn(u, l + s / 2, s);
  }
  return i ? e.bins = i : e.bins && delete e.bins, e.type === Wx && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n;
}
function OW(e, t, n) {
  var i = e.type, r = t.round || !1, o = t.range;
  if (t.rangeStep != null)
    o = NW(i, t, n);
  else if (t.scheme && (o = DW(i, t, n), fe(o))) {
    if (e.interpolator)
      return e.interpolator(o);
    I(`Scale type ${i} does not support interpolating color schemes.`);
  }
  if (o && Q3(i))
    return e.interpolator(Gg(Dy(o, t.reverse), t.interpolate, t.interpolateGamma));
  o && t.interpolate && e.interpolate ? e.interpolate(Xx(t.interpolate, t.interpolateGamma)) : fe(e.round) ? e.round(r) : fe(e.rangeRound) && e.interpolate(r ? Tf : fa), o && e.range(Dy(o, t.reverse));
}
function NW(e, t, n) {
  e !== G3 && e !== by && I("Only band and point scales support rangeStep.");
  var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0, r = e === by ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
  return [0, t.rangeStep * Ux(n, r, i)];
}
function DW(e, t, n) {
  var i = t.schemeExtent, r, o;
  return P(t.scheme) ? o = Gg(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), o = Vx(r), o || I(`Unrecognized scheme name: ${t.scheme}`)), n = e === Wg ? n + 1 : e === Wx ? n - 1 : e === Ru || e === qg ? +t.schemeCount || _W : n, Q3(e) ? MA(o, i, t.reverse) : fe(o) ? tO(MA(o, i), n) : e === qx ? o : o.slice(0, n);
}
function MA(e, t, n) {
  return fe(e) && (t || n) ? eO(e, Dy(t || [0, 1], n)) : e;
}
function Dy(e, t) {
  return t ? e.slice().reverse() : e;
}
function LN(e) {
  D.call(this, null, e);
}
G(LN, D, {
  transform(e, t) {
    const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
    return n && t.source.sort(Fs(e.sort)), this.modified(n), t;
  }
});
const TA = "zero", IN = "center", PN = "normalize", zN = ["y0", "y1"];
function P2(e) {
  D.call(this, null, e);
}
P2.Definition = {
  type: "Stack",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "offset",
    type: "enum",
    default: TA,
    values: [TA, IN, PN]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: zN
  }]
};
G(P2, D, {
  transform(e, t) {
    var n = e.as || zN, i = n[0], r = n[1], o = Fs(e.sort), a = e.field || ul, s = e.offset === IN ? RW : e.offset === PN ? LW : IW, u, l, c, f;
    for (u = PW(t.source, e.groupby, o, a), l = 0, c = u.length, f = u.max; l < c; ++l)
      s(u[l], f, a, i, r);
    return t.reflow(e.modified()).modifies(n);
  }
});
function RW(e, t, n, i, r) {
  for (var o = (t - e.sum) / 2, a = e.length, s = 0, u; s < a; ++s)
    u = e[s], u[i] = o, u[r] = o += Math.abs(n(u));
}
function LW(e, t, n, i, r) {
  for (var o = 1 / e.sum, a = 0, s = e.length, u = 0, l = 0, c; u < s; ++u)
    c = e[u], c[i] = a, c[r] = a = o * (l += Math.abs(n(c)));
}
function IW(e, t, n, i, r) {
  for (var o = 0, a = 0, s = e.length, u = 0, l, c; u < s; ++u)
    c = e[u], l = +n(c), l < 0 ? (c[i] = a, c[r] = a += l) : (c[i] = o, c[r] = o += l);
}
function PW(e, t, n, i) {
  var r = [], o = (g) => g(c), a, s, u, l, c, f, d, h, p;
  if (t == null)
    r.push(e.slice());
  else
    for (a = {}, s = 0, u = e.length; s < u; ++s)
      c = e[s], f = t.map(o), d = a[f], d || (a[f] = d = [], r.push(d)), d.push(c);
  for (f = 0, p = 0, l = r.length; f < l; ++f) {
    for (d = r[f], s = 0, h = 0, u = d.length; s < u; ++s)
      h += Math.abs(i(d[s]));
    d.sum = h, h > p && (p = h), n && d.sort(n);
  }
  return r.max = p, r;
}
const zW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  axisticks: $N,
  datajoin: kN,
  encode: CN,
  legendentries: FN,
  linkpath: L2,
  pie: I2,
  scale: DN,
  sortitems: LN,
  stack: P2
}, Symbol.toStringTag, { value: "Module" }));
var re = 1e-6, op = 1e-12, pe = Math.PI, Qe = pe / 2, ap = pe / 4, on = pe * 2, et = 180 / pe, he = pe / 180, be = Math.abs, xl = Math.atan, ii = Math.atan2, oe = Math.cos, Cd = Math.ceil, BN = Math.exp, Ry = Math.hypot, sp = Math.log, W0 = Math.pow, ne = Math.sin, Vn = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, an = Math.sqrt, z2 = Math.tan;
function jN(e) {
  return e > 1 ? 0 : e < -1 ? pe : Math.acos(e);
}
function An(e) {
  return e > 1 ? Qe : e < -1 ? -Qe : Math.asin(e);
}
function St() {
}
function up(e, t) {
  e && NA.hasOwnProperty(e.type) && NA[e.type](e, t);
}
var OA = {
  Feature: function(e, t) {
    up(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, i = -1, r = n.length; ++i < r; )
      up(n[i].geometry, t);
  }
}, NA = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      e = n[i], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    Ly(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      Ly(n[i], t, 0);
  },
  Polygon: function(e, t) {
    DA(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      DA(n[i], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, i = -1, r = n.length; ++i < r; )
      up(n[i], t);
  }
};
function Ly(e, t, n) {
  var i = -1, r = e.length - n, o;
  for (t.lineStart(); ++i < r; )
    o = e[i], t.point(o[0], o[1], o[2]);
  t.lineEnd();
}
function DA(e, t) {
  var n = -1, i = e.length;
  for (t.polygonStart(); ++n < i; )
    Ly(e[n], t, 1);
  t.polygonEnd();
}
function qr(e, t) {
  e && OA.hasOwnProperty(e.type) ? OA[e.type](e, t) : up(e, t);
}
var lp = new nn(), cp = new nn(), UN, qN, Iy, Py, zy, yr = {
  point: St,
  lineStart: St,
  lineEnd: St,
  polygonStart: function() {
    lp = new nn(), yr.lineStart = BW, yr.lineEnd = jW;
  },
  polygonEnd: function() {
    var e = +lp;
    cp.add(e < 0 ? on + e : e), this.lineStart = this.lineEnd = this.point = St;
  },
  sphere: function() {
    cp.add(on);
  }
};
function BW() {
  yr.point = UW;
}
function jW() {
  WN(UN, qN);
}
function UW(e, t) {
  yr.point = WN, UN = e, qN = t, e *= he, t *= he, Iy = e, Py = oe(t = t / 2 + ap), zy = ne(t);
}
function WN(e, t) {
  e *= he, t *= he, t = t / 2 + ap;
  var n = e - Iy, i = n >= 0 ? 1 : -1, r = i * n, o = oe(t), a = ne(t), s = zy * a, u = Py * o + s * oe(r), l = s * i * ne(r);
  lp.add(ii(l, u)), Iy = e, Py = o, zy = a;
}
function qW(e) {
  return cp = new nn(), qr(e, yr), cp * 2;
}
function fp(e) {
  return [ii(e[1], e[0]), An(e[2])];
}
function ls(e) {
  var t = e[0], n = e[1], i = oe(n);
  return [i * oe(t), i * ne(t), ne(n)];
}
function Fd(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function Uu(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function G0(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function Md(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function dp(e) {
  var t = an(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
var Ye, hn, Ve, Rn, La, GN, HN, vu, Nc, Ao, oo, Br = {
  point: By,
  lineStart: RA,
  lineEnd: LA,
  polygonStart: function() {
    Br.point = XN, Br.lineStart = WW, Br.lineEnd = GW, Nc = new nn(), yr.polygonStart();
  },
  polygonEnd: function() {
    yr.polygonEnd(), Br.point = By, Br.lineStart = RA, Br.lineEnd = LA, lp < 0 ? (Ye = -(Ve = 180), hn = -(Rn = 90)) : Nc > re ? Rn = 90 : Nc < -re && (hn = -90), oo[0] = Ye, oo[1] = Ve;
  },
  sphere: function() {
    Ye = -(Ve = 180), hn = -(Rn = 90);
  }
};
function By(e, t) {
  Ao.push(oo = [Ye = e, Ve = e]), t < hn && (hn = t), t > Rn && (Rn = t);
}
function YN(e, t) {
  var n = ls([e * he, t * he]);
  if (vu) {
    var i = Uu(vu, n), r = [i[1], -i[0], 0], o = Uu(r, i);
    dp(o), o = fp(o);
    var a = e - La, s = a > 0 ? 1 : -1, u = o[0] * et * s, l, c = be(a) > 180;
    c ^ (s * La < u && u < s * e) ? (l = o[1] * et, l > Rn && (Rn = l)) : (u = (u + 360) % 360 - 180, c ^ (s * La < u && u < s * e) ? (l = -o[1] * et, l < hn && (hn = l)) : (t < hn && (hn = t), t > Rn && (Rn = t))), c ? e < La ? Dn(Ye, e) > Dn(Ye, Ve) && (Ve = e) : Dn(e, Ve) > Dn(Ye, Ve) && (Ye = e) : Ve >= Ye ? (e < Ye && (Ye = e), e > Ve && (Ve = e)) : e > La ? Dn(Ye, e) > Dn(Ye, Ve) && (Ve = e) : Dn(e, Ve) > Dn(Ye, Ve) && (Ye = e);
  } else
    Ao.push(oo = [Ye = e, Ve = e]);
  t < hn && (hn = t), t > Rn && (Rn = t), vu = n, La = e;
}
function RA() {
  Br.point = YN;
}
function LA() {
  oo[0] = Ye, oo[1] = Ve, Br.point = By, vu = null;
}
function XN(e, t) {
  if (vu) {
    var n = e - La;
    Nc.add(be(n) > 180 ? n + (n > 0 ? 360 : -360) : n);
  } else
    GN = e, HN = t;
  yr.point(e, t), YN(e, t);
}
function WW() {
  yr.lineStart();
}
function GW() {
  XN(GN, HN), yr.lineEnd(), be(Nc) > re && (Ye = -(Ve = 180)), oo[0] = Ye, oo[1] = Ve, vu = null;
}
function Dn(e, t) {
  return (t -= e) < 0 ? t + 360 : t;
}
function HW(e, t) {
  return e[0] - t[0];
}
function IA(e, t) {
  return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t;
}
function YW(e) {
  var t, n, i, r, o, a, s;
  if (Rn = Ve = -(Ye = hn = 1 / 0), Ao = [], qr(e, Br), n = Ao.length) {
    for (Ao.sort(HW), t = 1, i = Ao[0], o = [i]; t < n; ++t)
      r = Ao[t], IA(i, r[0]) || IA(i, r[1]) ? (Dn(i[0], r[1]) > Dn(i[0], i[1]) && (i[1] = r[1]), Dn(r[0], i[1]) > Dn(i[0], i[1]) && (i[0] = r[0])) : o.push(i = r);
    for (a = -1 / 0, n = o.length - 1, t = 0, i = o[n]; t <= n; i = r, ++t)
      r = o[t], (s = Dn(i[1], r[0])) > a && (a = s, Ye = r[0], Ve = i[1]);
  }
  return Ao = oo = null, Ye === 1 / 0 || hn === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Ye, hn], [Ve, Rn]];
}
var gc, hp, pp, gp, mp, yp, vp, bp, jy, Uy, qy, VN, KN, Jt, Qt, Zt, Si = {
  sphere: St,
  point: B2,
  lineStart: PA,
  lineEnd: zA,
  polygonStart: function() {
    Si.lineStart = KW, Si.lineEnd = JW;
  },
  polygonEnd: function() {
    Si.lineStart = PA, Si.lineEnd = zA;
  }
};
function B2(e, t) {
  e *= he, t *= he;
  var n = oe(t);
  Gf(n * oe(e), n * ne(e), ne(t));
}
function Gf(e, t, n) {
  ++gc, pp += (e - pp) / gc, gp += (t - gp) / gc, mp += (n - mp) / gc;
}
function PA() {
  Si.point = XW;
}
function XW(e, t) {
  e *= he, t *= he;
  var n = oe(t);
  Jt = n * oe(e), Qt = n * ne(e), Zt = ne(t), Si.point = VW, Gf(Jt, Qt, Zt);
}
function VW(e, t) {
  e *= he, t *= he;
  var n = oe(t), i = n * oe(e), r = n * ne(e), o = ne(t), a = ii(an((a = Qt * o - Zt * r) * a + (a = Zt * i - Jt * o) * a + (a = Jt * r - Qt * i) * a), Jt * i + Qt * r + Zt * o);
  hp += a, yp += a * (Jt + (Jt = i)), vp += a * (Qt + (Qt = r)), bp += a * (Zt + (Zt = o)), Gf(Jt, Qt, Zt);
}
function zA() {
  Si.point = B2;
}
function KW() {
  Si.point = QW;
}
function JW() {
  JN(VN, KN), Si.point = B2;
}
function QW(e, t) {
  VN = e, KN = t, e *= he, t *= he, Si.point = JN;
  var n = oe(t);
  Jt = n * oe(e), Qt = n * ne(e), Zt = ne(t), Gf(Jt, Qt, Zt);
}
function JN(e, t) {
  e *= he, t *= he;
  var n = oe(t), i = n * oe(e), r = n * ne(e), o = ne(t), a = Qt * o - Zt * r, s = Zt * i - Jt * o, u = Jt * r - Qt * i, l = Ry(a, s, u), c = An(l), f = l && -c / l;
  jy.add(f * a), Uy.add(f * s), qy.add(f * u), hp += c, yp += c * (Jt + (Jt = i)), vp += c * (Qt + (Qt = r)), bp += c * (Zt + (Zt = o)), Gf(Jt, Qt, Zt);
}
function ZW(e) {
  gc = hp = pp = gp = mp = yp = vp = bp = 0, jy = new nn(), Uy = new nn(), qy = new nn(), qr(e, Si);
  var t = +jy, n = +Uy, i = +qy, r = Ry(t, n, i);
  return r < op && (t = yp, n = vp, i = bp, hp < re && (t = pp, n = gp, i = mp), r = Ry(t, n, i), r < op) ? [NaN, NaN] : [ii(n, t) * et, An(i / r) * et];
}
function Wy(e, t) {
  function n(i, r) {
    return i = e(i, r), t(i[0], i[1]);
  }
  return e.invert && t.invert && (n.invert = function(i, r) {
    return i = t.invert(i, r), i && e.invert(i[0], i[1]);
  }), n;
}
function Gy(e, t) {
  return be(e) > pe && (e -= Math.round(e / on) * on), [e, t];
}
Gy.invert = Gy;
function QN(e, t, n) {
  return (e %= on) ? t || n ? Wy(jA(e), UA(t, n)) : jA(e) : t || n ? UA(t, n) : Gy;
}
function BA(e) {
  return function(t, n) {
    return t += e, be(t) > pe && (t -= Math.round(t / on) * on), [t, n];
  };
}
function jA(e) {
  var t = BA(e);
  return t.invert = BA(-e), t;
}
function UA(e, t) {
  var n = oe(e), i = ne(e), r = oe(t), o = ne(t);
  function a(s, u) {
    var l = oe(u), c = oe(s) * l, f = ne(s) * l, d = ne(u), h = d * n + c * i;
    return [
      ii(f * r - h * o, c * n - d * i),
      An(h * r + f * o)
    ];
  }
  return a.invert = function(s, u) {
    var l = oe(u), c = oe(s) * l, f = ne(s) * l, d = ne(u), h = d * r - f * o;
    return [
      ii(f * r + d * o, c * n + h * i),
      An(h * n - c * i)
    ];
  }, a;
}
function eG(e) {
  e = QN(e[0] * he, e[1] * he, e.length > 2 ? e[2] * he : 0);
  function t(n) {
    return n = e(n[0] * he, n[1] * he), n[0] *= et, n[1] *= et, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * he, n[1] * he), n[0] *= et, n[1] *= et, n;
  }, t;
}
function tG(e, t, n, i, r, o) {
  if (!!n) {
    var a = oe(t), s = ne(t), u = i * n;
    r == null ? (r = t + i * on, o = t - u / 2) : (r = qA(a, r), o = qA(a, o), (i > 0 ? r < o : r > o) && (r += i * on));
    for (var l, c = r; i > 0 ? c > o : c < o; c -= u)
      l = fp([a, -s * oe(c), -s * ne(c)]), e.point(l[0], l[1]);
  }
}
function qA(e, t) {
  t = ls(t), t[0] -= e, dp(t);
  var n = jN(-t[1]);
  return ((-t[2] < 0 ? -n : n) + on - re) % on;
}
function ZN() {
  var e = [], t;
  return {
    point: function(n, i, r) {
      t.push([n, i, r]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: St,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function hh(e, t) {
  return be(e[0] - t[0]) < re && be(e[1] - t[1]) < re;
}
function Td(e, t, n, i) {
  this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
}
function eD(e, t, n, i, r) {
  var o = [], a = [], s, u;
  if (e.forEach(function(p) {
    if (!((g = p.length - 1) <= 0)) {
      var g, m = p[0], y = p[g], v;
      if (hh(m, y)) {
        if (!m[2] && !y[2]) {
          for (r.lineStart(), s = 0; s < g; ++s)
            r.point((m = p[s])[0], m[1]);
          r.lineEnd();
          return;
        }
        y[0] += 2 * re;
      }
      o.push(v = new Td(m, p, null, !0)), a.push(v.o = new Td(m, null, v, !1)), o.push(v = new Td(y, p, null, !1)), a.push(v.o = new Td(y, null, v, !0));
    }
  }), !!o.length) {
    for (a.sort(t), WA(o), WA(a), s = 0, u = a.length; s < u; ++s)
      a[s].e = n = !n;
    for (var l = o[0], c, f; ; ) {
      for (var d = l, h = !0; d.v; )
        if ((d = d.n) === l)
          return;
      c = d.z, r.lineStart();
      do {
        if (d.v = d.o.v = !0, d.e) {
          if (h)
            for (s = 0, u = c.length; s < u; ++s)
              r.point((f = c[s])[0], f[1]);
          else
            i(d.x, d.n.x, 1, r);
          d = d.n;
        } else {
          if (h)
            for (c = d.p.z, s = c.length - 1; s >= 0; --s)
              r.point((f = c[s])[0], f[1]);
          else
            i(d.x, d.p.x, -1, r);
          d = d.p;
        }
        d = d.o, c = d.z, h = !h;
      } while (!d.v);
      r.lineEnd();
    }
  }
}
function WA(e) {
  if (!!(t = e.length)) {
    for (var t, n = 0, i = e[0], r; ++n < t; )
      i.n = r = e[n], r.p = i, i = r;
    i.n = r = e[0], r.p = i;
  }
}
function H0(e) {
  return be(e[0]) <= pe ? e[0] : Vn(e[0]) * ((be(e[0]) + pe) % on - pe);
}
function nG(e, t) {
  var n = H0(t), i = t[1], r = ne(i), o = [ne(n), -oe(n), 0], a = 0, s = 0, u = new nn();
  r === 1 ? i = Qe + re : r === -1 && (i = -Qe - re);
  for (var l = 0, c = e.length; l < c; ++l)
    if (!!(d = (f = e[l]).length))
      for (var f, d, h = f[d - 1], p = H0(h), g = h[1] / 2 + ap, m = ne(g), y = oe(g), v = 0; v < d; ++v, p = x, m = _, y = w, h = b) {
        var b = f[v], x = H0(b), E = b[1] / 2 + ap, _ = ne(E), w = oe(E), S = x - p, C = S >= 0 ? 1 : -1, $ = C * S, A = $ > pe, M = m * _;
        if (u.add(ii(M * C * ne($), y * w + M * oe($))), a += A ? S + C * on : S, A ^ p >= n ^ x >= n) {
          var F = Uu(ls(h), ls(b));
          dp(F);
          var O = Uu(o, F);
          dp(O);
          var k = (A ^ S >= 0 ? -1 : 1) * An(O[2]);
          (i > k || i === k && (F[0] || F[1])) && (s += A ^ S >= 0 ? 1 : -1);
        }
      }
  return (a < -re || a < re && u < -op) ^ s & 1;
}
function tD(e, t, n, i) {
  return function(r) {
    var o = t(r), a = ZN(), s = t(a), u = !1, l, c, f, d = {
      point: h,
      lineStart: g,
      lineEnd: m,
      polygonStart: function() {
        d.point = y, d.lineStart = v, d.lineEnd = b, c = [], l = [];
      },
      polygonEnd: function() {
        d.point = h, d.lineStart = g, d.lineEnd = m, c = QF(c);
        var x = nG(l, i);
        c.length ? (u || (r.polygonStart(), u = !0), eD(c, rG, x, n, r)) : x && (u || (r.polygonStart(), u = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), u && (r.polygonEnd(), u = !1), c = l = null;
      },
      sphere: function() {
        r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd();
      }
    };
    function h(x, E) {
      e(x, E) && r.point(x, E);
    }
    function p(x, E) {
      o.point(x, E);
    }
    function g() {
      d.point = p, o.lineStart();
    }
    function m() {
      d.point = h, o.lineEnd();
    }
    function y(x, E) {
      f.push([x, E]), s.point(x, E);
    }
    function v() {
      s.lineStart(), f = [];
    }
    function b() {
      y(f[0][0], f[0][1]), s.lineEnd();
      var x = s.clean(), E = a.result(), _, w = E.length, S, C, $;
      if (f.pop(), l.push(f), f = null, !!w) {
        if (x & 1) {
          if (C = E[0], (S = C.length - 1) > 0) {
            for (u || (r.polygonStart(), u = !0), r.lineStart(), _ = 0; _ < S; ++_)
              r.point(($ = C[_])[0], $[1]);
            r.lineEnd();
          }
          return;
        }
        w > 1 && x & 2 && E.push(E.pop().concat(E.shift())), c.push(E.filter(iG));
      }
    }
    return d;
  };
}
function iG(e) {
  return e.length > 1;
}
function rG(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - Qe - re : Qe - e[1]) - ((t = t.x)[0] < 0 ? t[1] - Qe - re : Qe - t[1]);
}
const GA = tD(
  function() {
    return !0;
  },
  oG,
  sG,
  [-pe, -Qe]
);
function oG(e) {
  var t = NaN, n = NaN, i = NaN, r;
  return {
    lineStart: function() {
      e.lineStart(), r = 1;
    },
    point: function(o, a) {
      var s = o > 0 ? pe : -pe, u = be(o - t);
      be(u - pe) < re ? (e.point(t, n = (n + a) / 2 > 0 ? Qe : -Qe), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(s, n), e.point(o, n), r = 0) : i !== s && u >= pe && (be(t - i) < re && (t -= i * re), be(o - s) < re && (o -= s * re), n = aG(t, n, o, a), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(s, n), r = 0), e.point(t = o, n = a), i = s;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - r;
    }
  };
}
function aG(e, t, n, i) {
  var r, o, a = ne(e - n);
  return be(a) > re ? xl((ne(t) * (o = oe(i)) * ne(n) - ne(i) * (r = oe(t)) * ne(e)) / (r * o * a)) : (t + i) / 2;
}
function sG(e, t, n, i) {
  var r;
  if (e == null)
    r = n * Qe, i.point(-pe, r), i.point(0, r), i.point(pe, r), i.point(pe, 0), i.point(pe, -r), i.point(0, -r), i.point(-pe, -r), i.point(-pe, 0), i.point(-pe, r);
  else if (be(e[0] - t[0]) > re) {
    var o = e[0] < t[0] ? pe : -pe;
    r = n * o / 2, i.point(-o, r), i.point(0, r), i.point(o, r);
  } else
    i.point(t[0], t[1]);
}
function uG(e) {
  var t = oe(e), n = 6 * he, i = t > 0, r = be(t) > re;
  function o(c, f, d, h) {
    tG(h, e, n, d, c, f);
  }
  function a(c, f) {
    return oe(c) * oe(f) > t;
  }
  function s(c) {
    var f, d, h, p, g;
    return {
      lineStart: function() {
        p = h = !1, g = 1;
      },
      point: function(m, y) {
        var v = [m, y], b, x = a(m, y), E = i ? x ? 0 : l(m, y) : x ? l(m + (m < 0 ? pe : -pe), y) : 0;
        if (!f && (p = h = x) && c.lineStart(), x !== h && (b = u(f, v), (!b || hh(f, b) || hh(v, b)) && (v[2] = 1)), x !== h)
          g = 0, x ? (c.lineStart(), b = u(v, f), c.point(b[0], b[1])) : (b = u(f, v), c.point(b[0], b[1], 2), c.lineEnd()), f = b;
        else if (r && f && i ^ x) {
          var _;
          !(E & d) && (_ = u(v, f, !0)) && (g = 0, i ? (c.lineStart(), c.point(_[0][0], _[0][1]), c.point(_[1][0], _[1][1]), c.lineEnd()) : (c.point(_[1][0], _[1][1]), c.lineEnd(), c.lineStart(), c.point(_[0][0], _[0][1], 3)));
        }
        x && (!f || !hh(f, v)) && c.point(v[0], v[1]), f = v, h = x, d = E;
      },
      lineEnd: function() {
        h && c.lineEnd(), f = null;
      },
      clean: function() {
        return g | (p && h) << 1;
      }
    };
  }
  function u(c, f, d) {
    var h = ls(c), p = ls(f), g = [1, 0, 0], m = Uu(h, p), y = Fd(m, m), v = m[0], b = y - v * v;
    if (!b)
      return !d && c;
    var x = t * y / b, E = -t * v / b, _ = Uu(g, m), w = Md(g, x), S = Md(m, E);
    G0(w, S);
    var C = _, $ = Fd(w, C), A = Fd(C, C), M = $ * $ - A * (Fd(w, w) - 1);
    if (!(M < 0)) {
      var F = an(M), O = Md(C, (-$ - F) / A);
      if (G0(O, w), O = fp(O), !d)
        return O;
      var k = c[0], T = f[0], N = c[1], L = f[1], z;
      T < k && (z = k, k = T, T = z);
      var J = T - k, le = be(J - pe) < re, Ee = le || J < re;
      if (!le && L < N && (z = N, N = L, L = z), Ee ? le ? N + L > 0 ^ O[1] < (be(O[0] - k) < re ? N : L) : N <= O[1] && O[1] <= L : J > pe ^ (k <= O[0] && O[0] <= T)) {
        var _e = Md(C, (-$ + F) / A);
        return G0(_e, w), [O, fp(_e)];
      }
    }
  }
  function l(c, f) {
    var d = i ? e : pe - e, h = 0;
    return c < -d ? h |= 1 : c > d && (h |= 2), f < -d ? h |= 4 : f > d && (h |= 8), h;
  }
  return tD(a, s, o, i ? [0, -e] : [-pe, e - pe]);
}
function lG(e, t, n, i, r, o) {
  var a = e[0], s = e[1], u = t[0], l = t[1], c = 0, f = 1, d = u - a, h = l - s, p;
  if (p = n - a, !(!d && p > 0)) {
    if (p /= d, d < 0) {
      if (p < c)
        return;
      p < f && (f = p);
    } else if (d > 0) {
      if (p > f)
        return;
      p > c && (c = p);
    }
    if (p = r - a, !(!d && p < 0)) {
      if (p /= d, d < 0) {
        if (p > f)
          return;
        p > c && (c = p);
      } else if (d > 0) {
        if (p < c)
          return;
        p < f && (f = p);
      }
      if (p = i - s, !(!h && p > 0)) {
        if (p /= h, h < 0) {
          if (p < c)
            return;
          p < f && (f = p);
        } else if (h > 0) {
          if (p > f)
            return;
          p > c && (c = p);
        }
        if (p = o - s, !(!h && p < 0)) {
          if (p /= h, h < 0) {
            if (p > f)
              return;
            p > c && (c = p);
          } else if (h > 0) {
            if (p < c)
              return;
            p < f && (f = p);
          }
          return c > 0 && (e[0] = a + c * d, e[1] = s + c * h), f < 1 && (t[0] = a + f * d, t[1] = s + f * h), !0;
        }
      }
    }
  }
}
var mc = 1e9, Od = -mc;
function nD(e, t, n, i) {
  function r(l, c) {
    return e <= l && l <= n && t <= c && c <= i;
  }
  function o(l, c, f, d) {
    var h = 0, p = 0;
    if (l == null || (h = a(l, f)) !== (p = a(c, f)) || u(l, c) < 0 ^ f > 0)
      do
        d.point(h === 0 || h === 3 ? e : n, h > 1 ? i : t);
      while ((h = (h + f + 4) % 4) !== p);
    else
      d.point(c[0], c[1]);
  }
  function a(l, c) {
    return be(l[0] - e) < re ? c > 0 ? 0 : 3 : be(l[0] - n) < re ? c > 0 ? 2 : 1 : be(l[1] - t) < re ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
  }
  function s(l, c) {
    return u(l.x, c.x);
  }
  function u(l, c) {
    var f = a(l, 1), d = a(c, 1);
    return f !== d ? f - d : f === 0 ? c[1] - l[1] : f === 1 ? l[0] - c[0] : f === 2 ? l[1] - c[1] : c[0] - l[0];
  }
  return function(l) {
    var c = l, f = ZN(), d, h, p, g, m, y, v, b, x, E, _, w = {
      point: S,
      lineStart: M,
      lineEnd: F,
      polygonStart: $,
      polygonEnd: A
    };
    function S(k, T) {
      r(k, T) && c.point(k, T);
    }
    function C() {
      for (var k = 0, T = 0, N = h.length; T < N; ++T)
        for (var L = h[T], z = 1, J = L.length, le = L[0], Ee, _e, Ue = le[0], ye = le[1]; z < J; ++z)
          Ee = Ue, _e = ye, le = L[z], Ue = le[0], ye = le[1], _e <= i ? ye > i && (Ue - Ee) * (i - _e) > (ye - _e) * (e - Ee) && ++k : ye <= i && (Ue - Ee) * (i - _e) < (ye - _e) * (e - Ee) && --k;
      return k;
    }
    function $() {
      c = f, d = [], h = [], _ = !0;
    }
    function A() {
      var k = C(), T = _ && k, N = (d = QF(d)).length;
      (T || N) && (l.polygonStart(), T && (l.lineStart(), o(null, null, 1, l), l.lineEnd()), N && eD(d, s, k, o, l), l.polygonEnd()), c = l, d = h = p = null;
    }
    function M() {
      w.point = O, h && h.push(p = []), E = !0, x = !1, v = b = NaN;
    }
    function F() {
      d && (O(g, m), y && x && f.rejoin(), d.push(f.result())), w.point = S, x && c.lineEnd();
    }
    function O(k, T) {
      var N = r(k, T);
      if (h && p.push([k, T]), E)
        g = k, m = T, y = N, E = !1, N && (c.lineStart(), c.point(k, T));
      else if (N && x)
        c.point(k, T);
      else {
        var L = [v = Math.max(Od, Math.min(mc, v)), b = Math.max(Od, Math.min(mc, b))], z = [k = Math.max(Od, Math.min(mc, k)), T = Math.max(Od, Math.min(mc, T))];
        lG(L, z, e, t, n, i) ? (x || (c.lineStart(), c.point(L[0], L[1])), c.point(z[0], z[1]), N || c.lineEnd(), _ = !1) : N && (c.lineStart(), c.point(k, T), _ = !1);
      }
      v = k, b = T, x = N;
    }
    return w;
  };
}
function HA(e, t, n) {
  var i = Pn(e, t - re, n).concat(t);
  return function(r) {
    return i.map(function(o) {
      return [r, o];
    });
  };
}
function YA(e, t, n) {
  var i = Pn(e, t - re, n).concat(t);
  return function(r) {
    return i.map(function(o) {
      return [o, r];
    });
  };
}
function cG() {
  var e, t, n, i, r, o, a, s, u = 10, l = u, c = 90, f = 360, d, h, p, g, m = 2.5;
  function y() {
    return { type: "MultiLineString", coordinates: v() };
  }
  function v() {
    return Pn(Cd(i / c) * c, n, c).map(p).concat(Pn(Cd(s / f) * f, a, f).map(g)).concat(Pn(Cd(t / u) * u, e, u).filter(function(b) {
      return be(b % c) > re;
    }).map(d)).concat(Pn(Cd(o / l) * l, r, l).filter(function(b) {
      return be(b % f) > re;
    }).map(h));
  }
  return y.lines = function() {
    return v().map(function(b) {
      return { type: "LineString", coordinates: b };
    });
  }, y.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        p(i).concat(
          g(a).slice(1),
          p(n).reverse().slice(1),
          g(s).reverse().slice(1)
        )
      ]
    };
  }, y.extent = function(b) {
    return arguments.length ? y.extentMajor(b).extentMinor(b) : y.extentMinor();
  }, y.extentMajor = function(b) {
    return arguments.length ? (i = +b[0][0], n = +b[1][0], s = +b[0][1], a = +b[1][1], i > n && (b = i, i = n, n = b), s > a && (b = s, s = a, a = b), y.precision(m)) : [[i, s], [n, a]];
  }, y.extentMinor = function(b) {
    return arguments.length ? (t = +b[0][0], e = +b[1][0], o = +b[0][1], r = +b[1][1], t > e && (b = t, t = e, e = b), o > r && (b = o, o = r, r = b), y.precision(m)) : [[t, o], [e, r]];
  }, y.step = function(b) {
    return arguments.length ? y.stepMajor(b).stepMinor(b) : y.stepMinor();
  }, y.stepMajor = function(b) {
    return arguments.length ? (c = +b[0], f = +b[1], y) : [c, f];
  }, y.stepMinor = function(b) {
    return arguments.length ? (u = +b[0], l = +b[1], y) : [u, l];
  }, y.precision = function(b) {
    return arguments.length ? (m = +b, d = HA(o, r, 90), h = YA(t, e, m), p = HA(s, a, 90), g = YA(i, n, m), y) : m;
  }, y.extentMajor([[-180, -90 + re], [180, 90 - re]]).extentMinor([[-180, -80 - re], [180, 80 + re]]);
}
const of = (e) => e;
var Y0 = new nn(), Hy = new nn(), iD, rD, Yy, Xy, Fo = {
  point: St,
  lineStart: St,
  lineEnd: St,
  polygonStart: function() {
    Fo.lineStart = fG, Fo.lineEnd = hG;
  },
  polygonEnd: function() {
    Fo.lineStart = Fo.lineEnd = Fo.point = St, Y0.add(be(Hy)), Hy = new nn();
  },
  result: function() {
    var e = Y0 / 2;
    return Y0 = new nn(), e;
  }
};
function fG() {
  Fo.point = dG;
}
function dG(e, t) {
  Fo.point = oD, iD = Yy = e, rD = Xy = t;
}
function oD(e, t) {
  Hy.add(Xy * e - Yy * t), Yy = e, Xy = t;
}
function hG() {
  oD(iD, rD);
}
const XA = Fo;
var qu = 1 / 0, xp = qu, af = -qu, wp = af, pG = {
  point: gG,
  lineStart: St,
  lineEnd: St,
  polygonStart: St,
  polygonEnd: St,
  result: function() {
    var e = [[qu, xp], [af, wp]];
    return af = wp = -(xp = qu = 1 / 0), e;
  }
};
function gG(e, t) {
  e < qu && (qu = e), e > af && (af = e), t < xp && (xp = t), t > wp && (wp = t);
}
const Ep = pG;
var Vy = 0, Ky = 0, yc = 0, _p = 0, Sp = 0, du = 0, Jy = 0, Qy = 0, vc = 0, aD, sD, tr, nr, xi = {
  point: cs,
  lineStart: VA,
  lineEnd: KA,
  polygonStart: function() {
    xi.lineStart = vG, xi.lineEnd = bG;
  },
  polygonEnd: function() {
    xi.point = cs, xi.lineStart = VA, xi.lineEnd = KA;
  },
  result: function() {
    var e = vc ? [Jy / vc, Qy / vc] : du ? [_p / du, Sp / du] : yc ? [Vy / yc, Ky / yc] : [NaN, NaN];
    return Vy = Ky = yc = _p = Sp = du = Jy = Qy = vc = 0, e;
  }
};
function cs(e, t) {
  Vy += e, Ky += t, ++yc;
}
function VA() {
  xi.point = mG;
}
function mG(e, t) {
  xi.point = yG, cs(tr = e, nr = t);
}
function yG(e, t) {
  var n = e - tr, i = t - nr, r = an(n * n + i * i);
  _p += r * (tr + e) / 2, Sp += r * (nr + t) / 2, du += r, cs(tr = e, nr = t);
}
function KA() {
  xi.point = cs;
}
function vG() {
  xi.point = xG;
}
function bG() {
  uD(aD, sD);
}
function xG(e, t) {
  xi.point = uD, cs(aD = tr = e, sD = nr = t);
}
function uD(e, t) {
  var n = e - tr, i = t - nr, r = an(n * n + i * i);
  _p += r * (tr + e) / 2, Sp += r * (nr + t) / 2, du += r, r = nr * e - tr * t, Jy += r * (tr + e), Qy += r * (nr + t), vc += r * 3, cs(tr = e, nr = t);
}
const JA = xi;
function lD(e) {
  this._context = e;
}
lD.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, on);
        break;
      }
    }
  },
  result: St
};
var Zy = new nn(), X0, cD, fD, bc, xc, Ap = {
  point: St,
  lineStart: function() {
    Ap.point = wG;
  },
  lineEnd: function() {
    X0 && dD(cD, fD), Ap.point = St;
  },
  polygonStart: function() {
    X0 = !0;
  },
  polygonEnd: function() {
    X0 = null;
  },
  result: function() {
    var e = +Zy;
    return Zy = new nn(), e;
  }
};
function wG(e, t) {
  Ap.point = dD, cD = bc = e, fD = xc = t;
}
function dD(e, t) {
  bc -= e, xc -= t, Zy.add(an(bc * bc + xc * xc)), bc = e, xc = t;
}
const QA = Ap;
let ZA, $p, e$, t$;
class n$ {
  constructor(t) {
    this._append = t == null ? hD : EG(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== e$ || this._append !== $p) {
          const i = this._radius, r = this._;
          this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, e$ = i, $p = this._append, t$ = this._, this._ = r;
        }
        this._ += t$;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function hD(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function EG(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return hD;
  if (t !== ZA) {
    const n = 10 ** t;
    ZA = t, $p = function(r) {
      let o = 1;
      this._ += r[0];
      for (const a = r.length; o < a; ++o)
        this._ += Math.round(arguments[o] * n) / n + r[o];
    };
  }
  return $p;
}
function pD(e, t) {
  let n = 3, i = 4.5, r, o;
  function a(s) {
    return s && (typeof i == "function" && o.pointRadius(+i.apply(this, arguments)), qr(s, r(o))), o.result();
  }
  return a.area = function(s) {
    return qr(s, r(XA)), XA.result();
  }, a.measure = function(s) {
    return qr(s, r(QA)), QA.result();
  }, a.bounds = function(s) {
    return qr(s, r(Ep)), Ep.result();
  }, a.centroid = function(s) {
    return qr(s, r(JA)), JA.result();
  }, a.projection = function(s) {
    return arguments.length ? (r = s == null ? (e = null, of) : (e = s).stream, a) : e;
  }, a.context = function(s) {
    return arguments.length ? (o = s == null ? (t = null, new n$(n)) : new lD(t = s), typeof i != "function" && o.pointRadius(i), a) : t;
  }, a.pointRadius = function(s) {
    return arguments.length ? (i = typeof s == "function" ? s : (o.pointRadius(+s), +s), a) : i;
  }, a.digits = function(s) {
    if (!arguments.length)
      return n;
    if (s == null)
      n = null;
    else {
      const u = Math.floor(s);
      if (!(u >= 0))
        throw new RangeError(`invalid digits: ${s}`);
      n = u;
    }
    return t === null && (o = new n$(n)), a;
  }, a.projection(e).digits(n).context(t);
}
function rm(e) {
  return function(t) {
    var n = new ev();
    for (var i in e)
      n[i] = e[i];
    return n.stream = t, n;
  };
}
function ev() {
}
ev.prototype = {
  constructor: ev,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function j2(e, t, n) {
  var i = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), qr(n, e.stream(Ep)), t(Ep.result()), i != null && e.clipExtent(i), e;
}
function om(e, t, n) {
  return j2(e, function(i) {
    var r = t[1][0] - t[0][0], o = t[1][1] - t[0][1], a = Math.min(r / (i[1][0] - i[0][0]), o / (i[1][1] - i[0][1])), s = +t[0][0] + (r - a * (i[1][0] + i[0][0])) / 2, u = +t[0][1] + (o - a * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * a).translate([s, u]);
  }, n);
}
function U2(e, t, n) {
  return om(e, [[0, 0], t], n);
}
function q2(e, t, n) {
  return j2(e, function(i) {
    var r = +t, o = r / (i[1][0] - i[0][0]), a = (r - o * (i[1][0] + i[0][0])) / 2, s = -o * i[0][1];
    e.scale(150 * o).translate([a, s]);
  }, n);
}
function W2(e, t, n) {
  return j2(e, function(i) {
    var r = +t, o = r / (i[1][1] - i[0][1]), a = -o * i[0][0], s = (r - o * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * o).translate([a, s]);
  }, n);
}
var i$ = 16, _G = oe(30 * he);
function r$(e, t) {
  return +t ? AG(e, t) : SG(e);
}
function SG(e) {
  return rm({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function AG(e, t) {
  function n(i, r, o, a, s, u, l, c, f, d, h, p, g, m) {
    var y = l - i, v = c - r, b = y * y + v * v;
    if (b > 4 * t && g--) {
      var x = a + d, E = s + h, _ = u + p, w = an(x * x + E * E + _ * _), S = An(_ /= w), C = be(be(_) - 1) < re || be(o - f) < re ? (o + f) / 2 : ii(E, x), $ = e(C, S), A = $[0], M = $[1], F = A - i, O = M - r, k = v * F - y * O;
      (k * k / b > t || be((y * F + v * O) / b - 0.5) > 0.3 || a * d + s * h + u * p < _G) && (n(i, r, o, a, s, u, A, M, C, x /= w, E /= w, _, g, m), m.point(A, M), n(A, M, C, x, E, _, l, c, f, d, h, p, g, m));
    }
  }
  return function(i) {
    var r, o, a, s, u, l, c, f, d, h, p, g, m = {
      point: y,
      lineStart: v,
      lineEnd: x,
      polygonStart: function() {
        i.polygonStart(), m.lineStart = E;
      },
      polygonEnd: function() {
        i.polygonEnd(), m.lineStart = v;
      }
    };
    function y(S, C) {
      S = e(S, C), i.point(S[0], S[1]);
    }
    function v() {
      f = NaN, m.point = b, i.lineStart();
    }
    function b(S, C) {
      var $ = ls([S, C]), A = e(S, C);
      n(f, d, c, h, p, g, f = A[0], d = A[1], c = S, h = $[0], p = $[1], g = $[2], i$, i), i.point(f, d);
    }
    function x() {
      m.point = y, i.lineEnd();
    }
    function E() {
      v(), m.point = _, m.lineEnd = w;
    }
    function _(S, C) {
      b(r = S, C), o = f, a = d, s = h, u = p, l = g, m.point = b;
    }
    function w() {
      n(f, d, c, h, p, g, o, a, r, s, u, l, i$, i), m.lineEnd = x, x();
    }
    return m;
  };
}
var $G = rm({
  point: function(e, t) {
    this.stream.point(e * he, t * he);
  }
});
function kG(e) {
  return rm({
    point: function(t, n) {
      var i = e(t, n);
      return this.stream.point(i[0], i[1]);
    }
  });
}
function CG(e, t, n, i, r) {
  function o(a, s) {
    return a *= i, s *= r, [t + e * a, n - e * s];
  }
  return o.invert = function(a, s) {
    return [(a - t) / e * i, (n - s) / e * r];
  }, o;
}
function o$(e, t, n, i, r, o) {
  if (!o)
    return CG(e, t, n, i, r);
  var a = oe(o), s = ne(o), u = a * e, l = s * e, c = a / e, f = s / e, d = (s * n - a * t) / e, h = (s * t + a * n) / e;
  function p(g, m) {
    return g *= i, m *= r, [u * g - l * m + t, n - l * g - u * m];
  }
  return p.invert = function(g, m) {
    return [i * (c * g - f * m + d), r * (h - f * g - c * m)];
  }, p;
}
function $r(e) {
  return gD(function() {
    return e;
  })();
}
function gD(e) {
  var t, n = 150, i = 480, r = 250, o = 0, a = 0, s = 0, u = 0, l = 0, c, f = 0, d = 1, h = 1, p = null, g = GA, m = null, y, v, b, x = of, E = 0.5, _, w, S, C, $;
  function A(k) {
    return S(k[0] * he, k[1] * he);
  }
  function M(k) {
    return k = S.invert(k[0], k[1]), k && [k[0] * et, k[1] * et];
  }
  A.stream = function(k) {
    return C && $ === k ? C : C = $G(kG(c)(g(_(x($ = k)))));
  }, A.preclip = function(k) {
    return arguments.length ? (g = k, p = void 0, O()) : g;
  }, A.postclip = function(k) {
    return arguments.length ? (x = k, m = y = v = b = null, O()) : x;
  }, A.clipAngle = function(k) {
    return arguments.length ? (g = +k ? uG(p = k * he) : (p = null, GA), O()) : p * et;
  }, A.clipExtent = function(k) {
    return arguments.length ? (x = k == null ? (m = y = v = b = null, of) : nD(m = +k[0][0], y = +k[0][1], v = +k[1][0], b = +k[1][1]), O()) : m == null ? null : [[m, y], [v, b]];
  }, A.scale = function(k) {
    return arguments.length ? (n = +k, F()) : n;
  }, A.translate = function(k) {
    return arguments.length ? (i = +k[0], r = +k[1], F()) : [i, r];
  }, A.center = function(k) {
    return arguments.length ? (o = k[0] % 360 * he, a = k[1] % 360 * he, F()) : [o * et, a * et];
  }, A.rotate = function(k) {
    return arguments.length ? (s = k[0] % 360 * he, u = k[1] % 360 * he, l = k.length > 2 ? k[2] % 360 * he : 0, F()) : [s * et, u * et, l * et];
  }, A.angle = function(k) {
    return arguments.length ? (f = k % 360 * he, F()) : f * et;
  }, A.reflectX = function(k) {
    return arguments.length ? (d = k ? -1 : 1, F()) : d < 0;
  }, A.reflectY = function(k) {
    return arguments.length ? (h = k ? -1 : 1, F()) : h < 0;
  }, A.precision = function(k) {
    return arguments.length ? (_ = r$(w, E = k * k), O()) : an(E);
  }, A.fitExtent = function(k, T) {
    return om(A, k, T);
  }, A.fitSize = function(k, T) {
    return U2(A, k, T);
  }, A.fitWidth = function(k, T) {
    return q2(A, k, T);
  }, A.fitHeight = function(k, T) {
    return W2(A, k, T);
  };
  function F() {
    var k = o$(n, 0, 0, d, h, f).apply(null, t(o, a)), T = o$(n, i - k[0], r - k[1], d, h, f);
    return c = QN(s, u, l), w = Wy(t, T), S = Wy(c, w), _ = r$(w, E), O();
  }
  function O() {
    return C = $ = null, A;
  }
  return function() {
    return t = e.apply(this, arguments), A.invert = t.invert && M, F();
  };
}
function G2(e) {
  var t = 0, n = pe / 3, i = gD(e), r = i(t, n);
  return r.parallels = function(o) {
    return arguments.length ? i(t = o[0] * he, n = o[1] * he) : [t * et, n * et];
  }, r;
}
function FG(e) {
  var t = oe(e);
  function n(i, r) {
    return [i * t, ne(r) / t];
  }
  return n.invert = function(i, r) {
    return [i / t, An(r * t)];
  }, n;
}
function MG(e, t) {
  var n = ne(e), i = (n + ne(t)) / 2;
  if (be(i) < re)
    return FG(e);
  var r = 1 + n * (2 * i - n), o = an(r) / i;
  function a(s, u) {
    var l = an(r - 2 * i * ne(u)) / i;
    return [l * ne(s *= i), o - l * oe(s)];
  }
  return a.invert = function(s, u) {
    var l = o - u, c = ii(s, be(l)) * Vn(l);
    return l * i < 0 && (c -= pe * Vn(s) * Vn(l)), [c / i, An((r - (s * s + l * l) * i * i) / (2 * i))];
  }, a;
}
function kp() {
  return G2(MG).scale(155.424).center([0, 33.6442]);
}
function mD() {
  return kp().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function TG(e) {
  var t = e.length;
  return {
    point: function(n, i) {
      for (var r = -1; ++r < t; )
        e[r].point(n, i);
    },
    sphere: function() {
      for (var n = -1; ++n < t; )
        e[n].sphere();
    },
    lineStart: function() {
      for (var n = -1; ++n < t; )
        e[n].lineStart();
    },
    lineEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].lineEnd();
    },
    polygonStart: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonStart();
    },
    polygonEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonEnd();
    }
  };
}
function OG() {
  var e, t, n = mD(), i, r = kp().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), o, a = kp().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), s, u, l = { point: function(d, h) {
    u = [d, h];
  } };
  function c(d) {
    var h = d[0], p = d[1];
    return u = null, i.point(h, p), u || (o.point(h, p), u) || (s.point(h, p), u);
  }
  c.invert = function(d) {
    var h = n.scale(), p = n.translate(), g = (d[0] - p[0]) / h, m = (d[1] - p[1]) / h;
    return (m >= 0.12 && m < 0.234 && g >= -0.425 && g < -0.214 ? r : m >= 0.166 && m < 0.234 && g >= -0.214 && g < -0.115 ? a : n).invert(d);
  }, c.stream = function(d) {
    return e && t === d ? e : e = TG([n.stream(t = d), r.stream(d), a.stream(d)]);
  }, c.precision = function(d) {
    return arguments.length ? (n.precision(d), r.precision(d), a.precision(d), f()) : n.precision();
  }, c.scale = function(d) {
    return arguments.length ? (n.scale(d), r.scale(d * 0.35), a.scale(d), c.translate(n.translate())) : n.scale();
  }, c.translate = function(d) {
    if (!arguments.length)
      return n.translate();
    var h = n.scale(), p = +d[0], g = +d[1];
    return i = n.translate(d).clipExtent([[p - 0.455 * h, g - 0.238 * h], [p + 0.455 * h, g + 0.238 * h]]).stream(l), o = r.translate([p - 0.307 * h, g + 0.201 * h]).clipExtent([[p - 0.425 * h + re, g + 0.12 * h + re], [p - 0.214 * h - re, g + 0.234 * h - re]]).stream(l), s = a.translate([p - 0.205 * h, g + 0.212 * h]).clipExtent([[p - 0.214 * h + re, g + 0.166 * h + re], [p - 0.115 * h - re, g + 0.234 * h - re]]).stream(l), f();
  }, c.fitExtent = function(d, h) {
    return om(c, d, h);
  }, c.fitSize = function(d, h) {
    return U2(c, d, h);
  }, c.fitWidth = function(d, h) {
    return q2(c, d, h);
  }, c.fitHeight = function(d, h) {
    return W2(c, d, h);
  };
  function f() {
    return e = t = null, c;
  }
  return c.scale(1070);
}
function yD(e) {
  return function(t, n) {
    var i = oe(t), r = oe(n), o = e(i * r);
    return o === 1 / 0 ? [2, 0] : [
      o * r * ne(t),
      o * ne(n)
    ];
  };
}
function Hf(e) {
  return function(t, n) {
    var i = an(t * t + n * n), r = e(i), o = ne(r), a = oe(r);
    return [
      ii(t * o, i * a),
      An(i && n * o / i)
    ];
  };
}
var vD = yD(function(e) {
  return an(2 / (1 + e));
});
vD.invert = Hf(function(e) {
  return 2 * An(e / 2);
});
function NG() {
  return $r(vD).scale(124.75).clipAngle(180 - 1e-3);
}
var bD = yD(function(e) {
  return (e = jN(e)) && e / ne(e);
});
bD.invert = Hf(function(e) {
  return e;
});
function DG() {
  return $r(bD).scale(79.4188).clipAngle(180 - 1e-3);
}
function am(e, t) {
  return [e, sp(z2((Qe + t) / 2))];
}
am.invert = function(e, t) {
  return [e, 2 * xl(BN(t)) - Qe];
};
function RG() {
  return xD(am).scale(961 / on);
}
function xD(e) {
  var t = $r(e), n = t.center, i = t.scale, r = t.translate, o = t.clipExtent, a = null, s, u, l;
  t.scale = function(f) {
    return arguments.length ? (i(f), c()) : i();
  }, t.translate = function(f) {
    return arguments.length ? (r(f), c()) : r();
  }, t.center = function(f) {
    return arguments.length ? (n(f), c()) : n();
  }, t.clipExtent = function(f) {
    return arguments.length ? (f == null ? a = s = u = l = null : (a = +f[0][0], s = +f[0][1], u = +f[1][0], l = +f[1][1]), c()) : a == null ? null : [[a, s], [u, l]];
  };
  function c() {
    var f = pe * i(), d = t(eG(t.rotate()).invert([0, 0]));
    return o(a == null ? [[d[0] - f, d[1] - f], [d[0] + f, d[1] + f]] : e === am ? [[Math.max(d[0] - f, a), s], [Math.min(d[0] + f, u), l]] : [[a, Math.max(d[1] - f, s)], [u, Math.min(d[1] + f, l)]]);
  }
  return c();
}
function Nd(e) {
  return z2((Qe + e) / 2);
}
function LG(e, t) {
  var n = oe(e), i = e === t ? ne(e) : sp(n / oe(t)) / sp(Nd(t) / Nd(e)), r = n * W0(Nd(e), i) / i;
  if (!i)
    return am;
  function o(a, s) {
    r > 0 ? s < -Qe + re && (s = -Qe + re) : s > Qe - re && (s = Qe - re);
    var u = r / W0(Nd(s), i);
    return [u * ne(i * a), r - u * oe(i * a)];
  }
  return o.invert = function(a, s) {
    var u = r - s, l = Vn(i) * an(a * a + u * u), c = ii(a, be(u)) * Vn(u);
    return u * i < 0 && (c -= pe * Vn(a) * Vn(u)), [c / i, 2 * xl(W0(r / l, 1 / i)) - Qe];
  }, o;
}
function IG() {
  return G2(LG).scale(109.5).parallels([30, 30]);
}
function Cp(e, t) {
  return [e, t];
}
Cp.invert = Cp;
function PG() {
  return $r(Cp).scale(152.63);
}
function zG(e, t) {
  var n = oe(e), i = e === t ? ne(e) : (n - oe(t)) / (t - e), r = n / i + e;
  if (be(i) < re)
    return Cp;
  function o(a, s) {
    var u = r - s, l = i * a;
    return [u * ne(l), r - u * oe(l)];
  }
  return o.invert = function(a, s) {
    var u = r - s, l = ii(a, be(u)) * Vn(u);
    return u * i < 0 && (l -= pe * Vn(a) * Vn(u)), [l / i, r - Vn(i) * an(a * a + u * u)];
  }, o;
}
function BG() {
  return G2(zG).scale(131.154).center([0, 13.9389]);
}
var Dc = 1.340264, Rc = -0.081106, Lc = 893e-6, Ic = 3796e-6, Fp = an(3) / 2, jG = 12;
function wD(e, t) {
  var n = An(Fp * ne(t)), i = n * n, r = i * i * i;
  return [
    e * oe(n) / (Fp * (Dc + 3 * Rc * i + r * (7 * Lc + 9 * Ic * i))),
    n * (Dc + Rc * i + r * (Lc + Ic * i))
  ];
}
wD.invert = function(e, t) {
  for (var n = t, i = n * n, r = i * i * i, o = 0, a, s, u; o < jG && (s = n * (Dc + Rc * i + r * (Lc + Ic * i)) - t, u = Dc + 3 * Rc * i + r * (7 * Lc + 9 * Ic * i), n -= a = s / u, i = n * n, r = i * i * i, !(be(a) < op)); ++o)
    ;
  return [
    Fp * e * (Dc + 3 * Rc * i + r * (7 * Lc + 9 * Ic * i)) / oe(n),
    An(ne(n) / Fp)
  ];
};
function UG() {
  return $r(wD).scale(177.158);
}
function ED(e, t) {
  var n = oe(t), i = oe(e) * n;
  return [n * ne(e) / i, ne(t) / i];
}
ED.invert = Hf(xl);
function qG() {
  return $r(ED).scale(144.049).clipAngle(60);
}
function WG() {
  var e = 1, t = 0, n = 0, i = 1, r = 1, o = 0, a, s, u = null, l, c, f, d = 1, h = 1, p = rm({
    point: function(x, E) {
      var _ = b([x, E]);
      this.stream.point(_[0], _[1]);
    }
  }), g = of, m, y;
  function v() {
    return d = e * i, h = e * r, m = y = null, b;
  }
  function b(x) {
    var E = x[0] * d, _ = x[1] * h;
    if (o) {
      var w = _ * a - E * s;
      E = E * a + _ * s, _ = w;
    }
    return [E + t, _ + n];
  }
  return b.invert = function(x) {
    var E = x[0] - t, _ = x[1] - n;
    if (o) {
      var w = _ * a + E * s;
      E = E * a - _ * s, _ = w;
    }
    return [E / d, _ / h];
  }, b.stream = function(x) {
    return m && y === x ? m : m = p(g(y = x));
  }, b.postclip = function(x) {
    return arguments.length ? (g = x, u = l = c = f = null, v()) : g;
  }, b.clipExtent = function(x) {
    return arguments.length ? (g = x == null ? (u = l = c = f = null, of) : nD(u = +x[0][0], l = +x[0][1], c = +x[1][0], f = +x[1][1]), v()) : u == null ? null : [[u, l], [c, f]];
  }, b.scale = function(x) {
    return arguments.length ? (e = +x, v()) : e;
  }, b.translate = function(x) {
    return arguments.length ? (t = +x[0], n = +x[1], v()) : [t, n];
  }, b.angle = function(x) {
    return arguments.length ? (o = x % 360 * he, s = ne(o), a = oe(o), v()) : o * et;
  }, b.reflectX = function(x) {
    return arguments.length ? (i = x ? -1 : 1, v()) : i < 0;
  }, b.reflectY = function(x) {
    return arguments.length ? (r = x ? -1 : 1, v()) : r < 0;
  }, b.fitExtent = function(x, E) {
    return om(b, x, E);
  }, b.fitSize = function(x, E) {
    return U2(b, x, E);
  }, b.fitWidth = function(x, E) {
    return q2(b, x, E);
  }, b.fitHeight = function(x, E) {
    return W2(b, x, E);
  }, b;
}
function _D(e, t) {
  var n = t * t, i = n * n;
  return [
    e * (0.8707 - 0.131979 * n + i * (-0.013791 + i * (3971e-6 * n - 1529e-6 * i))),
    t * (1.007226 + n * (0.015085 + i * (-0.044475 + 0.028874 * n - 5916e-6 * i)))
  ];
}
_D.invert = function(e, t) {
  var n = t, i = 25, r;
  do {
    var o = n * n, a = o * o;
    n -= r = (n * (1.007226 + o * (0.015085 + a * (-0.044475 + 0.028874 * o - 5916e-6 * a))) - t) / (1.007226 + o * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * o - 5916e-6 * 11 * a)));
  } while (be(r) > re && --i > 0);
  return [
    e / (0.8707 + (o = n * n) * (-0.131979 + o * (-0.013791 + o * o * o * (3971e-6 - 1529e-6 * o)))),
    n
  ];
};
function GG() {
  return $r(_D).scale(175.295);
}
function SD(e, t) {
  return [oe(t) * ne(e), ne(t)];
}
SD.invert = Hf(An);
function HG() {
  return $r(SD).scale(249.5).clipAngle(90 + re);
}
function AD(e, t) {
  var n = oe(t), i = 1 + oe(e) * n;
  return [n * ne(e) / i, ne(t) / i];
}
AD.invert = Hf(function(e) {
  return 2 * xl(e);
});
function YG() {
  return $r(AD).scale(250).clipAngle(142);
}
function $D(e, t) {
  return [sp(z2((Qe + t) / 2)), -e];
}
$D.invert = function(e, t) {
  return [-t, 2 * xl(BN(e)) - Qe];
};
function XG() {
  var e = xD($D), t = e.center, n = e.rotate;
  return e.center = function(i) {
    return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
  }, e.rotate = function(i) {
    return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
  }, n([0, 0, 90]).scale(159.155);
}
var VG = Math.abs, tv = Math.cos, Mp = Math.sin, KG = 1e-6, kD = Math.PI, nv = kD / 2, a$ = JG(2);
function s$(e) {
  return e > 1 ? nv : e < -1 ? -nv : Math.asin(e);
}
function JG(e) {
  return e > 0 ? Math.sqrt(e) : 0;
}
function QG(e, t) {
  var n = e * Mp(t), i = 30, r;
  do
    t -= r = (t + Mp(t) - n) / (1 + tv(t));
  while (VG(r) > KG && --i > 0);
  return t / 2;
}
function ZG(e, t, n) {
  function i(r, o) {
    return [e * r * tv(o = QG(n, o)), t * Mp(o)];
  }
  return i.invert = function(r, o) {
    return o = s$(o / t), [r / (e * tv(o)), s$((2 * o + Mp(2 * o)) / n)];
  }, i;
}
var eH = ZG(a$ / nv, a$, kD);
function tH() {
  return $r(eH).scale(169.529);
}
const nH = pD(), iv = [
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function iH(e, t) {
  return function n() {
    const i = t();
    return i.type = e, i.path = pD().projection(i), i.copy = i.copy || function() {
      const r = n();
      return iv.forEach((o) => {
        i[o] && r[o](i[o]());
      }), r.path.pointRadius(i.path.pointRadius()), r;
    }, V3(i);
  };
}
function H2(e, t) {
  if (!e || typeof e != "string")
    throw new Error("Projection type must be a name string.");
  return e = e.toLowerCase(), arguments.length > 1 ? (Tp[e] = iH(e, t), this) : Tp[e] || null;
}
function CD(e) {
  return e && e.path || nH;
}
const Tp = {
  albers: mD,
  albersusa: OG,
  azimuthalequalarea: NG,
  azimuthalequidistant: DG,
  conicconformal: IG,
  conicequalarea: kp,
  conicequidistant: BG,
  equalEarth: UG,
  equirectangular: PG,
  gnomonic: qG,
  identity: WG,
  mercator: RG,
  mollweide: tH,
  naturalEarth1: GG,
  orthographic: HG,
  stereographic: YG,
  transversemercator: XG
};
for (const e in Tp)
  H2(e, Tp[e]);
function rH() {
}
const Rr = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function FD() {
  var e = 1, t = 1, n = s;
  function i(u, l) {
    return l.map((c) => r(u, c));
  }
  function r(u, l) {
    var c = [], f = [];
    return o(u, l, (d) => {
      n(d, u, l), oH(d) > 0 ? c.push([d]) : f.push(d);
    }), f.forEach((d) => {
      for (var h = 0, p = c.length, g; h < p; ++h)
        if (aH((g = c[h])[0], d) !== -1) {
          g.push(d);
          return;
        }
    }), {
      type: "MultiPolygon",
      value: l,
      coordinates: c
    };
  }
  function o(u, l, c) {
    var f = new Array(), d = new Array(), h, p, g, m, y, v;
    for (h = p = -1, m = u[0] >= l, Rr[m << 1].forEach(b); ++h < e - 1; )
      g = m, m = u[h + 1] >= l, Rr[g | m << 1].forEach(b);
    for (Rr[m << 0].forEach(b); ++p < t - 1; ) {
      for (h = -1, m = u[p * e + e] >= l, y = u[p * e] >= l, Rr[m << 1 | y << 2].forEach(b); ++h < e - 1; )
        g = m, m = u[p * e + e + h + 1] >= l, v = y, y = u[p * e + h + 1] >= l, Rr[g | m << 1 | y << 2 | v << 3].forEach(b);
      Rr[m | y << 3].forEach(b);
    }
    for (h = -1, y = u[p * e] >= l, Rr[y << 2].forEach(b); ++h < e - 1; )
      v = y, y = u[p * e + h + 1] >= l, Rr[y << 2 | v << 3].forEach(b);
    Rr[y << 3].forEach(b);
    function b(x) {
      var E = [x[0][0] + h, x[0][1] + p], _ = [x[1][0] + h, x[1][1] + p], w = a(E), S = a(_), C, $;
      (C = d[w]) ? ($ = f[S]) ? (delete d[C.end], delete f[$.start], C === $ ? (C.ring.push(_), c(C.ring)) : f[C.start] = d[$.end] = {
        start: C.start,
        end: $.end,
        ring: C.ring.concat($.ring)
      }) : (delete d[C.end], C.ring.push(_), d[C.end = S] = C) : (C = f[S]) ? ($ = d[w]) ? (delete f[C.start], delete d[$.end], C === $ ? (C.ring.push(_), c(C.ring)) : f[$.start] = d[C.end] = {
        start: $.start,
        end: C.end,
        ring: $.ring.concat(C.ring)
      }) : (delete f[C.start], C.ring.unshift(E), f[C.start = w] = C) : f[w] = d[S] = {
        start: w,
        end: S,
        ring: [E, _]
      };
    }
  }
  function a(u) {
    return u[0] * 2 + u[1] * (e + 1) * 4;
  }
  function s(u, l, c) {
    u.forEach((f) => {
      var d = f[0], h = f[1], p = d | 0, g = h | 0, m, y = l[g * e + p];
      d > 0 && d < e && p === d && (m = l[g * e + p - 1], f[0] = d + (c - m) / (y - m) - 0.5), h > 0 && h < t && g === h && (m = l[(g - 1) * e + p], f[1] = h + (c - m) / (y - m) - 0.5);
    });
  }
  return i.contour = r, i.size = function(u) {
    if (!arguments.length)
      return [e, t];
    var l = Math.floor(u[0]), c = Math.floor(u[1]);
    return l >= 0 && c >= 0 || I("invalid size"), e = l, t = c, i;
  }, i.smooth = function(u) {
    return arguments.length ? (n = u ? s : rH, i) : n === s;
  }, i;
}
function oH(e) {
  for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; )
    i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
  return i;
}
function aH(e, t) {
  for (var n = -1, i = t.length, r; ++n < i; )
    if (r = sH(e, t[n]))
      return r;
  return 0;
}
function sH(e, t) {
  for (var n = t[0], i = t[1], r = -1, o = 0, a = e.length, s = a - 1; o < a; s = o++) {
    var u = e[o], l = u[0], c = u[1], f = e[s], d = f[0], h = f[1];
    if (uH(u, f, t))
      return 0;
    c > i != h > i && n < (d - l) * (i - c) / (h - c) + l && (r = -r);
  }
  return r;
}
function uH(e, t, n) {
  var i;
  return lH(e, t, n) && cH(e[i = +(e[0] === t[0])], n[i], t[i]);
}
function lH(e, t, n) {
  return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
}
function cH(e, t, n) {
  return e <= t && t <= n || n <= t && t <= e;
}
function MD(e, t, n) {
  return function(i) {
    var r = hr(i), o = n ? Math.min(r[0], 0) : r[0], a = r[1], s = a - o, u = t ? Ho(o, a, e) : s / (e + 1);
    return Pn(o + u, a, u);
  };
}
function Y2(e) {
  D.call(this, null, e);
}
Y2.Definition = {
  type: "Isocontour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "levels",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "zero",
    type: "boolean",
    default: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }, {
    name: "scale",
    type: "number",
    expr: !0
  }, {
    name: "translate",
    type: "number",
    array: !0,
    expr: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    default: "contour"
  }]
};
G(Y2, D, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = e.field || Wt, o = FD().smooth(e.smooth !== !1), a = e.thresholds || fH(i, r, e), s = e.as === null ? null : e.as || "contour", u = [];
    return i.forEach((l) => {
      const c = r(l), f = o.size([c.width, c.height])(c.values, P(a) ? a : a(c.values));
      dH(f, c, l, e), f.forEach((d) => {
        u.push(_g(l, Ce(s != null ? {
          [s]: d
        } : d)));
      });
    }), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
  }
});
function fH(e, t, n) {
  const i = MD(n.levels || 10, n.nice, n.zero !== !1);
  return n.resolve !== "shared" ? i : i(e.map((r) => Ka(t(r).values)));
}
function dH(e, t, n, i) {
  let r = i.scale || t.scale, o = i.translate || t.translate;
  if (fe(r) && (r = r(n, i)), fe(o) && (o = o(n, i)), (r === 1 || r == null) && !o)
    return;
  const a = (Oe(r) ? r : r[0]) || 1, s = (Oe(r) ? r : r[1]) || 1, u = o && o[0] || 0, l = o && o[1] || 0;
  e.forEach(TD(t, a, s, u, l));
}
function TD(e, t, n, i, r) {
  const o = e.x1 || 0, a = e.y1 || 0, s = t * n < 0;
  function u(f) {
    f.forEach(l);
  }
  function l(f) {
    s && f.reverse(), f.forEach(c);
  }
  function c(f) {
    f[0] = (f[0] - o) * t + i, f[1] = (f[1] - a) * n + r;
  }
  return function(f) {
    return f.coordinates.forEach(u), f;
  };
}
function u$(e, t, n) {
  const i = e >= 0 ? e : Lb(t, n);
  return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2);
}
function V0(e) {
  return fe(e) ? e : Gt(+e);
}
function OD() {
  var e = (u) => u[0], t = (u) => u[1], n = ul, i = [-1, -1], r = 960, o = 500, a = 2;
  function s(u, l) {
    const c = u$(i[0], u, e) >> a, f = u$(i[1], u, t) >> a, d = c ? c + 2 : 0, h = f ? f + 2 : 0, p = 2 * d + (r >> a), g = 2 * h + (o >> a), m = new Float32Array(p * g), y = new Float32Array(p * g);
    let v = m;
    u.forEach((x) => {
      const E = d + (+e(x) >> a), _ = h + (+t(x) >> a);
      E >= 0 && E < p && _ >= 0 && _ < g && (m[E + _ * p] += +n(x));
    }), c > 0 && f > 0 ? (Ks(p, g, m, y, c), Js(p, g, y, m, f), Ks(p, g, m, y, c), Js(p, g, y, m, f), Ks(p, g, m, y, c), Js(p, g, y, m, f)) : c > 0 ? (Ks(p, g, m, y, c), Ks(p, g, y, m, c), Ks(p, g, m, y, c), v = y) : f > 0 && (Js(p, g, m, y, f), Js(p, g, y, m, f), Js(p, g, m, y, f), v = y);
    const b = l ? Math.pow(2, -2 * a) : 1 / ZF(v);
    for (let x = 0, E = p * g; x < E; ++x)
      v[x] *= b;
    return {
      values: v,
      scale: 1 << a,
      width: p,
      height: g,
      x1: d,
      y1: h,
      x2: d + (r >> a),
      y2: h + (o >> a)
    };
  }
  return s.x = function(u) {
    return arguments.length ? (e = V0(u), s) : e;
  }, s.y = function(u) {
    return arguments.length ? (t = V0(u), s) : t;
  }, s.weight = function(u) {
    return arguments.length ? (n = V0(u), s) : n;
  }, s.size = function(u) {
    if (!arguments.length)
      return [r, o];
    var l = +u[0], c = +u[1];
    return l >= 0 && c >= 0 || I("invalid size"), r = l, o = c, s;
  }, s.cellSize = function(u) {
    return arguments.length ? ((u = +u) >= 1 || I("invalid cell size"), a = Math.floor(Math.log(u) / Math.LN2), s) : 1 << a;
  }, s.bandwidth = function(u) {
    return arguments.length ? (u = X(u), u.length === 1 && (u = [+u[0], +u[0]]), u.length !== 2 && I("invalid bandwidth"), i = u, s) : i;
  }, s;
}
function Ks(e, t, n, i, r) {
  const o = (r << 1) + 1;
  for (let a = 0; a < t; ++a)
    for (let s = 0, u = 0; s < e + r; ++s)
      s < e && (u += n[s + a * e]), s >= r && (s >= o && (u -= n[s - o + a * e]), i[s - r + a * e] = u / Math.min(s + 1, e - 1 + o - s, o));
}
function Js(e, t, n, i, r) {
  const o = (r << 1) + 1;
  for (let a = 0; a < e; ++a)
    for (let s = 0, u = 0; s < t + r; ++s)
      s < t && (u += n[a + s * e]), s >= r && (s >= o && (u -= n[a + (s - o) * e]), i[a + (s - r) * e] = u / Math.min(s + 1, t - 1 + o - s, o));
}
function X2(e) {
  D.call(this, null, e);
}
X2.Definition = {
  type: "KDE2D",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: "grid"
  }]
};
const hH = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function ND(e, t) {
  return hH.forEach((n) => t[n] != null ? e[n](t[n]) : 0), e;
}
G(X2, D, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = pH(i, e.groupby), o = (e.groupby || []).map(Ze), a = ND(OD(), e), s = e.as || "grid", u = [];
    function l(c, f) {
      for (let d = 0; d < o.length; ++d)
        c[o[d]] = f[d];
      return c;
    }
    return u = r.map((c) => Ce(l({
      [s]: a(c, e.counts)
    }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
  }
});
function pH(e, t) {
  var n = [], i = (c) => c(s), r, o, a, s, u, l;
  if (t == null)
    n.push(e);
  else
    for (r = {}, o = 0, a = e.length; o < a; ++o)
      s = e[o], u = t.map(i), l = r[u], l || (r[u] = l = [], l.dims = u, n.push(l)), l.push(s);
  return n;
}
function V2(e) {
  D.call(this, null, e);
}
V2.Definition = {
  type: "Contour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "values",
    type: "number",
    array: !0
  }, {
    name: "x",
    type: "field"
  }, {
    name: "y",
    type: "field"
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number"
  }, {
    name: "count",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }]
};
G(V2, D, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = FD().smooth(e.smooth !== !1), r = e.values, o = e.thresholds || MD(e.count || 10, e.nice, !!r), a = e.size, s, u;
    return r || (r = t.materialize(t.SOURCE).source, s = ND(OD(), e)(r, !0), u = TD(s, s.scale || 1, s.scale || 1, 0, 0), a = [s.width, s.height], r = s.values), o = P(o) ? o : o(r), r = i.size(a)(r, o), u && r.forEach(u), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map(Ce), n;
  }
});
const rv = "Feature", K2 = "FeatureCollection", gH = "MultiPoint";
function J2(e) {
  D.call(this, null, e);
}
J2.Definition = {
  type: "GeoJSON",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    length: 2
  }, {
    name: "geojson",
    type: "field"
  }]
};
G(J2, D, {
  transform(e, t) {
    var n = this._features, i = this._points, r = e.fields, o = r && r[0], a = r && r[1], s = e.geojson || !r && Wt, u = t.ADD, l;
    l = e.modified() || t.changed(t.REM) || t.modified(Bt(s)) || o && t.modified(Bt(o)) || a && t.modified(Bt(a)), (!this.value || l) && (u = t.SOURCE, this._features = n = [], this._points = i = []), s && t.visit(u, (c) => n.push(s(c))), o && a && (t.visit(u, (c) => {
      var f = o(c), d = a(c);
      f != null && d != null && (f = +f) === f && (d = +d) === d && i.push([f, d]);
    }), n = n.concat({
      type: rv,
      geometry: {
        type: gH,
        coordinates: i
      }
    })), this.value = {
      type: K2,
      features: n
    };
  }
});
function Q2(e) {
  D.call(this, null, e);
}
Q2.Definition = {
  type: "GeoPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
G(Q2, D, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = this.value, r = e.field || Wt, o = e.as || "path", a = n.SOURCE;
    !i || e.modified() ? (this.value = i = CD(e.projection), n.materialize().reflow()) : a = r === Wt || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
    const s = mH(i, e.pointRadius);
    return n.visit(a, (u) => u[o] = i(r(u))), i.pointRadius(s), n.modifies(o);
  }
});
function mH(e, t) {
  const n = e.pointRadius();
  return e.context(null), t != null && e.pointRadius(t), n;
}
function Z2(e) {
  D.call(this, null, e);
}
Z2.Definition = {
  type: "GeoPoint",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection",
    required: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["x", "y"]
  }]
};
G(Z2, D, {
  transform(e, t) {
    var n = e.projection, i = e.fields[0], r = e.fields[1], o = e.as || ["x", "y"], a = o[0], s = o[1], u;
    function l(c) {
      const f = n([i(c), r(c)]);
      f ? (c[a] = f[0], c[s] = f[1]) : (c[a] = void 0, c[s] = void 0);
    }
    return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, l) : (u = t.modified(i.fields) || t.modified(r.fields), t.visit(u ? t.ADD_MOD : t.ADD, l)), t.modifies(o);
  }
});
function ew(e) {
  D.call(this, null, e);
}
ew.Definition = {
  type: "GeoShape",
  metadata: {
    modifies: !0,
    nomod: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field",
    default: "datum"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "shape"
  }]
};
G(ew, D, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = this.value, r = e.as || "shape", o = n.ADD;
    return (!i || e.modified()) && (this.value = i = yH(CD(e.projection), e.field || En("datum"), e.pointRadius), n.materialize().reflow(), o = n.SOURCE), n.visit(o, (a) => a[r] = i), n.modifies(r);
  }
});
function yH(e, t, n) {
  const i = n == null ? (r) => e(t(r)) : (r) => {
    var o = e.pointRadius(), a = e.pointRadius(n)(t(r));
    return e.pointRadius(o), a;
  };
  return i.context = (r) => (e.context(r), i), i;
}
function tw(e) {
  D.call(this, [], e), this.generator = cG();
}
tw.Definition = {
  type: "Graticule",
  metadata: {
    changes: !0,
    generates: !0
  },
  params: [{
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMajor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMinor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "step",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "stepMajor",
    type: "number",
    array: !0,
    length: 2,
    default: [90, 360]
  }, {
    name: "stepMinor",
    type: "number",
    array: !0,
    length: 2,
    default: [10, 10]
  }, {
    name: "precision",
    type: "number",
    default: 2.5
  }]
};
G(tw, D, {
  transform(e, t) {
    var n = this.value, i = this.generator, r;
    if (!n.length || e.modified())
      for (const o in e)
        fe(i[o]) && i[o](e[o]);
    return r = i(), n.length ? t.mod.push(XM(n[0], r)) : t.add.push(Ce(r)), n[0] = r, t;
  }
});
function nw(e) {
  D.call(this, null, e);
}
nw.Definition = {
  type: "heatmap",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "color",
    type: "string",
    expr: !0
  }, {
    name: "opacity",
    type: "number",
    expr: !0
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "as",
    type: "string",
    default: "image"
  }]
};
G(nw, D, {
  transform(e, t) {
    if (!t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.materialize(t.SOURCE).source, i = e.resolve === "shared", r = e.field || Wt, o = bH(e.opacity, e), a = vH(e.color, e), s = e.as || "image", u = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: i ? Ka(n.map((l) => Ka(r(l).values))) : 0
    };
    return n.forEach((l) => {
      const c = r(l), f = ce({}, l, u);
      i || (f.$max = Ka(c.values || [])), l[s] = xH(c, f, a.dep ? a : Gt(a(f)), o.dep ? o : Gt(o(f)));
    }), t.reflow(!0).modifies(s);
  }
});
function vH(e, t) {
  let n;
  return fe(e) ? (n = (i) => Vo(e(i, t)), n.dep = DD(e)) : n = Gt(Vo(e || "#888")), n;
}
function bH(e, t) {
  let n;
  return fe(e) ? (n = (i) => e(i, t), n.dep = DD(e)) : e ? n = Gt(e) : (n = (i) => i.$value / i.$max || 0, n.dep = !0), n;
}
function DD(e) {
  if (!fe(e))
    return !1;
  const t = Oi(Bt(e));
  return t.$x || t.$y || t.$value || t.$max;
}
function xH(e, t, n, i) {
  const r = e.width, o = e.height, a = e.x1 || 0, s = e.y1 || 0, u = e.x2 || r, l = e.y2 || o, c = e.values, f = c ? (m) => c[m] : Co, d = Uo(u - a, l - s), h = d.getContext("2d"), p = h.getImageData(0, 0, u - a, l - s), g = p.data;
  for (let m = s, y = 0; m < l; ++m) {
    t.$y = m - s;
    for (let v = a, b = m * r; v < u; ++v, y += 4) {
      t.$x = v - a, t.$value = f(v + b);
      const x = n(t);
      g[y + 0] = x.r, g[y + 1] = x.g, g[y + 2] = x.b, g[y + 3] = ~~(255 * i(t));
    }
  }
  return h.putImageData(p, 0, 0), d;
}
function RD(e) {
  D.call(this, null, e), this.modified(!0);
}
G(RD, D, {
  transform(e, t) {
    let n = this.value;
    return !n || e.modified("type") ? (this.value = n = EH(e.type), iv.forEach((i) => {
      e[i] != null && l$(n, i, e[i]);
    })) : iv.forEach((i) => {
      e.modified(i) && l$(n, i, e[i]);
    }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && wH(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function wH(e, t) {
  const n = _H(t.fit);
  t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n);
}
function EH(e) {
  const t = H2((e || "mercator").toLowerCase());
  return t || I("Unrecognized projection type: " + e), t();
}
function l$(e, t, n) {
  fe(e[t]) && e[t](n);
}
function _H(e) {
  return e = X(e), e.length === 1 ? e[0] : {
    type: K2,
    features: e.reduce((t, n) => t.concat(SH(n)), [])
  };
}
function SH(e) {
  return e.type === K2 ? e.features : X(e).filter((t) => t != null).map((t) => t.type === rv ? t : {
    type: rv,
    geometry: t
  });
}
const AH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contour: V2,
  geojson: J2,
  geopath: Q2,
  geopoint: Z2,
  geoshape: ew,
  graticule: tw,
  heatmap: nw,
  isocontour: Y2,
  kde2d: X2,
  projection: RD
}, Symbol.toStringTag, { value: "Module" }));
function $H(e, t) {
  var n, i = 1;
  e == null && (e = 0), t == null && (t = 0);
  function r() {
    var o, a = n.length, s, u = 0, l = 0;
    for (o = 0; o < a; ++o)
      s = n[o], u += s.x, l += s.y;
    for (u = (u / a - e) * i, l = (l / a - t) * i, o = 0; o < a; ++o)
      s = n[o], s.x -= u, s.y -= l;
  }
  return r.initialize = function(o) {
    n = o;
  }, r.x = function(o) {
    return arguments.length ? (e = +o, r) : e;
  }, r.y = function(o) {
    return arguments.length ? (t = +o, r) : t;
  }, r.strength = function(o) {
    return arguments.length ? (i = +o, r) : i;
  }, r;
}
function kH(e) {
  const t = +this._x.call(null, e), n = +this._y.call(null, e);
  return LD(this.cover(t, n), t, n, e);
}
function LD(e, t, n, i) {
  if (isNaN(t) || isNaN(n))
    return e;
  var r, o = e._root, a = { data: i }, s = e._x0, u = e._y0, l = e._x1, c = e._y1, f, d, h, p, g, m, y, v;
  if (!o)
    return e._root = a, e;
  for (; o.length; )
    if ((g = t >= (f = (s + l) / 2)) ? s = f : l = f, (m = n >= (d = (u + c) / 2)) ? u = d : c = d, r = o, !(o = o[y = m << 1 | g]))
      return r[y] = a, e;
  if (h = +e._x.call(null, o.data), p = +e._y.call(null, o.data), t === h && n === p)
    return a.next = o, r ? r[y] = a : e._root = a, e;
  do
    r = r ? r[y] = new Array(4) : e._root = new Array(4), (g = t >= (f = (s + l) / 2)) ? s = f : l = f, (m = n >= (d = (u + c) / 2)) ? u = d : c = d;
  while ((y = m << 1 | g) === (v = (p >= d) << 1 | h >= f));
  return r[v] = o, r[y] = a, e;
}
function CH(e) {
  var t, n, i = e.length, r, o, a = new Array(i), s = new Array(i), u = 1 / 0, l = 1 / 0, c = -1 / 0, f = -1 / 0;
  for (n = 0; n < i; ++n)
    isNaN(r = +this._x.call(null, t = e[n])) || isNaN(o = +this._y.call(null, t)) || (a[n] = r, s[n] = o, r < u && (u = r), r > c && (c = r), o < l && (l = o), o > f && (f = o));
  if (u > c || l > f)
    return this;
  for (this.cover(u, l).cover(c, f), n = 0; n < i; ++n)
    LD(this, a[n], s[n], e[n]);
  return this;
}
function FH(e, t) {
  if (isNaN(e = +e) || isNaN(t = +t))
    return this;
  var n = this._x0, i = this._y0, r = this._x1, o = this._y1;
  if (isNaN(n))
    r = (n = Math.floor(e)) + 1, o = (i = Math.floor(t)) + 1;
  else {
    for (var a = r - n || 1, s = this._root, u, l; n > e || e >= r || i > t || t >= o; )
      switch (l = (t < i) << 1 | e < n, u = new Array(4), u[l] = s, s = u, a *= 2, l) {
        case 0:
          r = n + a, o = i + a;
          break;
        case 1:
          n = r - a, o = i + a;
          break;
        case 2:
          r = n + a, i = o - a;
          break;
        case 3:
          n = r - a, i = o - a;
          break;
      }
    this._root && this._root.length && (this._root = s);
  }
  return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = o, this;
}
function MH() {
  var e = [];
  return this.visit(function(t) {
    if (!t.length)
      do
        e.push(t.data);
      while (t = t.next);
  }), e;
}
function TH(e) {
  return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function en(e, t, n, i, r) {
  this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r;
}
function OH(e, t, n) {
  var i, r = this._x0, o = this._y0, a, s, u, l, c = this._x1, f = this._y1, d = [], h = this._root, p, g;
  for (h && d.push(new en(h, r, o, c, f)), n == null ? n = 1 / 0 : (r = e - n, o = t - n, c = e + n, f = t + n, n *= n); p = d.pop(); )
    if (!(!(h = p.node) || (a = p.x0) > c || (s = p.y0) > f || (u = p.x1) < r || (l = p.y1) < o))
      if (h.length) {
        var m = (a + u) / 2, y = (s + l) / 2;
        d.push(
          new en(h[3], m, y, u, l),
          new en(h[2], a, y, m, l),
          new en(h[1], m, s, u, y),
          new en(h[0], a, s, m, y)
        ), (g = (t >= y) << 1 | e >= m) && (p = d[d.length - 1], d[d.length - 1] = d[d.length - 1 - g], d[d.length - 1 - g] = p);
      } else {
        var v = e - +this._x.call(null, h.data), b = t - +this._y.call(null, h.data), x = v * v + b * b;
        if (x < n) {
          var E = Math.sqrt(n = x);
          r = e - E, o = t - E, c = e + E, f = t + E, i = h.data;
        }
      }
  return i;
}
function NH(e) {
  if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e)))
    return this;
  var t, n = this._root, i, r, o, a = this._x0, s = this._y0, u = this._x1, l = this._y1, c, f, d, h, p, g, m, y;
  if (!n)
    return this;
  if (n.length)
    for (; ; ) {
      if ((p = c >= (d = (a + u) / 2)) ? a = d : u = d, (g = f >= (h = (s + l) / 2)) ? s = h : l = h, t = n, !(n = n[m = g << 1 | p]))
        return this;
      if (!n.length)
        break;
      (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m);
    }
  for (; n.data !== e; )
    if (r = n, !(n = n.next))
      return this;
  return (o = n.next) && delete n.next, r ? (o ? r.next = o : delete r.next, this) : t ? (o ? t[m] = o : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = o, this);
}
function DH(e) {
  for (var t = 0, n = e.length; t < n; ++t)
    this.remove(e[t]);
  return this;
}
function RH() {
  return this._root;
}
function LH() {
  var e = 0;
  return this.visit(function(t) {
    if (!t.length)
      do
        ++e;
      while (t = t.next);
  }), e;
}
function IH(e) {
  var t = [], n, i = this._root, r, o, a, s, u;
  for (i && t.push(new en(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop(); )
    if (!e(i = n.node, o = n.x0, a = n.y0, s = n.x1, u = n.y1) && i.length) {
      var l = (o + s) / 2, c = (a + u) / 2;
      (r = i[3]) && t.push(new en(r, l, c, s, u)), (r = i[2]) && t.push(new en(r, o, c, l, u)), (r = i[1]) && t.push(new en(r, l, a, s, c)), (r = i[0]) && t.push(new en(r, o, a, l, c));
    }
  return this;
}
function PH(e) {
  var t = [], n = [], i;
  for (this._root && t.push(new en(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop(); ) {
    var r = i.node;
    if (r.length) {
      var o, a = i.x0, s = i.y0, u = i.x1, l = i.y1, c = (a + u) / 2, f = (s + l) / 2;
      (o = r[0]) && t.push(new en(o, a, s, c, f)), (o = r[1]) && t.push(new en(o, c, s, u, f)), (o = r[2]) && t.push(new en(o, a, f, c, l)), (o = r[3]) && t.push(new en(o, c, f, u, l));
    }
    n.push(i);
  }
  for (; i = n.pop(); )
    e(i.node, i.x0, i.y0, i.x1, i.y1);
  return this;
}
function zH(e) {
  return e[0];
}
function BH(e) {
  return arguments.length ? (this._x = e, this) : this._x;
}
function jH(e) {
  return e[1];
}
function UH(e) {
  return arguments.length ? (this._y = e, this) : this._y;
}
function iw(e, t, n) {
  var i = new rw(t == null ? zH : t, n == null ? jH : n, NaN, NaN, NaN, NaN);
  return e == null ? i : i.addAll(e);
}
function rw(e, t, n, i, r, o) {
  this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = o, this._root = void 0;
}
function c$(e) {
  for (var t = { data: e.data }, n = t; e = e.next; )
    n = n.next = { data: e.data };
  return t;
}
var un = iw.prototype = rw.prototype;
un.copy = function() {
  var e = new rw(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t = this._root, n, i;
  if (!t)
    return e;
  if (!t.length)
    return e._root = c$(t), e;
  for (n = [{ source: t, target: e._root = new Array(4) }]; t = n.pop(); )
    for (var r = 0; r < 4; ++r)
      (i = t.source[r]) && (i.length ? n.push({ source: i, target: t.target[r] = new Array(4) }) : t.target[r] = c$(i));
  return e;
};
un.add = kH;
un.addAll = CH;
un.cover = FH;
un.data = MH;
un.extent = TH;
un.find = OH;
un.remove = NH;
un.removeAll = DH;
un.root = RH;
un.size = LH;
un.visit = IH;
un.visitAfter = PH;
un.x = BH;
un.y = UH;
function tn(e) {
  return function() {
    return e;
  };
}
function Lo(e) {
  return (e() - 0.5) * 1e-6;
}
function qH(e) {
  return e.x + e.vx;
}
function WH(e) {
  return e.y + e.vy;
}
function GH(e) {
  var t, n, i, r = 1, o = 1;
  typeof e != "function" && (e = tn(e == null ? 1 : +e));
  function a() {
    for (var l, c = t.length, f, d, h, p, g, m, y = 0; y < o; ++y)
      for (f = iw(t, qH, WH).visitAfter(s), l = 0; l < c; ++l)
        d = t[l], g = n[d.index], m = g * g, h = d.x + d.vx, p = d.y + d.vy, f.visit(v);
    function v(b, x, E, _, w) {
      var S = b.data, C = b.r, $ = g + C;
      if (S) {
        if (S.index > d.index) {
          var A = h - S.x - S.vx, M = p - S.y - S.vy, F = A * A + M * M;
          F < $ * $ && (A === 0 && (A = Lo(i), F += A * A), M === 0 && (M = Lo(i), F += M * M), F = ($ - (F = Math.sqrt(F))) / F * r, d.vx += (A *= F) * ($ = (C *= C) / (m + C)), d.vy += (M *= F) * $, S.vx -= A * ($ = 1 - $), S.vy -= M * $);
        }
        return;
      }
      return x > h + $ || _ < h - $ || E > p + $ || w < p - $;
    }
  }
  function s(l) {
    if (l.data)
      return l.r = n[l.data.index];
    for (var c = l.r = 0; c < 4; ++c)
      l[c] && l[c].r > l.r && (l.r = l[c].r);
  }
  function u() {
    if (!!t) {
      var l, c = t.length, f;
      for (n = new Array(c), l = 0; l < c; ++l)
        f = t[l], n[f.index] = +e(f, l, t);
    }
  }
  return a.initialize = function(l, c) {
    t = l, i = c, u();
  }, a.iterations = function(l) {
    return arguments.length ? (o = +l, a) : o;
  }, a.strength = function(l) {
    return arguments.length ? (r = +l, a) : r;
  }, a.radius = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : tn(+l), u(), a) : e;
  }, a;
}
function HH(e) {
  return e.index;
}
function f$(e, t) {
  var n = e.get(t);
  if (!n)
    throw new Error("node not found: " + t);
  return n;
}
function YH(e) {
  var t = HH, n = f, i, r = tn(30), o, a, s, u, l, c = 1;
  e == null && (e = []);
  function f(m) {
    return 1 / Math.min(s[m.source.index], s[m.target.index]);
  }
  function d(m) {
    for (var y = 0, v = e.length; y < c; ++y)
      for (var b = 0, x, E, _, w, S, C, $; b < v; ++b)
        x = e[b], E = x.source, _ = x.target, w = _.x + _.vx - E.x - E.vx || Lo(l), S = _.y + _.vy - E.y - E.vy || Lo(l), C = Math.sqrt(w * w + S * S), C = (C - o[b]) / C * m * i[b], w *= C, S *= C, _.vx -= w * ($ = u[b]), _.vy -= S * $, E.vx += w * ($ = 1 - $), E.vy += S * $;
  }
  function h() {
    if (!!a) {
      var m, y = a.length, v = e.length, b = new Map(a.map((E, _) => [t(E, _, a), E])), x;
      for (m = 0, s = new Array(y); m < v; ++m)
        x = e[m], x.index = m, typeof x.source != "object" && (x.source = f$(b, x.source)), typeof x.target != "object" && (x.target = f$(b, x.target)), s[x.source.index] = (s[x.source.index] || 0) + 1, s[x.target.index] = (s[x.target.index] || 0) + 1;
      for (m = 0, u = new Array(v); m < v; ++m)
        x = e[m], u[m] = s[x.source.index] / (s[x.source.index] + s[x.target.index]);
      i = new Array(v), p(), o = new Array(v), g();
    }
  }
  function p() {
    if (!!a)
      for (var m = 0, y = e.length; m < y; ++m)
        i[m] = +n(e[m], m, e);
  }
  function g() {
    if (!!a)
      for (var m = 0, y = e.length; m < y; ++m)
        o[m] = +r(e[m], m, e);
  }
  return d.initialize = function(m, y) {
    a = m, l = y, h();
  }, d.links = function(m) {
    return arguments.length ? (e = m, h(), d) : e;
  }, d.id = function(m) {
    return arguments.length ? (t = m, d) : t;
  }, d.iterations = function(m) {
    return arguments.length ? (c = +m, d) : c;
  }, d.strength = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : tn(+m), p(), d) : n;
  }, d.distance = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : tn(+m), g(), d) : r;
  }, d;
}
var XH = { value: () => {
} };
function ID() {
  for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
    if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i))
      throw new Error("illegal type: " + i);
    n[i] = [];
  }
  return new ph(n);
}
function ph(e) {
  this._ = e;
}
function VH(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var i = "", r = n.indexOf(".");
    if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: i };
  });
}
ph.prototype = ID.prototype = {
  constructor: ph,
  on: function(e, t) {
    var n = this._, i = VH(e + "", n), r, o = -1, a = i.length;
    if (arguments.length < 2) {
      for (; ++o < a; )
        if ((r = (e = i[o]).type) && (r = KH(n[r], e.name)))
          return r;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++o < a; )
      if (r = (e = i[o]).type)
        n[r] = d$(n[r], e.name, t);
      else if (t == null)
        for (r in n)
          n[r] = d$(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new ph(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0)
      for (var n = new Array(r), i = 0, r, o; i < r; ++i)
        n[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (o = this._[e], i = 0, r = o.length; i < r; ++i)
      o[i].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var i = this._[e], r = 0, o = i.length; r < o; ++r)
      i[r].value.apply(t, n);
  }
};
function KH(e, t) {
  for (var n = 0, i = e.length, r; n < i; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function d$(e, t, n) {
  for (var i = 0, r = e.length; i < r; ++i)
    if (e[i].name === t) {
      e[i] = XH, e = e.slice(0, i).concat(e.slice(i + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Wu = 0, wc = 0, Yl = 0, PD = 1e3, Op, Ec, Np = 0, fs = 0, sm = 0, sf = typeof performance == "object" && performance.now ? performance : Date, zD = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function ow() {
  return fs || (zD(JH), fs = sf.now() + sm);
}
function JH() {
  fs = 0;
}
function Dp() {
  this._call = this._time = this._next = null;
}
Dp.prototype = BD.prototype = {
  constructor: Dp,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? ow() : +n) + (t == null ? 0 : +t), !this._next && Ec !== this && (Ec ? Ec._next = this : Op = this, Ec = this), this._call = e, this._time = n, ov();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, ov());
  }
};
function BD(e, t, n) {
  var i = new Dp();
  return i.restart(e, t, n), i;
}
function QH() {
  ow(), ++Wu;
  for (var e = Op, t; e; )
    (t = fs - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Wu;
}
function h$() {
  fs = (Np = sf.now()) + sm, Wu = wc = 0;
  try {
    QH();
  } finally {
    Wu = 0, eY(), fs = 0;
  }
}
function ZH() {
  var e = sf.now(), t = e - Np;
  t > PD && (sm -= t, Np = e);
}
function eY() {
  for (var e, t = Op, n, i = 1 / 0; t; )
    t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Op = n);
  Ec = e, ov(i);
}
function ov(e) {
  if (!Wu) {
    wc && (wc = clearTimeout(wc));
    var t = e - fs;
    t > 24 ? (e < 1 / 0 && (wc = setTimeout(h$, e - sf.now() - sm)), Yl && (Yl = clearInterval(Yl))) : (Yl || (Np = sf.now(), Yl = setInterval(ZH, PD)), Wu = 1, zD(h$));
  }
}
function tY(e, t, n) {
  var i = new Dp(), r = t;
  return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(o, a, s) {
    a = +a, s = s == null ? ow() : +s, i._restart(function u(l) {
      l += r, i._restart(u, r += a, s), o(l);
    }, a, s);
  }, i.restart(e, t, n), i);
}
const nY = 1664525, iY = 1013904223, p$ = 4294967296;
function rY() {
  let e = 1;
  return () => (e = (nY * e + iY) % p$) / p$;
}
function oY(e) {
  return e.x;
}
function aY(e) {
  return e.y;
}
var sY = 10, uY = Math.PI * (3 - Math.sqrt(5));
function lY(e) {
  var t, n = 1, i = 1e-3, r = 1 - Math.pow(i, 1 / 300), o = 0, a = 0.6, s = /* @__PURE__ */ new Map(), u = BD(f), l = ID("tick", "end"), c = rY();
  e == null && (e = []);
  function f() {
    d(), l.call("tick", t), n < i && (u.stop(), l.call("end", t));
  }
  function d(g) {
    var m, y = e.length, v;
    g === void 0 && (g = 1);
    for (var b = 0; b < g; ++b)
      for (n += (o - n) * r, s.forEach(function(x) {
        x(n);
      }), m = 0; m < y; ++m)
        v = e[m], v.fx == null ? v.x += v.vx *= a : (v.x = v.fx, v.vx = 0), v.fy == null ? v.y += v.vy *= a : (v.y = v.fy, v.vy = 0);
    return t;
  }
  function h() {
    for (var g = 0, m = e.length, y; g < m; ++g) {
      if (y = e[g], y.index = g, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
        var v = sY * Math.sqrt(0.5 + g), b = g * uY;
        y.x = v * Math.cos(b), y.y = v * Math.sin(b);
      }
      (isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0);
    }
  }
  function p(g) {
    return g.initialize && g.initialize(e, c), g;
  }
  return h(), t = {
    tick: d,
    restart: function() {
      return u.restart(f), t;
    },
    stop: function() {
      return u.stop(), t;
    },
    nodes: function(g) {
      return arguments.length ? (e = g, h(), s.forEach(p), t) : e;
    },
    alpha: function(g) {
      return arguments.length ? (n = +g, t) : n;
    },
    alphaMin: function(g) {
      return arguments.length ? (i = +g, t) : i;
    },
    alphaDecay: function(g) {
      return arguments.length ? (r = +g, t) : +r;
    },
    alphaTarget: function(g) {
      return arguments.length ? (o = +g, t) : o;
    },
    velocityDecay: function(g) {
      return arguments.length ? (a = 1 - g, t) : 1 - a;
    },
    randomSource: function(g) {
      return arguments.length ? (c = g, s.forEach(p), t) : c;
    },
    force: function(g, m) {
      return arguments.length > 1 ? (m == null ? s.delete(g) : s.set(g, p(m)), t) : s.get(g);
    },
    find: function(g, m, y) {
      var v = 0, b = e.length, x, E, _, w, S;
      for (y == null ? y = 1 / 0 : y *= y, v = 0; v < b; ++v)
        w = e[v], x = g - w.x, E = m - w.y, _ = x * x + E * E, _ < y && (S = w, y = _);
      return S;
    },
    on: function(g, m) {
      return arguments.length > 1 ? (l.on(g, m), t) : l.on(g);
    }
  };
}
function cY() {
  var e, t, n, i, r = tn(-30), o, a = 1, s = 1 / 0, u = 0.81;
  function l(h) {
    var p, g = e.length, m = iw(e, oY, aY).visitAfter(f);
    for (i = h, p = 0; p < g; ++p)
      t = e[p], m.visit(d);
  }
  function c() {
    if (!!e) {
      var h, p = e.length, g;
      for (o = new Array(p), h = 0; h < p; ++h)
        g = e[h], o[g.index] = +r(g, h, e);
    }
  }
  function f(h) {
    var p = 0, g, m, y = 0, v, b, x;
    if (h.length) {
      for (v = b = x = 0; x < 4; ++x)
        (g = h[x]) && (m = Math.abs(g.value)) && (p += g.value, y += m, v += m * g.x, b += m * g.y);
      h.x = v / y, h.y = b / y;
    } else {
      g = h, g.x = g.data.x, g.y = g.data.y;
      do
        p += o[g.data.index];
      while (g = g.next);
    }
    h.value = p;
  }
  function d(h, p, g, m) {
    if (!h.value)
      return !0;
    var y = h.x - t.x, v = h.y - t.y, b = m - p, x = y * y + v * v;
    if (b * b / u < x)
      return x < s && (y === 0 && (y = Lo(n), x += y * y), v === 0 && (v = Lo(n), x += v * v), x < a && (x = Math.sqrt(a * x)), t.vx += y * h.value * i / x, t.vy += v * h.value * i / x), !0;
    if (h.length || x >= s)
      return;
    (h.data !== t || h.next) && (y === 0 && (y = Lo(n), x += y * y), v === 0 && (v = Lo(n), x += v * v), x < a && (x = Math.sqrt(a * x)));
    do
      h.data !== t && (b = o[h.data.index] * i / x, t.vx += y * b, t.vy += v * b);
    while (h = h.next);
  }
  return l.initialize = function(h, p) {
    e = h, n = p, c();
  }, l.strength = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : tn(+h), c(), l) : r;
  }, l.distanceMin = function(h) {
    return arguments.length ? (a = h * h, l) : Math.sqrt(a);
  }, l.distanceMax = function(h) {
    return arguments.length ? (s = h * h, l) : Math.sqrt(s);
  }, l.theta = function(h) {
    return arguments.length ? (u = h * h, l) : Math.sqrt(u);
  }, l;
}
function fY(e) {
  var t = tn(0.1), n, i, r;
  typeof e != "function" && (e = tn(e == null ? 0 : +e));
  function o(s) {
    for (var u = 0, l = n.length, c; u < l; ++u)
      c = n[u], c.vx += (r[u] - c.x) * i[u] * s;
  }
  function a() {
    if (!!n) {
      var s, u = n.length;
      for (i = new Array(u), r = new Array(u), s = 0; s < u; ++s)
        i[s] = isNaN(r[s] = +e(n[s], s, n)) ? 0 : +t(n[s], s, n);
    }
  }
  return o.initialize = function(s) {
    n = s, a();
  }, o.strength = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : tn(+s), a(), o) : t;
  }, o.x = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : tn(+s), a(), o) : e;
  }, o;
}
function dY(e) {
  var t = tn(0.1), n, i, r;
  typeof e != "function" && (e = tn(e == null ? 0 : +e));
  function o(s) {
    for (var u = 0, l = n.length, c; u < l; ++u)
      c = n[u], c.vy += (r[u] - c.y) * i[u] * s;
  }
  function a() {
    if (!!n) {
      var s, u = n.length;
      for (i = new Array(u), r = new Array(u), s = 0; s < u; ++s)
        i[s] = isNaN(r[s] = +e(n[s], s, n)) ? 0 : +t(n[s], s, n);
    }
  }
  return o.initialize = function(s) {
    n = s, a();
  }, o.strength = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : tn(+s), a(), o) : t;
  }, o.y = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : tn(+s), a(), o) : e;
  }, o;
}
const g$ = {
  center: $H,
  collide: GH,
  nbody: cY,
  link: YH,
  x: fY,
  y: dY
}, _c = "forces", av = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], hY = ["static", "iterations"], jD = ["x", "y", "vx", "vy"];
function aw(e) {
  D.call(this, null, e);
}
aw.Definition = {
  type: "Force",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "static",
    type: "boolean",
    default: !1
  }, {
    name: "restart",
    type: "boolean",
    default: !1
  }, {
    name: "iterations",
    type: "number",
    default: 300
  }, {
    name: "alpha",
    type: "number",
    default: 1
  }, {
    name: "alphaMin",
    type: "number",
    default: 1e-3
  }, {
    name: "alphaTarget",
    type: "number",
    default: 0
  }, {
    name: "velocityDecay",
    type: "number",
    default: 0.4
  }, {
    name: "forces",
    type: "param",
    array: !0,
    params: [{
      key: {
        force: "center"
      },
      params: [{
        name: "x",
        type: "number",
        default: 0
      }, {
        name: "y",
        type: "number",
        default: 0
      }]
    }, {
      key: {
        force: "collide"
      },
      params: [{
        name: "radius",
        type: "number",
        expr: !0
      }, {
        name: "strength",
        type: "number",
        default: 0.7
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "nbody"
      },
      params: [{
        name: "strength",
        type: "number",
        default: -30,
        expr: !0
      }, {
        name: "theta",
        type: "number",
        default: 0.9
      }, {
        name: "distanceMin",
        type: "number",
        default: 1
      }, {
        name: "distanceMax",
        type: "number"
      }]
    }, {
      key: {
        force: "link"
      },
      params: [{
        name: "links",
        type: "data"
      }, {
        name: "id",
        type: "field"
      }, {
        name: "distance",
        type: "number",
        default: 30,
        expr: !0
      }, {
        name: "strength",
        type: "number",
        expr: !0
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "x"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "x",
        type: "field"
      }]
    }, {
      key: {
        force: "y"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "y",
        type: "field"
      }]
    }]
  }, {
    name: "as",
    type: "string",
    array: !0,
    modify: !1,
    default: jD
  }]
};
G(aw, D, {
  transform(e, t) {
    var n = this.value, i = t.changed(t.ADD_REM), r = e.modified(av), o = e.iterations || 300;
    if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && UD(n, e, 0, t)) : (this.value = n = gY(t.source, e), n.on("tick", pY(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(hY) || t.changed() && e.restart) {
      if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / o)), e.static)
        for (n.stop(); --o >= 0; )
          n.tick();
      else if (n.stopped() && n.restart(), !i)
        return t.StopPropagation;
    }
    return this.finish(e, t);
  },
  finish(e, t) {
    const n = t.dataflow;
    for (let s = this._argops, u = 0, l = s.length, c; u < l; ++u)
      if (c = s[u], !(c.name !== _c || c.op._argval.force !== "link")) {
        for (var i = c.op._argops, r = 0, o = i.length, a; r < o; ++r)
          if (i[r].name === "links" && (a = i[r].op.source)) {
            n.pulse(a, n.changeset().reflow());
            break;
          }
      }
    return t.reflow(e.modified()).modifies(jD);
  }
});
function pY(e, t) {
  return () => e.touch(t).run();
}
function gY(e, t) {
  const n = lY(e), i = n.stop, r = n.restart;
  let o = !1;
  return n.stopped = () => o, n.restart = () => (o = !1, r()), n.stop = () => (o = !0, i()), UD(n, t, !0).on("end", () => o = !0);
}
function UD(e, t, n, i) {
  var r = X(t.forces), o, a, s, u;
  for (o = 0, a = av.length; o < a; ++o)
    s = av[o], s !== _c && t.modified(s) && e[s](t[s]);
  for (o = 0, a = r.length; o < a; ++o)
    u = _c + o, s = n || t.modified(_c, o) ? yY(r[o]) : i && mY(r[o], i) ? e.force(u) : null, s && e.force(u, s);
  for (a = e.numForces || 0; o < a; ++o)
    e.force(_c + o, null);
  return e.numForces = r.length, e;
}
function mY(e, t) {
  var n, i;
  for (n in e)
    if (fe(i = e[n]) && t.modified(Bt(i)))
      return 1;
  return 0;
}
function yY(e) {
  var t, n;
  ie(g$, e.force) || I("Unrecognized force: " + e.force), t = g$[e.force]();
  for (n in e)
    fe(t[n]) && vY(t[n], e[n], e);
  return t;
}
function vY(e, t, n) {
  e(fe(t) ? (i) => t(i, n) : t);
}
const bY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  force: aw
}, Symbol.toStringTag, { value: "Module" }));
function xY(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function wY(e) {
  return e.reduce(EY, 0) / e.length;
}
function EY(e, t) {
  return e + t.x;
}
function _Y(e) {
  return 1 + e.reduce(SY, 0);
}
function SY(e, t) {
  return Math.max(e, t.y);
}
function AY(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function $Y(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function kY() {
  var e = xY, t = 1, n = 1, i = !1;
  function r(o) {
    var a, s = 0;
    o.eachAfter(function(d) {
      var h = d.children;
      h ? (d.x = wY(h), d.y = _Y(h)) : (d.x = a ? s += e(d, a) : 0, d.y = 0, a = d);
    });
    var u = AY(o), l = $Y(o), c = u.x - e(u, l) / 2, f = l.x + e(l, u) / 2;
    return o.eachAfter(i ? function(d) {
      d.x = (d.x - o.x) * t, d.y = (o.y - d.y) * n;
    } : function(d) {
      d.x = (d.x - c) / (f - c) * t, d.y = (1 - (o.y ? d.y / o.y : 1)) * n;
    });
  }
  return r.separation = function(o) {
    return arguments.length ? (e = o, r) : e;
  }, r.size = function(o) {
    return arguments.length ? (i = !1, t = +o[0], n = +o[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(o) {
    return arguments.length ? (i = !0, t = +o[0], n = +o[1], r) : i ? [t, n] : null;
  }, r;
}
function CY(e) {
  var t = 0, n = e.children, i = n && n.length;
  if (!i)
    t = 1;
  else
    for (; --i >= 0; )
      t += n[i].value;
  e.value = t;
}
function FY() {
  return this.eachAfter(CY);
}
function MY(e, t) {
  let n = -1;
  for (const i of this)
    e.call(t, i, ++n, this);
  return this;
}
function TY(e, t) {
  for (var n = this, i = [n], r, o, a = -1; n = i.pop(); )
    if (e.call(t, n, ++a, this), r = n.children)
      for (o = r.length - 1; o >= 0; --o)
        i.push(r[o]);
  return this;
}
function OY(e, t) {
  for (var n = this, i = [n], r = [], o, a, s, u = -1; n = i.pop(); )
    if (r.push(n), o = n.children)
      for (a = 0, s = o.length; a < s; ++a)
        i.push(o[a]);
  for (; n = r.pop(); )
    e.call(t, n, ++u, this);
  return this;
}
function NY(e, t) {
  let n = -1;
  for (const i of this)
    if (e.call(t, i, ++n, this))
      return i;
}
function DY(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0; )
      n += i[r].value;
    t.value = n;
  });
}
function RY(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function LY(e) {
  for (var t = this, n = IY(t, e), i = [t]; t !== n; )
    t = t.parent, i.push(t);
  for (var r = i.length; e !== n; )
    i.splice(r, 0, e), e = e.parent;
  return i;
}
function IY(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), i = t.ancestors(), r = null;
  for (e = n.pop(), t = i.pop(); e === t; )
    r = e, e = n.pop(), t = i.pop();
  return r;
}
function PY() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function zY() {
  return Array.from(this);
}
function BY() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function jY() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* UY() {
  var e = this, t, n = [e], i, r, o;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, i = e.children)
        for (r = 0, o = i.length; r < o; ++r)
          n.push(i[r]);
  while (n.length);
}
function sw(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = GY)) : t === void 0 && (t = WY);
  for (var n = new Gu(e), i, r = [n], o, a, s, u; i = r.pop(); )
    if ((a = t(i.data)) && (u = (a = Array.from(a)).length))
      for (i.children = a, s = u - 1; s >= 0; --s)
        r.push(o = a[s] = new Gu(a[s])), o.parent = i, o.depth = i.depth + 1;
  return n.eachBefore(qD);
}
function qY() {
  return sw(this).eachBefore(HY);
}
function WY(e) {
  return e.children;
}
function GY(e) {
  return Array.isArray(e) ? e[1] : null;
}
function HY(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function qD(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function Gu(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
Gu.prototype = sw.prototype = {
  constructor: Gu,
  count: FY,
  each: MY,
  eachAfter: OY,
  eachBefore: TY,
  find: NY,
  sum: DY,
  sort: RY,
  path: LY,
  ancestors: PY,
  descendants: zY,
  leaves: BY,
  links: jY,
  copy: qY,
  [Symbol.iterator]: UY
};
function gh(e) {
  return e == null ? null : WD(e);
}
function WD(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
function ja() {
  return 0;
}
function au(e) {
  return function() {
    return e;
  };
}
const YY = 1664525, XY = 1013904223, m$ = 4294967296;
function VY() {
  let e = 1;
  return () => (e = (YY * e + XY) % m$) / m$;
}
function KY(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function JY(e, t) {
  let n = e.length, i, r;
  for (; n; )
    r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
  return e;
}
function QY(e, t) {
  for (var n = 0, i = (e = JY(Array.from(e), t)).length, r = [], o, a; n < i; )
    o = e[n], a && GD(a, o) ? ++n : (a = eX(r = ZY(r, o)), n = 0);
  return a;
}
function ZY(e, t) {
  var n, i;
  if (K0(t, e))
    return [t];
  for (n = 0; n < e.length; ++n)
    if (Dd(t, e[n]) && K0(Sc(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (i = n + 1; i < e.length; ++i)
      if (Dd(Sc(e[n], e[i]), t) && Dd(Sc(e[n], t), e[i]) && Dd(Sc(e[i], t), e[n]) && K0(HD(e[n], e[i], t), e))
        return [e[n], e[i], t];
  throw new Error();
}
function Dd(e, t) {
  var n = e.r - t.r, i = t.x - e.x, r = t.y - e.y;
  return n < 0 || n * n < i * i + r * r;
}
function GD(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, i = t.x - e.x, r = t.y - e.y;
  return n > 0 && n * n > i * i + r * r;
}
function K0(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!GD(e, t[n]))
      return !1;
  return !0;
}
function eX(e) {
  switch (e.length) {
    case 1:
      return tX(e[0]);
    case 2:
      return Sc(e[0], e[1]);
    case 3:
      return HD(e[0], e[1], e[2]);
  }
}
function tX(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function Sc(e, t) {
  var n = e.x, i = e.y, r = e.r, o = t.x, a = t.y, s = t.r, u = o - n, l = a - i, c = s - r, f = Math.sqrt(u * u + l * l);
  return {
    x: (n + o + u / f * c) / 2,
    y: (i + a + l / f * c) / 2,
    r: (f + r + s) / 2
  };
}
function HD(e, t, n) {
  var i = e.x, r = e.y, o = e.r, a = t.x, s = t.y, u = t.r, l = n.x, c = n.y, f = n.r, d = i - a, h = i - l, p = r - s, g = r - c, m = u - o, y = f - o, v = i * i + r * r - o * o, b = v - a * a - s * s + u * u, x = v - l * l - c * c + f * f, E = h * p - d * g, _ = (p * x - g * b) / (E * 2) - i, w = (g * m - p * y) / E, S = (h * b - d * x) / (E * 2) - r, C = (d * y - h * m) / E, $ = w * w + C * C - 1, A = 2 * (o + _ * w + S * C), M = _ * _ + S * S - o * o, F = -(Math.abs($) > 1e-6 ? (A + Math.sqrt(A * A - 4 * $ * M)) / (2 * $) : M / A);
  return {
    x: i + _ + w * F,
    y: r + S + C * F,
    r: F
  };
}
function y$(e, t, n) {
  var i = e.x - t.x, r, o, a = e.y - t.y, s, u, l = i * i + a * a;
  l ? (o = t.r + n.r, o *= o, u = e.r + n.r, u *= u, o > u ? (r = (l + u - o) / (2 * l), s = Math.sqrt(Math.max(0, u / l - r * r)), n.x = e.x - r * i - s * a, n.y = e.y - r * a + s * i) : (r = (l + o - u) / (2 * l), s = Math.sqrt(Math.max(0, o / l - r * r)), n.x = t.x + r * i - s * a, n.y = t.y + r * a + s * i)) : (n.x = t.x + n.r, n.y = t.y);
}
function v$(e, t) {
  var n = e.r + t.r - 1e-6, i = t.x - e.x, r = t.y - e.y;
  return n > 0 && n * n > i * i + r * r;
}
function b$(e) {
  var t = e._, n = e.next._, i = t.r + n.r, r = (t.x * n.r + n.x * t.r) / i, o = (t.y * n.r + n.y * t.r) / i;
  return r * r + o * o;
}
function Rd(e) {
  this._ = e, this.next = null, this.previous = null;
}
function nX(e, t) {
  if (!(o = (e = KY(e)).length))
    return 0;
  var n, i, r, o, a, s, u, l, c, f, d;
  if (n = e[0], n.x = 0, n.y = 0, !(o > 1))
    return n.r;
  if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(o > 2))
    return n.r + i.r;
  y$(i, n, r = e[2]), n = new Rd(n), i = new Rd(i), r = new Rd(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
  e:
    for (u = 3; u < o; ++u) {
      y$(n._, i._, r = e[u]), r = new Rd(r), l = i.next, c = n.previous, f = i._.r, d = n._.r;
      do
        if (f <= d) {
          if (v$(l._, r._)) {
            i = l, n.next = i, i.previous = n, --u;
            continue e;
          }
          f += l._.r, l = l.next;
        } else {
          if (v$(c._, r._)) {
            n = c, n.next = i, i.previous = n, --u;
            continue e;
          }
          d += c._.r, c = c.previous;
        }
      while (l !== c.next);
      for (r.previous = n, r.next = i, n.next = i.previous = i = r, a = b$(n); (r = r.next) !== i; )
        (s = b$(r)) < a && (n = r, a = s);
      i = n.next;
    }
  for (n = [i._], r = i; (r = r.next) !== i; )
    n.push(r._);
  for (r = QY(n, t), u = 0; u < o; ++u)
    n = e[u], n.x -= r.x, n.y -= r.y;
  return r.r;
}
function iX(e) {
  return Math.sqrt(e.value);
}
function rX() {
  var e = null, t = 1, n = 1, i = ja;
  function r(o) {
    const a = VY();
    return o.x = t / 2, o.y = n / 2, e ? o.eachBefore(x$(e)).eachAfter(J0(i, 0.5, a)).eachBefore(w$(1)) : o.eachBefore(x$(iX)).eachAfter(J0(ja, 1, a)).eachAfter(J0(i, o.r / Math.min(t, n), a)).eachBefore(w$(Math.min(t, n) / (2 * o.r))), o;
  }
  return r.radius = function(o) {
    return arguments.length ? (e = gh(o), r) : e;
  }, r.size = function(o) {
    return arguments.length ? (t = +o[0], n = +o[1], r) : [t, n];
  }, r.padding = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : au(+o), r) : i;
  }, r;
}
function x$(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function J0(e, t, n) {
  return function(i) {
    if (r = i.children) {
      var r, o, a = r.length, s = e(i) * t || 0, u;
      if (s)
        for (o = 0; o < a; ++o)
          r[o].r += s;
      if (u = nX(r, n), s)
        for (o = 0; o < a; ++o)
          r[o].r -= s;
      i.r = u + s;
    }
  };
}
function w$(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function YD(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function Yf(e, t, n, i, r) {
  for (var o = e.children, a, s = -1, u = o.length, l = e.value && (i - t) / e.value; ++s < u; )
    a = o[s], a.y0 = n, a.y1 = r, a.x0 = t, a.x1 = t += a.value * l;
}
function oX() {
  var e = 1, t = 1, n = 0, i = !1;
  function r(a) {
    var s = a.height + 1;
    return a.x0 = a.y0 = n, a.x1 = e, a.y1 = t / s, a.eachBefore(o(t, s)), i && a.eachBefore(YD), a;
  }
  function o(a, s) {
    return function(u) {
      u.children && Yf(u, u.x0, a * (u.depth + 1) / s, u.x1, a * (u.depth + 2) / s);
      var l = u.x0, c = u.y0, f = u.x1 - n, d = u.y1 - n;
      f < l && (l = f = (l + f) / 2), d < c && (c = d = (c + d) / 2), u.x0 = l, u.y0 = c, u.x1 = f, u.y1 = d;
    };
  }
  return r.round = function(a) {
    return arguments.length ? (i = !!a, r) : i;
  }, r.size = function(a) {
    return arguments.length ? (e = +a[0], t = +a[1], r) : [e, t];
  }, r.padding = function(a) {
    return arguments.length ? (n = +a, r) : n;
  }, r;
}
var aX = { depth: -1 }, E$ = {}, Q0 = {};
function sX(e) {
  return e.id;
}
function uX(e) {
  return e.parentId;
}
function _$() {
  var e = sX, t = uX, n;
  function i(r) {
    var o = Array.from(r), a = e, s = t, u, l, c, f, d, h, p, g, m = /* @__PURE__ */ new Map();
    if (n != null) {
      const y = o.map((x, E) => lX(n(x, E, r))), v = y.map(S$), b = new Set(y).add("");
      for (const x of v)
        b.has(x) || (b.add(x), y.push(x), v.push(S$(x)), o.push(Q0));
      a = (x, E) => y[E], s = (x, E) => v[E];
    }
    for (c = 0, u = o.length; c < u; ++c)
      l = o[c], h = o[c] = new Gu(l), (p = a(l, c, r)) != null && (p += "") && (g = h.id = p, m.set(g, m.has(g) ? E$ : h)), (p = s(l, c, r)) != null && (p += "") && (h.parent = p);
    for (c = 0; c < u; ++c)
      if (h = o[c], p = h.parent) {
        if (d = m.get(p), !d)
          throw new Error("missing: " + p);
        if (d === E$)
          throw new Error("ambiguous: " + p);
        d.children ? d.children.push(h) : d.children = [h], h.parent = d;
      } else {
        if (f)
          throw new Error("multiple roots");
        f = h;
      }
    if (!f)
      throw new Error("no root");
    if (n != null) {
      for (; f.data === Q0 && f.children.length === 1; )
        f = f.children[0], --u;
      for (let y = o.length - 1; y >= 0 && (h = o[y], h.data === Q0); --y)
        h.data = null;
    }
    if (f.parent = aX, f.eachBefore(function(y) {
      y.depth = y.parent.depth + 1, --u;
    }).eachBefore(qD), f.parent = null, u > 0)
      throw new Error("cycle");
    return f;
  }
  return i.id = function(r) {
    return arguments.length ? (e = gh(r), i) : e;
  }, i.parentId = function(r) {
    return arguments.length ? (t = gh(r), i) : t;
  }, i.path = function(r) {
    return arguments.length ? (n = gh(r), i) : n;
  }, i;
}
function lX(e) {
  e = `${e}`;
  let t = e.length;
  return sv(e, t - 1) && !sv(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
}
function S$(e) {
  let t = e.length;
  if (t < 2)
    return "";
  for (; --t > 1 && !sv(e, t); )
    ;
  return e.slice(0, t);
}
function sv(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if ((n & 1) === 0)
      return !0;
  }
  return !1;
}
function cX(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function Z0(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function e1(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function fX(e, t, n) {
  var i = n / (t.i - e.i);
  t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n;
}
function dX(e) {
  for (var t = 0, n = 0, i = e.children, r = i.length, o; --r >= 0; )
    o = i[r], o.z += t, o.m += t, t += o.s + (n += o.c);
}
function hX(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function mh(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
mh.prototype = Object.create(Gu.prototype);
function pX(e) {
  for (var t = new mh(e, 0), n, i = [t], r, o, a, s; n = i.pop(); )
    if (o = n._.children)
      for (n.children = new Array(s = o.length), a = s - 1; a >= 0; --a)
        i.push(r = n.children[a] = new mh(o[a], a)), r.parent = n;
  return (t.parent = new mh(null, 0)).children = [t], t;
}
function gX() {
  var e = cX, t = 1, n = 1, i = null;
  function r(l) {
    var c = pX(l);
    if (c.eachAfter(o), c.parent.m = -c.z, c.eachBefore(a), i)
      l.eachBefore(u);
    else {
      var f = l, d = l, h = l;
      l.eachBefore(function(v) {
        v.x < f.x && (f = v), v.x > d.x && (d = v), v.depth > h.depth && (h = v);
      });
      var p = f === d ? 1 : e(f, d) / 2, g = p - f.x, m = t / (d.x + p + g), y = n / (h.depth || 1);
      l.eachBefore(function(v) {
        v.x = (v.x + g) * m, v.y = v.depth * y;
      });
    }
    return l;
  }
  function o(l) {
    var c = l.children, f = l.parent.children, d = l.i ? f[l.i - 1] : null;
    if (c) {
      dX(l);
      var h = (c[0].z + c[c.length - 1].z) / 2;
      d ? (l.z = d.z + e(l._, d._), l.m = l.z - h) : l.z = h;
    } else
      d && (l.z = d.z + e(l._, d._));
    l.parent.A = s(l, d, l.parent.A || f[0]);
  }
  function a(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function s(l, c, f) {
    if (c) {
      for (var d = l, h = l, p = c, g = d.parent.children[0], m = d.m, y = h.m, v = p.m, b = g.m, x; p = e1(p), d = Z0(d), p && d; )
        g = Z0(g), h = e1(h), h.a = l, x = p.z + v - d.z - m + e(p._, d._), x > 0 && (fX(hX(p, l, f), l, x), m += x, y += x), v += p.m, m += d.m, b += g.m, y += h.m;
      p && !e1(h) && (h.t = p, h.m += v - y), d && !Z0(g) && (g.t = d, g.m += m - b, f = l);
    }
    return f;
  }
  function u(l) {
    l.x *= t, l.y = l.depth * n;
  }
  return r.separation = function(l) {
    return arguments.length ? (e = l, r) : e;
  }, r.size = function(l) {
    return arguments.length ? (i = !1, t = +l[0], n = +l[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(l) {
    return arguments.length ? (i = !0, t = +l[0], n = +l[1], r) : i ? [t, n] : null;
  }, r;
}
function um(e, t, n, i, r) {
  for (var o = e.children, a, s = -1, u = o.length, l = e.value && (r - n) / e.value; ++s < u; )
    a = o[s], a.x0 = t, a.x1 = i, a.y0 = n, a.y1 = n += a.value * l;
}
var XD = (1 + Math.sqrt(5)) / 2;
function VD(e, t, n, i, r, o) {
  for (var a = [], s = t.children, u, l, c = 0, f = 0, d = s.length, h, p, g = t.value, m, y, v, b, x, E, _; c < d; ) {
    h = r - n, p = o - i;
    do
      m = s[f++].value;
    while (!m && f < d);
    for (y = v = m, E = Math.max(p / h, h / p) / (g * e), _ = m * m * E, x = Math.max(v / _, _ / y); f < d; ++f) {
      if (m += l = s[f].value, l < y && (y = l), l > v && (v = l), _ = m * m * E, b = Math.max(v / _, _ / y), b > x) {
        m -= l;
        break;
      }
      x = b;
    }
    a.push(u = { value: m, dice: h < p, children: s.slice(c, f) }), u.dice ? Yf(u, n, i, r, g ? i += p * m / g : o) : um(u, n, i, g ? n += h * m / g : r, o), g -= m, c = f;
  }
  return a;
}
const KD = function e(t) {
  function n(i, r, o, a, s) {
    VD(t, i, r, o, a, s);
  }
  return n.ratio = function(i) {
    return e((i = +i) > 1 ? i : 1);
  }, n;
}(XD);
function mX() {
  var e = KD, t = !1, n = 1, i = 1, r = [0], o = ja, a = ja, s = ja, u = ja, l = ja;
  function c(d) {
    return d.x0 = d.y0 = 0, d.x1 = n, d.y1 = i, d.eachBefore(f), r = [0], t && d.eachBefore(YD), d;
  }
  function f(d) {
    var h = r[d.depth], p = d.x0 + h, g = d.y0 + h, m = d.x1 - h, y = d.y1 - h;
    m < p && (p = m = (p + m) / 2), y < g && (g = y = (g + y) / 2), d.x0 = p, d.y0 = g, d.x1 = m, d.y1 = y, d.children && (h = r[d.depth + 1] = o(d) / 2, p += l(d) - h, g += a(d) - h, m -= s(d) - h, y -= u(d) - h, m < p && (p = m = (p + m) / 2), y < g && (g = y = (g + y) / 2), e(d, p, g, m, y));
  }
  return c.round = function(d) {
    return arguments.length ? (t = !!d, c) : t;
  }, c.size = function(d) {
    return arguments.length ? (n = +d[0], i = +d[1], c) : [n, i];
  }, c.tile = function(d) {
    return arguments.length ? (e = WD(d), c) : e;
  }, c.padding = function(d) {
    return arguments.length ? c.paddingInner(d).paddingOuter(d) : c.paddingInner();
  }, c.paddingInner = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : au(+d), c) : o;
  }, c.paddingOuter = function(d) {
    return arguments.length ? c.paddingTop(d).paddingRight(d).paddingBottom(d).paddingLeft(d) : c.paddingTop();
  }, c.paddingTop = function(d) {
    return arguments.length ? (a = typeof d == "function" ? d : au(+d), c) : a;
  }, c.paddingRight = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : au(+d), c) : s;
  }, c.paddingBottom = function(d) {
    return arguments.length ? (u = typeof d == "function" ? d : au(+d), c) : u;
  }, c.paddingLeft = function(d) {
    return arguments.length ? (l = typeof d == "function" ? d : au(+d), c) : l;
  }, c;
}
function yX(e, t, n, i, r) {
  var o = e.children, a, s = o.length, u, l = new Array(s + 1);
  for (l[0] = u = a = 0; a < s; ++a)
    l[a + 1] = u += o[a].value;
  c(0, s, e.value, t, n, i, r);
  function c(f, d, h, p, g, m, y) {
    if (f >= d - 1) {
      var v = o[f];
      v.x0 = p, v.y0 = g, v.x1 = m, v.y1 = y;
      return;
    }
    for (var b = l[f], x = h / 2 + b, E = f + 1, _ = d - 1; E < _; ) {
      var w = E + _ >>> 1;
      l[w] < x ? E = w + 1 : _ = w;
    }
    x - l[E - 1] < l[E] - x && f + 1 < E && --E;
    var S = l[E] - b, C = h - S;
    if (m - p > y - g) {
      var $ = h ? (p * C + m * S) / h : m;
      c(f, E, S, p, g, $, y), c(E, d, C, $, g, m, y);
    } else {
      var A = h ? (g * C + y * S) / h : y;
      c(f, E, S, p, g, m, A), c(E, d, C, p, A, m, y);
    }
  }
}
function vX(e, t, n, i, r) {
  (e.depth & 1 ? um : Yf)(e, t, n, i, r);
}
const bX = function e(t) {
  function n(i, r, o, a, s) {
    if ((u = i._squarify) && u.ratio === t)
      for (var u, l, c, f, d = -1, h, p = u.length, g = i.value; ++d < p; ) {
        for (l = u[d], c = l.children, f = l.value = 0, h = c.length; f < h; ++f)
          l.value += c[f].value;
        l.dice ? Yf(l, r, o, a, g ? o += (s - o) * l.value / g : s) : um(l, r, o, g ? r += (a - r) * l.value / g : a, s), g -= l.value;
      }
    else
      i._squarify = u = VD(t, i, r, o, a, s), u.ratio = t;
  }
  return n.ratio = function(i) {
    return e((i = +i) > 1 ? i : 1);
  }, n;
}(XD);
function uv(e, t, n) {
  const i = {};
  return e.each((r) => {
    const o = r.data;
    n(o) && (i[t(o)] = r);
  }), e.lookup = i, e;
}
function uw(e) {
  D.call(this, null, e);
}
uw.Definition = {
  type: "Nest",
  metadata: {
    treesource: !0,
    changes: !0
  },
  params: [{
    name: "keys",
    type: "field",
    array: !0
  }, {
    name: "generate",
    type: "boolean"
  }]
};
const xX = (e) => e.values;
G(uw, D, {
  transform(e, t) {
    t.source || I("Nest transform requires an upstream data source.");
    var n = e.generate, i = e.modified(), r = t.clone(), o = this.value;
    return (!o || i || t.changed()) && (o && o.each((a) => {
      a.children && Eg(a.data) && r.rem.push(a.data);
    }), this.value = o = sw({
      values: X(e.keys).reduce((a, s) => (a.key(s), a), wX()).entries(r.source)
    }, xX), n && o.each((a) => {
      a.children && (a = Ce(a.data), r.add.push(a), r.source.push(a));
    }), uv(o, te, te)), r.source.root = o, r;
  }
});
function wX() {
  const e = [], t = {
    entries: (r) => i(n(r, 0), 0),
    key: (r) => (e.push(r), t)
  };
  function n(r, o) {
    if (o >= e.length)
      return r;
    const a = r.length, s = e[o++], u = {}, l = {};
    let c = -1, f, d, h;
    for (; ++c < a; )
      f = s(d = r[c]) + "", (h = u[f]) ? h.push(d) : u[f] = [d];
    for (f in u)
      l[f] = n(u[f], o);
    return l;
  }
  function i(r, o) {
    if (++o > e.length)
      return r;
    const a = [];
    for (const s in r)
      a.push({
        key: s,
        values: i(r[s], o)
      });
    return a;
  }
  return t;
}
function lo(e) {
  D.call(this, null, e);
}
const EX = (e, t) => e.parent === t.parent ? 1 : 2;
G(lo, D, {
  transform(e, t) {
    (!t.source || !t.source.root) && I(this.constructor.name + " transform requires a backing tree data source.");
    const n = this.layout(e.method), i = this.fields, r = t.source.root, o = e.as || i;
    e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(Fs(e.sort, (a) => a.data)), _X(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? EX : ul);
    try {
      this.value = n(r);
    } catch (a) {
      I(a);
    }
    return r.each((a) => SX(a, i, o)), t.reflow(e.modified()).modifies(o).modifies("leaf");
  }
});
function _X(e, t, n) {
  for (let i, r = 0, o = t.length; r < o; ++r)
    i = t[r], i in n && e[i](n[i]);
}
function SX(e, t, n) {
  const i = e.data, r = t.length - 1;
  for (let o = 0; o < r; ++o)
    i[n[o]] = e[t[o]];
  i[n[r]] = e.children ? e.children.length : 0;
}
const lv = ["x", "y", "r", "depth", "children"];
function lw(e) {
  lo.call(this, e);
}
lw.Definition = {
  type: "Pack",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "radius",
    type: "field",
    default: null
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: lv.length,
    default: lv
  }]
};
G(lw, lo, {
  layout: rX,
  params: ["radius", "size", "padding"],
  fields: lv
});
const cv = ["x0", "y0", "x1", "y1", "depth", "children"];
function cw(e) {
  lo.call(this, e);
}
cw.Definition = {
  type: "Partition",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: cv.length,
    default: cv
  }]
};
G(cw, lo, {
  layout: oX,
  params: ["size", "round", "padding"],
  fields: cv
});
function fw(e) {
  D.call(this, null, e);
}
fw.Definition = {
  type: "Stratify",
  metadata: {
    treesource: !0
  },
  params: [{
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "parentKey",
    type: "field",
    required: !0
  }]
};
G(fw, D, {
  transform(e, t) {
    t.source || I("Stratify transform requires an upstream data source.");
    let n = this.value;
    const i = e.modified(), r = t.fork(t.ALL).materialize(t.SOURCE), o = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
    return r.source = r.source.slice(), o && (n = r.source.length ? uv(_$().id(e.key).parentId(e.parentKey)(r.source), e.key, ei) : uv(_$()([{}]), e.key, e.key)), r.source.root = this.value = n, r;
  }
});
const A$ = {
  tidy: gX,
  cluster: kY
}, fv = ["x", "y", "depth", "children"];
function dw(e) {
  lo.call(this, e);
}
dw.Definition = {
  type: "Tree",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "tidy",
    values: ["tidy", "cluster"]
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "nodeSize",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "separation",
    type: "boolean",
    default: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: fv.length,
    default: fv
  }]
};
G(dw, lo, {
  layout(e) {
    const t = e || "tidy";
    if (ie(A$, t))
      return A$[t]();
    I("Unrecognized Tree layout method: " + t);
  },
  params: ["size", "nodeSize"],
  fields: fv
});
function hw(e) {
  D.call(this, [], e);
}
hw.Definition = {
  type: "TreeLinks",
  metadata: {
    tree: !0,
    generates: !0,
    changes: !0
  },
  params: []
};
G(hw, D, {
  transform(e, t) {
    const n = this.value, i = t.source && t.source.root, r = t.fork(t.NO_SOURCE), o = {};
    return i || I("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, (a) => o[te(a)] = 1), i.each((a) => {
      const s = a.data, u = a.parent && a.parent.data;
      u && o[te(s)] && o[te(u)] && r.add.push(Ce({
        source: u,
        target: s
      }));
    }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, (a) => o[te(a)] = 1), n.forEach((a) => {
      (o[te(a.source)] || o[te(a.target)]) && r.mod.push(a);
    })), r;
  }
});
const $$ = {
  binary: yX,
  dice: Yf,
  slice: um,
  slicedice: vX,
  squarify: KD,
  resquarify: bX
}, dv = ["x0", "y0", "x1", "y1", "depth", "children"];
function pw(e) {
  lo.call(this, e);
}
pw.Definition = {
  type: "Treemap",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "squarify",
    values: ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "paddingInner",
    type: "number",
    default: 0
  }, {
    name: "paddingOuter",
    type: "number",
    default: 0
  }, {
    name: "paddingTop",
    type: "number",
    default: 0
  }, {
    name: "paddingRight",
    type: "number",
    default: 0
  }, {
    name: "paddingBottom",
    type: "number",
    default: 0
  }, {
    name: "paddingLeft",
    type: "number",
    default: 0
  }, {
    name: "ratio",
    type: "number",
    default: 1.618033988749895
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: dv.length,
    default: dv
  }]
};
G(pw, lo, {
  layout() {
    const e = mX();
    return e.ratio = (t) => {
      const n = e.tile();
      n.ratio && e.tile(n.ratio(t));
    }, e.method = (t) => {
      ie($$, t) ? e.tile($$[t]) : I("Unrecognized Treemap layout method: " + t);
    }, e;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: dv
});
const AX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nest: uw,
  pack: lw,
  partition: cw,
  stratify: fw,
  tree: dw,
  treelinks: hw,
  treemap: pw
}, Symbol.toStringTag, { value: "Module" })), t1 = 4278190080;
function $X(e, t) {
  const n = e.bitmap();
  return (t || []).forEach((i) => n.set(e(i.boundary[0]), e(i.boundary[3]))), [n, void 0];
}
function kX(e, t, n, i, r) {
  const o = e.width, a = e.height, s = i || r, u = Uo(o, a).getContext("2d"), l = Uo(o, a).getContext("2d"), c = s && Uo(o, a).getContext("2d");
  n.forEach((S) => yh(u, S, !1)), yh(l, t, !1), s && yh(c, t, !0);
  const f = n1(u, o, a), d = n1(l, o, a), h = s && n1(c, o, a), p = e.bitmap(), g = s && e.bitmap();
  let m, y, v, b, x, E, _, w;
  for (y = 0; y < a; ++y)
    for (m = 0; m < o; ++m)
      x = y * o + m, E = f[x] & t1, w = d[x] & t1, _ = s && h[x] & t1, (E || _ || w) && (v = e(m), b = e(y), !r && (E || w) && p.set(v, b), s && (E || _) && g.set(v, b));
  return [p, g];
}
function n1(e, t, n) {
  return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer);
}
function yh(e, t, n) {
  if (!t.length)
    return;
  const i = t[0].mark.marktype;
  i === "group" ? t.forEach((r) => {
    r.items.forEach((o) => yh(e, o.items, n));
  }) : Un[i].draw(e, {
    items: n ? t.map(CX) : t
  });
}
function CX(e) {
  const t = _g(e, {});
  return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
    ...t,
    strokeOpacity: 1,
    stroke: "#000",
    fillOpacity: 0
  } : t;
}
const Lr = 5, Yt = 31, uf = 32, $o = new Uint32Array(uf + 1), mi = new Uint32Array(uf + 1);
mi[0] = 0;
$o[0] = ~mi[0];
for (let e = 1; e <= uf; ++e)
  mi[e] = mi[e - 1] << 1 | 1, $o[e] = ~mi[e];
function FX(e, t) {
  const n = new Uint32Array(~~((e * t + uf) / uf));
  function i(o, a) {
    n[o] |= a;
  }
  function r(o, a) {
    n[o] &= a;
  }
  return {
    array: n,
    get: (o, a) => {
      const s = a * e + o;
      return n[s >>> Lr] & 1 << (s & Yt);
    },
    set: (o, a) => {
      const s = a * e + o;
      i(s >>> Lr, 1 << (s & Yt));
    },
    clear: (o, a) => {
      const s = a * e + o;
      r(s >>> Lr, ~(1 << (s & Yt)));
    },
    getRange: (o, a, s, u) => {
      let l = u, c, f, d, h;
      for (; l >= a; --l)
        if (c = l * e + o, f = l * e + s, d = c >>> Lr, h = f >>> Lr, d === h) {
          if (n[d] & $o[c & Yt] & mi[(f & Yt) + 1])
            return !0;
        } else {
          if (n[d] & $o[c & Yt] || n[h] & mi[(f & Yt) + 1])
            return !0;
          for (let p = d + 1; p < h; ++p)
            if (n[p])
              return !0;
        }
      return !1;
    },
    setRange: (o, a, s, u) => {
      let l, c, f, d, h;
      for (; a <= u; ++a)
        if (l = a * e + o, c = a * e + s, f = l >>> Lr, d = c >>> Lr, f === d)
          i(f, $o[l & Yt] & mi[(c & Yt) + 1]);
        else
          for (i(f, $o[l & Yt]), i(d, mi[(c & Yt) + 1]), h = f + 1; h < d; ++h)
            i(h, 4294967295);
    },
    clearRange: (o, a, s, u) => {
      let l, c, f, d, h;
      for (; a <= u; ++a)
        if (l = a * e + o, c = a * e + s, f = l >>> Lr, d = c >>> Lr, f === d)
          r(f, mi[l & Yt] | $o[(c & Yt) + 1]);
        else
          for (r(f, mi[l & Yt]), r(d, $o[(c & Yt) + 1]), h = f + 1; h < d; ++h)
            r(h, 0);
    },
    outOfBounds: (o, a, s, u) => o < 0 || a < 0 || u >= t || s >= e
  };
}
function MX(e, t, n) {
  const i = Math.max(1, Math.sqrt(e * t / 1e6)), r = ~~((e + 2 * n + i) / i), o = ~~((t + 2 * n + i) / i), a = (s) => ~~((s + n) / i);
  return a.invert = (s) => s * i - n, a.bitmap = () => FX(r, o), a.ratio = i, a.padding = n, a.width = e, a.height = t, a;
}
function TX(e, t, n, i) {
  const r = e.width, o = e.height;
  return function(a) {
    const s = a.datum.datum.items[i].items, u = s.length, l = a.datum.fontSize, c = Ci.width(a.datum, a.datum.text);
    let f = 0, d, h, p, g, m, y, v;
    for (let b = 0; b < u; ++b)
      d = s[b].x, p = s[b].y, h = s[b].x2 === void 0 ? d : s[b].x2, g = s[b].y2 === void 0 ? p : s[b].y2, m = (d + h) / 2, y = (p + g) / 2, v = Math.abs(h - d + g - p), v >= f && (f = v, a.x = m, a.y = y);
    return m = c / 2, y = l / 2, d = a.x - m, h = a.x + m, p = a.y - y, g = a.y + y, a.align = "center", d < 0 && h <= r ? a.align = "left" : 0 <= d && r < h && (a.align = "right"), a.baseline = "middle", p < 0 && g <= o ? a.baseline = "top" : 0 <= p && o < g && (a.baseline = "bottom"), !0;
  };
}
function Rp(e, t, n, i, r, o) {
  let a = n / 2;
  return e - a < 0 || e + a > r || t - (a = i / 2) < 0 || t + a > o;
}
function Io(e, t, n, i, r, o, a, s) {
  const u = r * o / (i * 2), l = e(t - u), c = e(t + u), f = e(n - (o = o / 2)), d = e(n + o);
  return a.outOfBounds(l, f, c, d) || a.getRange(l, f, c, d) || s && s.getRange(l, f, c, d);
}
function OX(e, t, n, i) {
  const r = e.width, o = e.height, a = t[0], s = t[1];
  function u(l, c, f, d, h) {
    const p = e.invert(l), g = e.invert(c);
    let m = f, y = o, v;
    if (!Rp(p, g, d, h, r, o) && !Io(e, p, g, h, d, m, a, s) && !Io(e, p, g, h, d, h, a, null)) {
      for (; y - m >= 1; )
        v = (m + y) / 2, Io(e, p, g, h, d, v, a, s) ? y = v : m = v;
      if (m > f)
        return [p, g, m, !0];
    }
  }
  return function(l) {
    const c = l.datum.datum.items[i].items, f = c.length, d = l.datum.fontSize, h = Ci.width(l.datum, l.datum.text);
    let p = n ? d : 0, g = !1, m = !1, y = 0, v, b, x, E, _, w, S, C, $, A, M, F, O, k, T, N, L;
    for (let z = 0; z < f; ++z) {
      for (v = c[z].x, x = c[z].y, b = c[z].x2 === void 0 ? v : c[z].x2, E = c[z].y2 === void 0 ? x : c[z].y2, v > b && (L = v, v = b, b = L), x > E && (L = x, x = E, E = L), $ = e(v), M = e(b), A = ~~(($ + M) / 2), F = e(x), k = e(E), O = ~~((F + k) / 2), S = A; S >= $; --S)
        for (C = O; C >= F; --C)
          N = u(S, C, p, h, d), N && ([l.x, l.y, p, g] = N);
      for (S = A; S <= M; ++S)
        for (C = O; C <= k; ++C)
          N = u(S, C, p, h, d), N && ([l.x, l.y, p, g] = N);
      !g && !n && (T = Math.abs(b - v + E - x), _ = (v + b) / 2, w = (x + E) / 2, T >= y && !Rp(_, w, h, d, r, o) && !Io(e, _, w, d, h, d, a, null) && (y = T, l.x = _, l.y = w, m = !0));
    }
    return g || m ? (_ = h / 2, w = d / 2, a.setRange(e(l.x - _), e(l.y - w), e(l.x + _), e(l.y + w)), l.align = "center", l.baseline = "middle", !0) : !1;
  };
}
const NX = [-1, -1, 1, 1], DX = [-1, 1, -1, 1];
function RX(e, t, n, i) {
  const r = e.width, o = e.height, a = t[0], s = t[1], u = e.bitmap();
  return function(l) {
    const c = l.datum.datum.items[i].items, f = c.length, d = l.datum.fontSize, h = Ci.width(l.datum, l.datum.text), p = [];
    let g = n ? d : 0, m = !1, y = !1, v = 0, b, x, E, _, w, S, C, $, A, M, F, O;
    for (let k = 0; k < f; ++k) {
      for (b = c[k].x, E = c[k].y, x = c[k].x2 === void 0 ? b : c[k].x2, _ = c[k].y2 === void 0 ? E : c[k].y2, p.push([e((b + x) / 2), e((E + _) / 2)]); p.length; )
        if ([C, $] = p.pop(), !(a.get(C, $) || s.get(C, $) || u.get(C, $))) {
          u.set(C, $);
          for (let T = 0; T < 4; ++T)
            w = C + NX[T], S = $ + DX[T], u.outOfBounds(w, S, w, S) || p.push([w, S]);
          if (w = e.invert(C), S = e.invert($), A = g, M = o, !Rp(w, S, h, d, r, o) && !Io(e, w, S, d, h, A, a, s) && !Io(e, w, S, d, h, d, a, null)) {
            for (; M - A >= 1; )
              F = (A + M) / 2, Io(e, w, S, d, h, F, a, s) ? M = F : A = F;
            A > g && (l.x = w, l.y = S, g = A, m = !0);
          }
        }
      !m && !n && (O = Math.abs(x - b + _ - E), w = (b + x) / 2, S = (E + _) / 2, O >= v && !Rp(w, S, h, d, r, o) && !Io(e, w, S, d, h, d, a, null) && (v = O, l.x = w, l.y = S, y = !0));
    }
    return m || y ? (w = h / 2, S = d / 2, a.setRange(e(l.x - w), e(l.y - S), e(l.x + w), e(l.y + S)), l.align = "center", l.baseline = "middle", !0) : !1;
  };
}
const LX = ["right", "center", "left"], IX = ["bottom", "middle", "top"];
function PX(e, t, n, i) {
  const r = e.width, o = e.height, a = t[0], s = t[1], u = i.length;
  return function(l) {
    var M;
    const c = l.boundary, f = l.datum.fontSize;
    if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > o)
      return !1;
    let d = (M = l.textWidth) != null ? M : 0, h, p, g, m, y, v, b, x, E, _, w, S, C, $, A;
    for (let F = 0; F < u; ++F) {
      if (h = (n[F] & 3) - 1, p = (n[F] >>> 2 & 3) - 1, g = h === 0 && p === 0 || i[F] < 0, m = h && p ? Math.SQRT1_2 : 1, y = i[F] < 0 ? -1 : 1, v = c[1 + h] + i[F] * h * m, w = c[4 + p] + y * f * p / 2 + i[F] * p * m, x = w - f / 2, E = w + f / 2, S = e(v), $ = e(x), A = e(E), !d)
        if (k$(S, S, $, A, a, s, v, v, x, E, c, g))
          d = Ci.width(l.datum, l.datum.text);
        else
          continue;
      if (_ = v + y * d * h / 2, v = _ - d / 2, b = _ + d / 2, S = e(v), C = e(b), k$(S, C, $, A, a, s, v, b, x, E, c, g))
        return l.x = h ? h * y < 0 ? b : v : _, l.y = p ? p * y < 0 ? E : x : w, l.align = LX[h * y + 1], l.baseline = IX[p * y + 1], a.setRange(S, $, C, A), !0;
    }
    return !1;
  };
}
function k$(e, t, n, i, r, o, a, s, u, l, c, f) {
  return !(r.outOfBounds(e, n, t, i) || (f && o || r).getRange(e, n, t, i));
}
const i1 = 0, r1 = 4, o1 = 8, a1 = 0, s1 = 1, u1 = 2, zX = {
  "top-left": i1 + a1,
  top: i1 + s1,
  "top-right": i1 + u1,
  left: r1 + a1,
  middle: r1 + s1,
  right: r1 + u1,
  "bottom-left": o1 + a1,
  bottom: o1 + s1,
  "bottom-right": o1 + u1
}, BX = {
  naive: TX,
  "reduced-search": OX,
  floodfill: RX
};
function jX(e, t, n, i, r, o, a, s, u, l, c) {
  if (!e.length)
    return e;
  const f = Math.max(i.length, r.length), d = UX(i, f), h = qX(r, f), p = WX(e[0].datum), g = p === "group" && e[0].datum.items[u].marktype, m = g === "area", y = GX(p, g, s, u), v = l === null || l === 1 / 0, b = m && c === "naive";
  let x = -1, E = -1;
  const _ = e.map(($) => {
    const A = v ? Ci.width($, $.text) : void 0;
    return x = Math.max(x, A), E = Math.max(E, $.fontSize), {
      datum: $,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: y($),
      textWidth: A
    };
  });
  l = l === null || l === 1 / 0 ? Math.max(x, E) + Math.max(...i) : l;
  const w = MX(t[0], t[1], l);
  let S;
  if (!b) {
    n && _.sort((M, F) => n(M.datum, F.datum));
    let $ = !1;
    for (let M = 0; M < h.length && !$; ++M)
      $ = h[M] === 5 || d[M] < 0;
    const A = (p && a || m) && e.map((M) => M.datum);
    S = o.length || A ? kX(w, A || [], o, $, m) : $X(w, a && _);
  }
  const C = m ? BX[c](w, S, a, u) : PX(w, S, h, d);
  return _.forEach(($) => $.opacity = +C($)), _;
}
function UX(e, t) {
  const n = new Float64Array(t), i = e.length;
  for (let r = 0; r < i; ++r)
    n[r] = e[r] || 0;
  for (let r = i; r < t; ++r)
    n[r] = n[i - 1];
  return n;
}
function qX(e, t) {
  const n = new Int8Array(t), i = e.length;
  for (let r = 0; r < i; ++r)
    n[r] |= zX[e[r]];
  for (let r = i; r < t; ++r)
    n[r] = n[i - 1];
  return n;
}
function WX(e) {
  return e && e.mark && e.mark.marktype;
}
function GX(e, t, n, i) {
  const r = (o) => [o.x, o.x, o.x, o.y, o.y, o.y];
  return e ? e === "line" || e === "area" ? (o) => r(o.datum) : t === "line" ? (o) => {
    const a = o.datum.items[i].items;
    return r(a.length ? a[n === "start" ? 0 : a.length - 1] : {
      x: NaN,
      y: NaN
    });
  } : (o) => {
    const a = o.datum.bounds;
    return [a.x1, (a.x1 + a.x2) / 2, a.x2, a.y1, (a.y1 + a.y2) / 2, a.y2];
  } : r;
}
const hv = ["x", "y", "opacity", "align", "baseline"], JD = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function gw(e) {
  D.call(this, null, e);
}
gw.Definition = {
  type: "Label",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: !0,
    default: JD
  }, {
    name: "offset",
    type: "number",
    array: !0,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: !0
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: !0
  }, {
    name: "avoidMarks",
    type: "data",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: hv.length,
    default: hv
  }]
};
G(gw, D, {
  transform(e, t) {
    function n(o) {
      const a = e[o];
      return fe(a) && t.modified(a.fields);
    }
    const i = e.modified();
    if (!(i || t.changed(t.ADD_REM) || n("sort")))
      return;
    (!e.size || e.size.length !== 2) && I("Size parameter should be specified as a [width, height] array.");
    const r = e.as || hv;
    return jX(t.materialize(t.SOURCE).source || [], e.size, e.sort, X(e.offset == null ? 1 : e.offset), X(e.anchor || JD), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((o) => {
      const a = o.datum;
      a[r[0]] = o.x, a[r[1]] = o.y, a[r[2]] = o.opacity, a[r[3]] = o.align, a[r[4]] = o.baseline;
    }), t.reflow(i).modifies(r);
  }
});
const HX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label: gw
}, Symbol.toStringTag, { value: "Module" }));
function QD(e, t) {
  var n = [], i = function(c) {
    return c(s);
  }, r, o, a, s, u, l;
  if (t == null)
    n.push(e);
  else
    for (r = {}, o = 0, a = e.length; o < a; ++o)
      s = e[o], u = t.map(i), l = r[u], l || (r[u] = l = [], l.dims = u, n.push(l)), l.push(s);
  return n;
}
function mw(e) {
  D.call(this, null, e);
}
mw.Definition = {
  type: "Loess",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "bandwidth",
    type: "number",
    default: 0.3
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
G(mw, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = QD(i, e.groupby), o = (e.groupby || []).map(Ze), a = o.length, s = e.as || [Ze(e.x), Ze(e.y)], u = [];
      r.forEach((l) => {
        dT(l, e.x, e.y, e.bandwidth || 0.3).forEach((c) => {
          const f = {};
          for (let d = 0; d < a; ++d)
            f[o[d]] = l.dims[d];
          f[s[0]] = c[0], f[s[1]] = c[1], u.push(Ce(f));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = u;
    }
    return n;
  }
});
const pv = {
  constant: Xb,
  linear: Vb,
  log: uT,
  exp: lT,
  pow: cT,
  quad: Kb,
  poly: fT
}, YX = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
function yw(e) {
  D.call(this, null, e);
}
yw.Definition = {
  type: "Regression",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "linear",
    values: Object.keys(pv)
  }, {
    name: "order",
    type: "number",
    default: 3
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "params",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
G(yw, D, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = QD(i, e.groupby), o = (e.groupby || []).map(Ze), a = e.method || "linear", s = e.order == null ? 3 : e.order, u = YX(a, s), l = e.as || [Ze(e.x), Ze(e.y)], c = pv[a], f = [];
      let d = e.extent;
      ie(pv, a) || I("Invalid regression method: " + a), d != null && a === "log" && d[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), d = null), r.forEach((h) => {
        if (h.length <= u) {
          t.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const g = c(h, e.x, e.y, s);
        if (e.params) {
          f.push(Ce({
            keys: h.dims,
            coef: g.coef,
            rSquared: g.rSquared
          }));
          return;
        }
        const m = d || hr(h, e.x), y = (v) => {
          const b = {};
          for (let x = 0; x < o.length; ++x)
            b[o[x]] = h.dims[x];
          b[l[0]] = v[0], b[l[1]] = v[1], f.push(Ce(b));
        };
        a === "linear" || a === "constant" ? m.forEach((v) => y([v, g.predict(v)])) : Mg(g.predict, m, 25, 200).forEach(y);
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = f;
    }
    return n;
  }
});
const XX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loess: mw,
  regression: yw
}, Symbol.toStringTag, { value: "Module" })), Qr = 11102230246251565e-32, Ot = 134217729, VX = (3 + 8 * Qr) * Qr;
function l1(e, t, n, i, r) {
  let o, a, s, u, l = t[0], c = i[0], f = 0, d = 0;
  c > l == c > -l ? (o = l, l = t[++f]) : (o = c, c = i[++d]);
  let h = 0;
  if (f < e && d < n)
    for (c > l == c > -l ? (a = l + o, s = o - (a - l), l = t[++f]) : (a = c + o, s = o - (a - c), c = i[++d]), o = a, s !== 0 && (r[h++] = s); f < e && d < n; )
      c > l == c > -l ? (a = o + l, u = a - o, s = o - (a - u) + (l - u), l = t[++f]) : (a = o + c, u = a - o, s = o - (a - u) + (c - u), c = i[++d]), o = a, s !== 0 && (r[h++] = s);
  for (; f < e; )
    a = o + l, u = a - o, s = o - (a - u) + (l - u), l = t[++f], o = a, s !== 0 && (r[h++] = s);
  for (; d < n; )
    a = o + c, u = a - o, s = o - (a - u) + (c - u), c = i[++d], o = a, s !== 0 && (r[h++] = s);
  return (o !== 0 || h === 0) && (r[h++] = o), h;
}
function KX(e, t) {
  let n = t[0];
  for (let i = 1; i < e; i++)
    n += t[i];
  return n;
}
function Xf(e) {
  return new Float64Array(e);
}
const JX = (3 + 16 * Qr) * Qr, QX = (2 + 12 * Qr) * Qr, ZX = (9 + 64 * Qr) * Qr * Qr, Qs = Xf(4), C$ = Xf(8), F$ = Xf(12), M$ = Xf(16), Xt = Xf(4);
function eV(e, t, n, i, r, o, a) {
  let s, u, l, c, f, d, h, p, g, m, y, v, b, x, E, _, w, S;
  const C = e - r, $ = n - r, A = t - o, M = i - o;
  x = C * M, d = Ot * C, h = d - (d - C), p = C - h, d = Ot * M, g = d - (d - M), m = M - g, E = p * m - (x - h * g - p * g - h * m), _ = A * $, d = Ot * A, h = d - (d - A), p = A - h, d = Ot * $, g = d - (d - $), m = $ - g, w = p * m - (_ - h * g - p * g - h * m), y = E - w, f = E - y, Qs[0] = E - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - _, f = b - y, Qs[1] = b - (y + f) + (f - _), S = v + y, f = S - v, Qs[2] = v - (S - f) + (y - f), Qs[3] = S;
  let F = KX(4, Qs), O = QX * a;
  if (F >= O || -F >= O || (f = e - C, s = e - (C + f) + (f - r), f = n - $, l = n - ($ + f) + (f - r), f = t - A, u = t - (A + f) + (f - o), f = i - M, c = i - (M + f) + (f - o), s === 0 && u === 0 && l === 0 && c === 0) || (O = ZX * a + VX * Math.abs(F), F += C * c + M * s - (A * l + $ * u), F >= O || -F >= O))
    return F;
  x = s * M, d = Ot * s, h = d - (d - s), p = s - h, d = Ot * M, g = d - (d - M), m = M - g, E = p * m - (x - h * g - p * g - h * m), _ = u * $, d = Ot * u, h = d - (d - u), p = u - h, d = Ot * $, g = d - (d - $), m = $ - g, w = p * m - (_ - h * g - p * g - h * m), y = E - w, f = E - y, Xt[0] = E - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - _, f = b - y, Xt[1] = b - (y + f) + (f - _), S = v + y, f = S - v, Xt[2] = v - (S - f) + (y - f), Xt[3] = S;
  const k = l1(4, Qs, 4, Xt, C$);
  x = C * c, d = Ot * C, h = d - (d - C), p = C - h, d = Ot * c, g = d - (d - c), m = c - g, E = p * m - (x - h * g - p * g - h * m), _ = A * l, d = Ot * A, h = d - (d - A), p = A - h, d = Ot * l, g = d - (d - l), m = l - g, w = p * m - (_ - h * g - p * g - h * m), y = E - w, f = E - y, Xt[0] = E - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - _, f = b - y, Xt[1] = b - (y + f) + (f - _), S = v + y, f = S - v, Xt[2] = v - (S - f) + (y - f), Xt[3] = S;
  const T = l1(k, C$, 4, Xt, F$);
  x = s * c, d = Ot * s, h = d - (d - s), p = s - h, d = Ot * c, g = d - (d - c), m = c - g, E = p * m - (x - h * g - p * g - h * m), _ = u * l, d = Ot * u, h = d - (d - u), p = u - h, d = Ot * l, g = d - (d - l), m = l - g, w = p * m - (_ - h * g - p * g - h * m), y = E - w, f = E - y, Xt[0] = E - (y + f) + (f - w), v = x + y, f = v - x, b = x - (v - f) + (y - f), y = b - _, f = b - y, Xt[1] = b - (y + f) + (f - _), S = v + y, f = S - v, Xt[2] = v - (S - f) + (y - f), Xt[3] = S;
  const N = l1(T, F$, 4, Xt, M$);
  return M$[N - 1];
}
function Ld(e, t, n, i, r, o) {
  const a = (t - o) * (n - r), s = (e - r) * (i - o), u = a - s, l = Math.abs(a + s);
  return Math.abs(u) >= JX * l ? u : -eV(e, t, n, i, r, o, l);
}
const T$ = Math.pow(2, -52), Id = new Uint32Array(512);
class Lp {
  static from(t, n = oV, i = aV) {
    const r = t.length, o = new Float64Array(r * 2);
    for (let a = 0; a < r; a++) {
      const s = t[a];
      o[2 * a] = n(s), o[2 * a + 1] = i(s);
    }
    return new Lp(o);
  }
  constructor(t) {
    const n = t.length >> 1;
    if (n > 0 && typeof t[0] != "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const i = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: t, _hullPrev: n, _hullNext: i, _hullTri: r, _hullHash: o } = this, a = t.length >> 1;
    let s = 1 / 0, u = 1 / 0, l = -1 / 0, c = -1 / 0;
    for (let $ = 0; $ < a; $++) {
      const A = t[2 * $], M = t[2 * $ + 1];
      A < s && (s = A), M < u && (u = M), A > l && (l = A), M > c && (c = M), this._ids[$] = $;
    }
    const f = (s + l) / 2, d = (u + c) / 2;
    let h = 1 / 0, p, g, m;
    for (let $ = 0; $ < a; $++) {
      const A = c1(f, d, t[2 * $], t[2 * $ + 1]);
      A < h && (p = $, h = A);
    }
    const y = t[2 * p], v = t[2 * p + 1];
    h = 1 / 0;
    for (let $ = 0; $ < a; $++) {
      if ($ === p)
        continue;
      const A = c1(y, v, t[2 * $], t[2 * $ + 1]);
      A < h && A > 0 && (g = $, h = A);
    }
    let b = t[2 * g], x = t[2 * g + 1], E = 1 / 0;
    for (let $ = 0; $ < a; $++) {
      if ($ === p || $ === g)
        continue;
      const A = iV(y, v, b, x, t[2 * $], t[2 * $ + 1]);
      A < E && (m = $, E = A);
    }
    let _ = t[2 * m], w = t[2 * m + 1];
    if (E === 1 / 0) {
      for (let M = 0; M < a; M++)
        this._dists[M] = t[2 * M] - t[0] || t[2 * M + 1] - t[1];
      hu(this._ids, this._dists, 0, a - 1);
      const $ = new Uint32Array(a);
      let A = 0;
      for (let M = 0, F = -1 / 0; M < a; M++) {
        const O = this._ids[M];
        this._dists[O] > F && ($[A++] = O, F = this._dists[O]);
      }
      this.hull = $.subarray(0, A), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (Ld(y, v, b, x, _, w) < 0) {
      const $ = g, A = b, M = x;
      g = m, b = _, x = w, m = $, _ = A, w = M;
    }
    const S = rV(y, v, b, x, _, w);
    this._cx = S.x, this._cy = S.y;
    for (let $ = 0; $ < a; $++)
      this._dists[$] = c1(t[2 * $], t[2 * $ + 1], S.x, S.y);
    hu(this._ids, this._dists, 0, a - 1), this._hullStart = p;
    let C = 3;
    i[p] = n[m] = g, i[g] = n[p] = m, i[m] = n[g] = p, r[p] = 0, r[g] = 1, r[m] = 2, o.fill(-1), o[this._hashKey(y, v)] = p, o[this._hashKey(b, x)] = g, o[this._hashKey(_, w)] = m, this.trianglesLen = 0, this._addTriangle(p, g, m, -1, -1, -1);
    for (let $ = 0, A, M; $ < this._ids.length; $++) {
      const F = this._ids[$], O = t[2 * F], k = t[2 * F + 1];
      if ($ > 0 && Math.abs(O - A) <= T$ && Math.abs(k - M) <= T$ || (A = O, M = k, F === p || F === g || F === m))
        continue;
      let T = 0;
      for (let le = 0, Ee = this._hashKey(O, k); le < this._hashSize && (T = o[(Ee + le) % this._hashSize], !(T !== -1 && T !== i[T])); le++)
        ;
      T = n[T];
      let N = T, L;
      for (; L = i[N], Ld(O, k, t[2 * N], t[2 * N + 1], t[2 * L], t[2 * L + 1]) >= 0; )
        if (N = L, N === T) {
          N = -1;
          break;
        }
      if (N === -1)
        continue;
      let z = this._addTriangle(N, F, i[N], -1, -1, r[N]);
      r[F] = this._legalize(z + 2), r[N] = z, C++;
      let J = i[N];
      for (; L = i[J], Ld(O, k, t[2 * J], t[2 * J + 1], t[2 * L], t[2 * L + 1]) < 0; )
        z = this._addTriangle(J, F, L, r[F], -1, r[J]), r[F] = this._legalize(z + 2), i[J] = J, C--, J = L;
      if (N === T)
        for (; L = n[N], Ld(O, k, t[2 * L], t[2 * L + 1], t[2 * N], t[2 * N + 1]) < 0; )
          z = this._addTriangle(L, F, N, -1, r[N], r[L]), this._legalize(z + 2), r[L] = z, i[N] = N, C--, N = L;
      this._hullStart = n[F] = N, i[N] = n[J] = F, i[F] = J, o[this._hashKey(O, k)] = F, o[this._hashKey(t[2 * N], t[2 * N + 1])] = N;
    }
    this.hull = new Uint32Array(C);
    for (let $ = 0, A = this._hullStart; $ < C; $++)
      this.hull[$] = A, A = i[A];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, n) {
    return Math.floor(tV(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: n, _halfedges: i, coords: r } = this;
    let o = 0, a = 0;
    for (; ; ) {
      const s = i[t], u = t - t % 3;
      if (a = u + (t + 2) % 3, s === -1) {
        if (o === 0)
          break;
        t = Id[--o];
        continue;
      }
      const l = s - s % 3, c = u + (t + 1) % 3, f = l + (s + 2) % 3, d = n[a], h = n[t], p = n[c], g = n[f];
      if (nV(
        r[2 * d],
        r[2 * d + 1],
        r[2 * h],
        r[2 * h + 1],
        r[2 * p],
        r[2 * p + 1],
        r[2 * g],
        r[2 * g + 1]
      )) {
        n[t] = g, n[s] = d;
        const y = i[f];
        if (y === -1) {
          let b = this._hullStart;
          do {
            if (this._hullTri[b] === f) {
              this._hullTri[b] = t;
              break;
            }
            b = this._hullPrev[b];
          } while (b !== this._hullStart);
        }
        this._link(t, y), this._link(s, i[a]), this._link(a, f);
        const v = l + (s + 1) % 3;
        o < Id.length && (Id[o++] = v);
      } else {
        if (o === 0)
          break;
        t = Id[--o];
      }
    }
    return a;
  }
  _link(t, n) {
    this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
  }
  _addTriangle(t, n, i, r, o, a) {
    const s = this.trianglesLen;
    return this._triangles[s] = t, this._triangles[s + 1] = n, this._triangles[s + 2] = i, this._link(s, r), this._link(s + 1, o), this._link(s + 2, a), this.trianglesLen += 3, s;
  }
}
function tV(e, t) {
  const n = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - n : 1 + n) / 4;
}
function c1(e, t, n, i) {
  const r = e - n, o = t - i;
  return r * r + o * o;
}
function nV(e, t, n, i, r, o, a, s) {
  const u = e - a, l = t - s, c = n - a, f = i - s, d = r - a, h = o - s, p = u * u + l * l, g = c * c + f * f, m = d * d + h * h;
  return u * (f * m - g * h) - l * (c * m - g * d) + p * (c * h - f * d) < 0;
}
function iV(e, t, n, i, r, o) {
  const a = n - e, s = i - t, u = r - e, l = o - t, c = a * a + s * s, f = u * u + l * l, d = 0.5 / (a * l - s * u), h = (l * c - s * f) * d, p = (a * f - u * c) * d;
  return h * h + p * p;
}
function rV(e, t, n, i, r, o) {
  const a = n - e, s = i - t, u = r - e, l = o - t, c = a * a + s * s, f = u * u + l * l, d = 0.5 / (a * l - s * u), h = e + (l * c - s * f) * d, p = t + (a * f - u * c) * d;
  return { x: h, y: p };
}
function hu(e, t, n, i) {
  if (i - n <= 20)
    for (let r = n + 1; r <= i; r++) {
      const o = e[r], a = t[o];
      let s = r - 1;
      for (; s >= n && t[e[s]] > a; )
        e[s + 1] = e[s--];
      e[s + 1] = o;
    }
  else {
    const r = n + i >> 1;
    let o = n + 1, a = i;
    Xl(e, r, o), t[e[n]] > t[e[i]] && Xl(e, n, i), t[e[o]] > t[e[i]] && Xl(e, o, i), t[e[n]] > t[e[o]] && Xl(e, n, o);
    const s = e[o], u = t[s];
    for (; ; ) {
      do
        o++;
      while (t[e[o]] < u);
      do
        a--;
      while (t[e[a]] > u);
      if (a < o)
        break;
      Xl(e, o, a);
    }
    e[n + 1] = e[a], e[a] = s, i - o + 1 >= a - n ? (hu(e, t, o, i), hu(e, t, n, a - 1)) : (hu(e, t, n, a - 1), hu(e, t, o, i));
  }
}
function Xl(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function oV(e) {
  return e[0];
}
function aV(e) {
  return e[1];
}
const O$ = 1e-6;
class Ha {
  constructor() {
    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, n) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, n) {
    this._ += `L${this._x1 = +t},${this._y1 = +n}`;
  }
  arc(t, n, i) {
    t = +t, n = +n, i = +i;
    const r = t + i, o = n;
    if (i < 0)
      throw new Error("negative radius");
    this._x1 === null ? this._ += `M${r},${o}` : (Math.abs(this._x1 - r) > O$ || Math.abs(this._y1 - o) > O$) && (this._ += "L" + r + "," + o), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = o}`);
  }
  rect(t, n, i, r) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
  }
  value() {
    return this._ || null;
  }
}
class gv {
  constructor() {
    this._ = [];
  }
  moveTo(t, n) {
    this._.push([t, n]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, n) {
    this._.push([t, n]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
class sV {
  constructor(t, [n, i, r, o] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (n = +n)) || !((o = +o) >= (i = +i)))
      throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = o, this.ymin = i, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: n, triangles: i }, vectors: r } = this;
    let o, a;
    const s = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
    for (let g = 0, m = 0, y = i.length, v, b; g < y; g += 3, m += 2) {
      const x = i[g] * 2, E = i[g + 1] * 2, _ = i[g + 2] * 2, w = t[x], S = t[x + 1], C = t[E], $ = t[E + 1], A = t[_], M = t[_ + 1], F = C - w, O = $ - S, k = A - w, T = M - S, N = (F * T - O * k) * 2;
      if (Math.abs(N) < 1e-9) {
        if (o === void 0) {
          o = a = 0;
          for (const z of n)
            o += t[z * 2], a += t[z * 2 + 1];
          o /= n.length, a /= n.length;
        }
        const L = 1e9 * Math.sign((o - w) * T - (a - S) * k);
        v = (w + A) / 2 - L * T, b = (S + M) / 2 + L * k;
      } else {
        const L = 1 / N, z = F * F + O * O, J = k * k + T * T;
        v = w + (T * z - O * J) * L, b = S + (F * J - k * z) * L;
      }
      s[m] = v, s[m + 1] = b;
    }
    let u = n[n.length - 1], l, c = u * 4, f, d = t[2 * u], h, p = t[2 * u + 1];
    r.fill(0);
    for (let g = 0; g < n.length; ++g)
      u = n[g], l = c, f = d, h = p, c = u * 4, d = t[2 * u], p = t[2 * u + 1], r[l + 2] = r[c] = h - p, r[l + 3] = r[c + 1] = d - f;
  }
  render(t) {
    const n = t == null ? t = new Ha() : void 0, { delaunay: { halfedges: i, inedges: r, hull: o }, circumcenters: a, vectors: s } = this;
    if (o.length <= 1)
      return null;
    for (let c = 0, f = i.length; c < f; ++c) {
      const d = i[c];
      if (d < c)
        continue;
      const h = Math.floor(c / 3) * 2, p = Math.floor(d / 3) * 2, g = a[h], m = a[h + 1], y = a[p], v = a[p + 1];
      this._renderSegment(g, m, y, v, t);
    }
    let u, l = o[o.length - 1];
    for (let c = 0; c < o.length; ++c) {
      u = l, l = o[c];
      const f = Math.floor(r[l] / 3) * 2, d = a[f], h = a[f + 1], p = u * 4, g = this._project(d, h, s[p + 2], s[p + 3]);
      g && this._renderSegment(d, h, g[0], g[1], t);
    }
    return n && n.value();
  }
  renderBounds(t) {
    const n = t == null ? t = new Ha() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
  }
  renderCell(t, n) {
    const i = n == null ? n = new Ha() : void 0, r = this._clip(t);
    if (r === null || !r.length)
      return;
    n.moveTo(r[0], r[1]);
    let o = r.length;
    for (; r[0] === r[o - 2] && r[1] === r[o - 1] && o > 1; )
      o -= 2;
    for (let a = 2; a < o; a += 2)
      (r[a] !== r[a - 2] || r[a + 1] !== r[a - 1]) && n.lineTo(r[a], r[a + 1]);
    return n.closePath(), i && i.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let n = 0, i = t.length / 2; n < i; ++n) {
      const r = this.cellPolygon(n);
      r && (r.index = n, yield r);
    }
  }
  cellPolygon(t) {
    const n = new gv();
    return this.renderCell(t, n), n.value();
  }
  _renderSegment(t, n, i, r, o) {
    let a;
    const s = this._regioncode(t, n), u = this._regioncode(i, r);
    s === 0 && u === 0 ? (o.moveTo(t, n), o.lineTo(i, r)) : (a = this._clipSegment(t, n, i, r, s, u)) && (o.moveTo(a[0], a[1]), o.lineTo(a[2], a[3]));
  }
  contains(t, n, i) {
    return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t;
  }
  *neighbors(t) {
    const n = this._clip(t);
    if (n)
      for (const i of this.delaunay.neighbors(t)) {
        const r = this._clip(i);
        if (r) {
          e:
            for (let o = 0, a = n.length; o < a; o += 2)
              for (let s = 0, u = r.length; s < u; s += 2)
                if (n[o] === r[s] && n[o + 1] === r[s + 1] && n[(o + 2) % a] === r[(s + u - 2) % u] && n[(o + 3) % a] === r[(s + u - 1) % u]) {
                  yield i;
                  break e;
                }
        }
      }
  }
  _cell(t) {
    const { circumcenters: n, delaunay: { inedges: i, halfedges: r, triangles: o } } = this, a = i[t];
    if (a === -1)
      return null;
    const s = [];
    let u = a;
    do {
      const l = Math.floor(u / 3);
      if (s.push(n[l * 2], n[l * 2 + 1]), u = u % 3 === 2 ? u - 2 : u + 1, o[u] !== t)
        break;
      u = r[u];
    } while (u !== a && u !== -1);
    return s;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const n = this._cell(t);
    if (n === null)
      return null;
    const { vectors: i } = this, r = t * 4;
    return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n));
  }
  _clipFinite(t, n) {
    const i = n.length;
    let r = null, o, a, s = n[i - 2], u = n[i - 1], l, c = this._regioncode(s, u), f, d = 0;
    for (let h = 0; h < i; h += 2)
      if (o = s, a = u, s = n[h], u = n[h + 1], l = c, c = this._regioncode(s, u), l === 0 && c === 0)
        f = d, d = 0, r ? r.push(s, u) : r = [s, u];
      else {
        let p, g, m, y, v;
        if (l === 0) {
          if ((p = this._clipSegment(o, a, s, u, l, c)) === null)
            continue;
          [g, m, y, v] = p;
        } else {
          if ((p = this._clipSegment(s, u, o, a, c, l)) === null)
            continue;
          [y, v, g, m] = p, f = d, d = this._edgecode(g, m), f && d && this._edge(t, f, d, r, r.length), r ? r.push(g, m) : r = [g, m];
        }
        f = d, d = this._edgecode(y, v), f && d && this._edge(t, f, d, r, r.length), r ? r.push(y, v) : r = [y, v];
      }
    if (r)
      f = d, d = this._edgecode(r[0], r[1]), f && d && this._edge(t, f, d, r, r.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return r;
  }
  _clipSegment(t, n, i, r, o, a) {
    const s = o < a;
    for (s && ([t, n, i, r, o, a] = [i, r, t, n, a, o]); ; ) {
      if (o === 0 && a === 0)
        return s ? [i, r, t, n] : [t, n, i, r];
      if (o & a)
        return null;
      let u, l, c = o || a;
      c & 8 ? (u = t + (i - t) * (this.ymax - n) / (r - n), l = this.ymax) : c & 4 ? (u = t + (i - t) * (this.ymin - n) / (r - n), l = this.ymin) : c & 2 ? (l = n + (r - n) * (this.xmax - t) / (i - t), u = this.xmax) : (l = n + (r - n) * (this.xmin - t) / (i - t), u = this.xmin), o ? (t = u, n = l, o = this._regioncode(t, n)) : (i = u, r = l, a = this._regioncode(i, r));
    }
  }
  _clipInfinite(t, n, i, r, o, a) {
    let s = Array.from(n), u;
    if ((u = this._project(s[0], s[1], i, r)) && s.unshift(u[0], u[1]), (u = this._project(s[s.length - 2], s[s.length - 1], o, a)) && s.push(u[0], u[1]), s = this._clipFinite(t, s))
      for (let l = 0, c = s.length, f, d = this._edgecode(s[c - 2], s[c - 1]); l < c; l += 2)
        f = d, d = this._edgecode(s[l], s[l + 1]), f && d && (l = this._edge(t, f, d, s, l), c = s.length);
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (s = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return s;
  }
  _edge(t, n, i, r, o) {
    for (; n !== i; ) {
      let a, s;
      switch (n) {
        case 5:
          n = 4;
          continue;
        case 4:
          n = 6, a = this.xmax, s = this.ymin;
          break;
        case 6:
          n = 2;
          continue;
        case 2:
          n = 10, a = this.xmax, s = this.ymax;
          break;
        case 10:
          n = 8;
          continue;
        case 8:
          n = 9, a = this.xmin, s = this.ymax;
          break;
        case 9:
          n = 1;
          continue;
        case 1:
          n = 5, a = this.xmin, s = this.ymin;
          break;
      }
      (r[o] !== a || r[o + 1] !== s) && this.contains(t, a, s) && (r.splice(o, 0, a, s), o += 2);
    }
    return o;
  }
  _project(t, n, i, r) {
    let o = 1 / 0, a, s, u;
    if (r < 0) {
      if (n <= this.ymin)
        return null;
      (a = (this.ymin - n) / r) < o && (u = this.ymin, s = t + (o = a) * i);
    } else if (r > 0) {
      if (n >= this.ymax)
        return null;
      (a = (this.ymax - n) / r) < o && (u = this.ymax, s = t + (o = a) * i);
    }
    if (i > 0) {
      if (t >= this.xmax)
        return null;
      (a = (this.xmax - t) / i) < o && (s = this.xmax, u = n + (o = a) * r);
    } else if (i < 0) {
      if (t <= this.xmin)
        return null;
      (a = (this.xmin - t) / i) < o && (s = this.xmin, u = n + (o = a) * r);
    }
    return [s, u];
  }
  _edgecode(t, n) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
  }
  _regioncode(t, n) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let n = 0; n < t.length; n += 2) {
        const i = (n + 2) % t.length, r = (n + 4) % t.length;
        (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
}
const uV = 2 * Math.PI, Zs = Math.pow;
function lV(e) {
  return e[0];
}
function cV(e) {
  return e[1];
}
function fV(e) {
  const { triangles: t, coords: n } = e;
  for (let i = 0; i < t.length; i += 3) {
    const r = 2 * t[i], o = 2 * t[i + 1], a = 2 * t[i + 2];
    if ((n[a] - n[r]) * (n[o + 1] - n[r + 1]) - (n[o] - n[r]) * (n[a + 1] - n[r + 1]) > 1e-10)
      return !1;
  }
  return !0;
}
function dV(e, t, n) {
  return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
}
class vw {
  static from(t, n = lV, i = cV, r) {
    return new vw("length" in t ? hV(t, n, i, r) : Float64Array.from(pV(t, n, i, r)));
  }
  constructor(t) {
    this._delaunator = new Lp(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, n = this.points;
    if (t.hull && t.hull.length > 2 && fV(t)) {
      this.collinear = Int32Array.from({ length: n.length / 2 }, (d, h) => h).sort((d, h) => n[2 * d] - n[2 * h] || n[2 * d + 1] - n[2 * h + 1]);
      const u = this.collinear[0], l = this.collinear[this.collinear.length - 1], c = [n[2 * u], n[2 * u + 1], n[2 * l], n[2 * l + 1]], f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
      for (let d = 0, h = n.length / 2; d < h; ++d) {
        const p = dV(n[2 * d], n[2 * d + 1], f);
        n[2 * d] = p[0], n[2 * d + 1] = p[1];
      }
      this._delaunator = new Lp(n);
    } else
      delete this.collinear;
    const i = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, o = this.triangles = this._delaunator.triangles, a = this.inedges.fill(-1), s = this._hullIndex.fill(-1);
    for (let u = 0, l = i.length; u < l; ++u) {
      const c = o[u % 3 === 2 ? u - 2 : u + 1];
      (i[u] === -1 || a[c] === -1) && (a[c] = u);
    }
    for (let u = 0, l = r.length; u < l; ++u)
      s[r[u]] = u;
    r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], a[r[0]] = 1, r.length === 2 && (a[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
  }
  voronoi(t) {
    return new sV(this, t);
  }
  *neighbors(t) {
    const { inedges: n, hull: i, _hullIndex: r, halfedges: o, triangles: a, collinear: s } = this;
    if (s) {
      const f = s.indexOf(t);
      f > 0 && (yield s[f - 1]), f < s.length - 1 && (yield s[f + 1]);
      return;
    }
    const u = n[t];
    if (u === -1)
      return;
    let l = u, c = -1;
    do {
      if (yield c = a[l], l = l % 3 === 2 ? l - 2 : l + 1, a[l] !== t)
        return;
      if (l = o[l], l === -1) {
        const f = i[(r[t] + 1) % i.length];
        f !== c && (yield f);
        return;
      }
    } while (l !== u);
  }
  find(t, n, i = 0) {
    if (t = +t, t !== t || (n = +n, n !== n))
      return -1;
    const r = i;
    let o;
    for (; (o = this._step(i, t, n)) >= 0 && o !== i && o !== r; )
      i = o;
    return o;
  }
  _step(t, n, i) {
    const { inedges: r, hull: o, _hullIndex: a, halfedges: s, triangles: u, points: l } = this;
    if (r[t] === -1 || !l.length)
      return (t + 1) % (l.length >> 1);
    let c = t, f = Zs(n - l[t * 2], 2) + Zs(i - l[t * 2 + 1], 2);
    const d = r[t];
    let h = d;
    do {
      let p = u[h];
      const g = Zs(n - l[p * 2], 2) + Zs(i - l[p * 2 + 1], 2);
      if (g < f && (f = g, c = p), h = h % 3 === 2 ? h - 2 : h + 1, u[h] !== t)
        break;
      if (h = s[h], h === -1) {
        if (h = o[(a[t] + 1) % o.length], h !== p && Zs(n - l[h * 2], 2) + Zs(i - l[h * 2 + 1], 2) < f)
          return h;
        break;
      }
    } while (h !== d);
    return c;
  }
  render(t) {
    const n = t == null ? t = new Ha() : void 0, { points: i, halfedges: r, triangles: o } = this;
    for (let a = 0, s = r.length; a < s; ++a) {
      const u = r[a];
      if (u < a)
        continue;
      const l = o[a] * 2, c = o[u] * 2;
      t.moveTo(i[l], i[l + 1]), t.lineTo(i[c], i[c + 1]);
    }
    return this.renderHull(t), n && n.value();
  }
  renderPoints(t, n) {
    n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
    const i = t == null ? t = new Ha() : void 0, { points: r } = this;
    for (let o = 0, a = r.length; o < a; o += 2) {
      const s = r[o], u = r[o + 1];
      t.moveTo(s + n, u), t.arc(s, u, n, 0, uV);
    }
    return i && i.value();
  }
  renderHull(t) {
    const n = t == null ? t = new Ha() : void 0, { hull: i, points: r } = this, o = i[0] * 2, a = i.length;
    t.moveTo(r[o], r[o + 1]);
    for (let s = 1; s < a; ++s) {
      const u = 2 * i[s];
      t.lineTo(r[u], r[u + 1]);
    }
    return t.closePath(), n && n.value();
  }
  hullPolygon() {
    const t = new gv();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, n) {
    const i = n == null ? n = new Ha() : void 0, { points: r, triangles: o } = this, a = o[t *= 3] * 2, s = o[t + 1] * 2, u = o[t + 2] * 2;
    return n.moveTo(r[a], r[a + 1]), n.lineTo(r[s], r[s + 1]), n.lineTo(r[u], r[u + 1]), n.closePath(), i && i.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let n = 0, i = t.length / 3; n < i; ++n)
      yield this.trianglePolygon(n);
  }
  trianglePolygon(t) {
    const n = new gv();
    return this.renderTriangle(t, n), n.value();
  }
}
function hV(e, t, n, i) {
  const r = e.length, o = new Float64Array(r * 2);
  for (let a = 0; a < r; ++a) {
    const s = e[a];
    o[a * 2] = t.call(i, s, a, e), o[a * 2 + 1] = n.call(i, s, a, e);
  }
  return o;
}
function* pV(e, t, n, i) {
  let r = 0;
  for (const o of e)
    yield t.call(i, o, r, e), yield n.call(i, o, r, e), ++r;
}
function bw(e) {
  D.call(this, null, e);
}
bw.Definition = {
  type: "Voronoi",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    default: [[-1e5, -1e5], [1e5, 1e5]],
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
const gV = [-1e5, -1e5, 1e5, 1e5];
G(bw, D, {
  transform(e, t) {
    const n = e.as || "path", i = t.source;
    if (!i || !i.length)
      return t;
    let r = e.size;
    r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : gV;
    const o = this.value = vw.from(i, e.x, e.y).voronoi(r);
    for (let a = 0, s = i.length; a < s; ++a) {
      const u = o.cellPolygon(a);
      i[a][n] = u ? mV(u) : null;
    }
    return t.reflow(e.modified()).modifies(n);
  }
});
function mV(e) {
  const t = e[0][0], n = e[0][1];
  let i = e.length - 1;
  for (; e[i][0] === t && e[i][1] === n; --i)
    ;
  return "M" + e.slice(0, i + 1).join("L") + "Z";
}
const yV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  voronoi: bw
}, Symbol.toStringTag, { value: "Module" }));
var f1 = Math.PI / 180, Ac = 1 << 11 >> 5, vh = 1 << 11;
function vV() {
  var e = [256, 256], t, n, i, r, o, a, s, u = ZD, l = [], c = Math.random, f = {};
  f.layout = function() {
    for (var p = d(Uo()), g = SV((e[0] >> 5) * e[1]), m = null, y = l.length, v = -1, b = [], x = l.map((_) => ({
      text: t(_),
      font: n(_),
      style: r(_),
      weight: o(_),
      rotate: a(_),
      size: ~~(i(_) + 1e-14),
      padding: s(_),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: !1,
      sprite: null,
      datum: _
    })).sort((_, w) => w.size - _.size); ++v < y; ) {
      var E = x[v];
      E.x = e[0] * (c() + 0.5) >> 1, E.y = e[1] * (c() + 0.5) >> 1, bV(p, E, x, v), E.hasText && h(g, E, m) && (b.push(E), m ? wV(m, E) : m = [{
        x: E.x + E.x0,
        y: E.y + E.y0
      }, {
        x: E.x + E.x1,
        y: E.y + E.y1
      }], E.x -= e[0] >> 1, E.y -= e[1] >> 1);
    }
    return b;
  };
  function d(p) {
    p.width = p.height = 1;
    var g = Math.sqrt(p.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    p.width = (Ac << 5) / g, p.height = vh / g;
    var m = p.getContext("2d");
    return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
      context: m,
      ratio: g
    };
  }
  function h(p, g, m) {
    for (var y = g.x, v = g.y, b = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = u(e), E = c() < 0.5 ? 1 : -1, _ = -E, w, S, C; (w = x(_ += E)) && (S = ~~w[0], C = ~~w[1], !(Math.min(Math.abs(S), Math.abs(C)) >= b)); )
      if (g.x = y + S, g.y = v + C, !(g.x + g.x0 < 0 || g.y + g.y0 < 0 || g.x + g.x1 > e[0] || g.y + g.y1 > e[1]) && (!m || !xV(g, p, e[0])) && (!m || EV(g, m))) {
        for (var $ = g.sprite, A = g.width >> 5, M = e[0] >> 5, F = g.x - (A << 4), O = F & 127, k = 32 - O, T = g.y1 - g.y0, N = (g.y + g.y0) * M + (F >> 5), L, z = 0; z < T; z++) {
          L = 0;
          for (var J = 0; J <= A; J++)
            p[N + J] |= L << k | (J < A ? (L = $[z * A + J]) >>> O : 0);
          N += M;
        }
        return g.sprite = null, !0;
      }
    return !1;
  }
  return f.words = function(p) {
    return arguments.length ? (l = p, f) : l;
  }, f.size = function(p) {
    return arguments.length ? (e = [+p[0], +p[1]], f) : e;
  }, f.font = function(p) {
    return arguments.length ? (n = Sa(p), f) : n;
  }, f.fontStyle = function(p) {
    return arguments.length ? (r = Sa(p), f) : r;
  }, f.fontWeight = function(p) {
    return arguments.length ? (o = Sa(p), f) : o;
  }, f.rotate = function(p) {
    return arguments.length ? (a = Sa(p), f) : a;
  }, f.text = function(p) {
    return arguments.length ? (t = Sa(p), f) : t;
  }, f.spiral = function(p) {
    return arguments.length ? (u = AV[p] || p, f) : u;
  }, f.fontSize = function(p) {
    return arguments.length ? (i = Sa(p), f) : i;
  }, f.padding = function(p) {
    return arguments.length ? (s = Sa(p), f) : s;
  }, f.random = function(p) {
    return arguments.length ? (c = p, f) : c;
  }, f;
}
function bV(e, t, n, i) {
  if (!t.sprite) {
    var r = e.context, o = e.ratio;
    r.clearRect(0, 0, (Ac << 5) / o, vh / o);
    var a = 0, s = 0, u = 0, l = n.length, c, f, d, h, p;
    for (--i; ++i < l; ) {
      if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / o) + "px " + t.font, c = r.measureText(t.text + "m").width * o, d = t.size << 1, t.rotate) {
        var g = Math.sin(t.rotate * f1), m = Math.cos(t.rotate * f1), y = c * m, v = c * g, b = d * m, x = d * g;
        c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, d = ~~Math.max(Math.abs(v + b), Math.abs(v - b));
      } else
        c = c + 31 >> 5 << 5;
      if (d > u && (u = d), a + c >= Ac << 5 && (a = 0, s += u, u = 0), s + d >= vh)
        break;
      r.translate((a + (c >> 1)) / o, (s + (d >> 1)) / o), t.rotate && r.rotate(t.rotate * f1), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = d, t.xoff = a, t.yoff = s, t.x1 = c >> 1, t.y1 = d >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += c;
    }
    for (var E = r.getImageData(0, 0, (Ac << 5) / o, vh / o).data, _ = []; --i >= 0; )
      if (t = n[i], !!t.hasText) {
        for (c = t.width, f = c >> 5, d = t.y1 - t.y0, h = 0; h < d * f; h++)
          _[h] = 0;
        if (a = t.xoff, a == null)
          return;
        s = t.yoff;
        var w = 0, S = -1;
        for (p = 0; p < d; p++) {
          for (h = 0; h < c; h++) {
            var C = f * p + (h >> 5), $ = E[(s + p) * (Ac << 5) + (a + h) << 2] ? 1 << 31 - h % 32 : 0;
            _[C] |= $, w |= $;
          }
          w ? S = p : (t.y0++, d--, p--, s++);
        }
        t.y1 = t.y0 + S, t.sprite = _.slice(0, (t.y1 - t.y0) * f);
      }
  }
}
function xV(e, t, n) {
  n >>= 5;
  for (var i = e.sprite, r = e.width >> 5, o = e.x - (r << 4), a = o & 127, s = 32 - a, u = e.y1 - e.y0, l = (e.y + e.y0) * n + (o >> 5), c, f = 0; f < u; f++) {
    c = 0;
    for (var d = 0; d <= r; d++)
      if ((c << s | (d < r ? (c = i[f * r + d]) >>> a : 0)) & t[l + d])
        return !0;
    l += n;
  }
  return !1;
}
function wV(e, t) {
  var n = e[0], i = e[1];
  t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1);
}
function EV(e, t) {
  return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
}
function ZD(e) {
  var t = e[0] / e[1];
  return function(n) {
    return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
  };
}
function _V(e) {
  var t = 4, n = t * e[0] / e[1], i = 0, r = 0;
  return function(o) {
    var a = o < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * a * o) - a & 3) {
      case 0:
        i += n;
        break;
      case 1:
        r += t;
        break;
      case 2:
        i -= n;
        break;
      default:
        r -= t;
        break;
    }
    return [i, r];
  };
}
function SV(e) {
  for (var t = [], n = -1; ++n < e; )
    t[n] = 0;
  return t;
}
function Sa(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
var AV = {
  archimedean: ZD,
  rectangular: _V
};
const e5 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"], $V = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function xw(e) {
  D.call(this, vV(), e);
}
xw.Definition = {
  type: "Wordcloud",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "font",
    type: "string",
    expr: !0,
    default: "sans-serif"
  }, {
    name: "fontStyle",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontWeight",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontSize",
    type: "number",
    expr: !0,
    default: 14
  }, {
    name: "fontSizeRange",
    type: "number",
    array: "nullable",
    default: [10, 50]
  }, {
    name: "rotate",
    type: "number",
    expr: !0,
    default: 0
  }, {
    name: "text",
    type: "field"
  }, {
    name: "spiral",
    type: "string",
    values: ["archimedean", "rectangular"]
  }, {
    name: "padding",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 7,
    default: e5
  }]
};
G(xw, D, {
  transform(e, t) {
    e.size && !(e.size[0] && e.size[1]) && I("Wordcloud size dimensions must be non-zero.");
    function n(p) {
      const g = e[p];
      return fe(g) && t.modified(g.fields);
    }
    const i = e.modified();
    if (!(i || t.changed(t.ADD_REM) || $V.some(n)))
      return;
    const r = t.materialize(t.SOURCE).source, o = this.value, a = e.as || e5;
    let s = e.fontSize || 14, u;
    if (fe(s) ? u = e.fontSizeRange : s = Gt(s), u) {
      const p = s, g = $e("sqrt")().domain(hr(r, p)).range(u);
      s = (m) => g(p(m));
    }
    r.forEach((p) => {
      p[a[0]] = NaN, p[a[1]] = NaN, p[a[3]] = 0;
    });
    const l = o.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(s).random(ni).layout(), c = o.size(), f = c[0] >> 1, d = c[1] >> 1, h = l.length;
    for (let p = 0, g, m; p < h; ++p)
      g = l[p], m = g.datum, m[a[0]] = g.x + f, m[a[1]] = g.y + d, m[a[2]] = g.font, m[a[3]] = g.size, m[a[4]] = g.style, m[a[5]] = g.weight, m[a[6]] = g.rotate;
    return t.reflow(i).modifies(a);
  }
});
const kV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  wordcloud: xw
}, Symbol.toStringTag, { value: "Module" })), CV = (e) => new Uint8Array(e), FV = (e) => new Uint16Array(e), Pc = (e) => new Uint32Array(e);
function MV() {
  let e = 8, t = [], n = Pc(0), i = Pd(0, e), r = Pd(0, e);
  return {
    data: () => t,
    seen: () => n = TV(n, t.length),
    add(o) {
      for (let a = 0, s = t.length, u = o.length, l; a < u; ++a)
        l = o[a], l._index = s++, t.push(l);
    },
    remove(o, a) {
      const s = t.length, u = Array(s - o), l = t;
      let c, f, d;
      for (f = 0; !a[f] && f < s; ++f)
        u[f] = t[f], l[f] = f;
      for (d = f; f < s; ++f)
        c = t[f], a[f] ? l[f] = -1 : (l[f] = d, i[d] = i[f], r[d] = r[f], u[d] = c, c._index = d++), i[f] = 0;
      return t = u, l;
    },
    size: () => t.length,
    curr: () => i,
    prev: () => r,
    reset: (o) => r[o] = i[o],
    all: () => e < 257 ? 255 : e < 65537 ? 65535 : 4294967295,
    set(o, a) {
      i[o] |= a;
    },
    clear(o, a) {
      i[o] &= ~a;
    },
    resize(o, a) {
      const s = i.length;
      (o > s || a > e) && (e = Math.max(a, e), i = Pd(o, e, i), r = Pd(o, e));
    }
  };
}
function TV(e, t, n) {
  return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n);
}
function Pd(e, t, n) {
  const i = (t < 257 ? CV : t < 65537 ? FV : Pc)(e);
  return n && i.set(n), i;
}
function N$(e, t, n) {
  const i = 1 << t;
  return {
    one: i,
    zero: ~i,
    range: n.slice(),
    bisect: e.bisect,
    index: e.index,
    size: e.size,
    onAdd(r, o) {
      const a = this, s = a.bisect(a.range, r.value), u = r.index, l = s[0], c = s[1], f = u.length;
      let d;
      for (d = 0; d < l; ++d)
        o[u[d]] |= i;
      for (d = c; d < f; ++d)
        o[u[d]] |= i;
      return a;
    }
  };
}
function D$() {
  let e = Pc(0), t = [], n = 0;
  function i(s, u, l) {
    if (!u.length)
      return [];
    const c = n, f = u.length, d = Pc(f);
    let h = Array(f), p, g, m;
    for (m = 0; m < f; ++m)
      h[m] = s(u[m]), d[m] = m;
    if (h = OV(h, d), c)
      p = t, g = e, t = Array(c + f), e = Pc(c + f), NV(l, p, g, c, h, d, f, t, e);
    else {
      if (l > 0)
        for (m = 0; m < f; ++m)
          d[m] += l;
      t = h, e = d;
    }
    return n = c + f, {
      index: d,
      value: h
    };
  }
  function r(s, u) {
    const l = n;
    let c, f, d;
    for (f = 0; !u[e[f]] && f < l; ++f)
      ;
    for (d = f; f < l; ++f)
      u[c = e[f]] || (e[d] = c, t[d] = t[f], ++d);
    n = l - s;
  }
  function o(s) {
    for (let u = 0, l = n; u < l; ++u)
      e[u] = s[e[u]];
  }
  function a(s, u) {
    let l;
    return u ? l = u.length : (u = t, l = n), [JI(u, s[0], 0, l), Mh(u, s[1], 0, l)];
  }
  return {
    insert: i,
    remove: r,
    bisect: a,
    reindex: o,
    index: () => e,
    size: () => n
  };
}
function OV(e, t) {
  return e.sort.call(t, (n, i) => {
    const r = e[n], o = e[i];
    return r < o ? -1 : r > o ? 1 : 0;
  }), eP(e, t);
}
function NV(e, t, n, i, r, o, a, s, u) {
  let l = 0, c = 0, f;
  for (f = 0; l < i && c < a; ++f)
    t[l] < r[c] ? (s[f] = t[l], u[f] = n[l++]) : (s[f] = r[c], u[f] = o[c++] + e);
  for (; l < i; ++l, ++f)
    s[f] = t[l], u[f] = n[l];
  for (; c < a; ++c, ++f)
    s[f] = r[c], u[f] = o[c] + e;
}
function ww(e) {
  D.call(this, MV(), e), this._indices = null, this._dims = null;
}
ww.Definition = {
  type: "CrossFilter",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "query",
    type: "array",
    array: !0,
    required: !0,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }]
};
G(ww, D, {
  transform(e, t) {
    if (this._dims) {
      var n = e.modified("fields") || e.fields.some((i) => t.modified(i.fields));
      return n ? this.reinit(e, t) : this.eval(e, t);
    } else
      return this.init(e, t);
  },
  init(e, t) {
    const n = e.fields, i = e.query, r = this._indices = {}, o = this._dims = [], a = i.length;
    let s = 0, u, l;
    for (; s < a; ++s)
      u = n[s].fname, l = r[u] || (r[u] = D$()), o.push(N$(l, s, i[s]));
    return this.eval(e, t);
  },
  reinit(e, t) {
    const n = t.materialize().fork(), i = e.fields, r = e.query, o = this._indices, a = this._dims, s = this.value, u = s.curr(), l = s.prev(), c = s.all(), f = n.rem = n.add, d = n.mod, h = r.length, p = {};
    let g, m, y, v, b, x, E, _, w;
    if (l.set(u), t.rem.length && (b = this.remove(e, t, n)), t.add.length && s.add(t.add), t.mod.length)
      for (x = {}, v = t.mod, E = 0, _ = v.length; E < _; ++E)
        x[v[E]._index] = 1;
    for (E = 0; E < h; ++E)
      w = i[E], (!a[E] || e.modified("fields", E) || t.modified(w.fields)) && (y = w.fname, (g = p[y]) || (o[y] = m = D$(), p[y] = g = m.insert(w, t.source, 0)), a[E] = N$(m, E, r[E]).onAdd(g, u));
    for (E = 0, _ = s.data().length; E < _; ++E)
      b[E] || (l[E] !== u[E] ? f.push(E) : x[E] && u[E] !== c && d.push(E));
    return s.mask = (1 << h) - 1, n;
  },
  eval(e, t) {
    const n = t.materialize().fork(), i = this._dims.length;
    let r = 0;
    return t.rem.length && (this.remove(e, t, n), r |= (1 << i) - 1), e.modified("query") && !e.modified("fields") && (r |= this.update(e, t, n)), t.add.length && (this.insert(e, t, n), r |= (1 << i) - 1), t.mod.length && (this.modify(t, n), r |= (1 << i) - 1), this.value.mask = r, n;
  },
  insert(e, t, n) {
    const i = t.add, r = this.value, o = this._dims, a = this._indices, s = e.fields, u = {}, l = n.add, c = r.size() + i.length, f = o.length;
    let d = r.size(), h, p, g;
    r.resize(c, f), r.add(i);
    const m = r.curr(), y = r.prev(), v = r.all();
    for (h = 0; h < f; ++h)
      p = s[h].fname, g = u[p] || (u[p] = a[p].insert(s[h], i, d)), o[h].onAdd(g, m);
    for (; d < c; ++d)
      y[d] = v, m[d] !== v && l.push(d);
  },
  modify(e, t) {
    const n = t.mod, i = this.value, r = i.curr(), o = i.all(), a = e.mod;
    let s, u, l;
    for (s = 0, u = a.length; s < u; ++s)
      l = a[s]._index, r[l] !== o && n.push(l);
  },
  remove(e, t, n) {
    const i = this._indices, r = this.value, o = r.curr(), a = r.prev(), s = r.all(), u = {}, l = n.rem, c = t.rem;
    let f, d, h, p;
    for (f = 0, d = c.length; f < d; ++f)
      h = c[f]._index, u[h] = 1, a[h] = p = o[h], o[h] = s, p !== s && l.push(h);
    for (h in i)
      i[h].remove(d, u);
    return this.reindex(t, d, u), u;
  },
  reindex(e, t, n) {
    const i = this._indices, r = this.value;
    e.runAfter(() => {
      const o = r.remove(t, n);
      for (const a in i)
        i[a].reindex(o);
    });
  },
  update(e, t, n) {
    const i = this._dims, r = e.query, o = t.stamp, a = i.length;
    let s = 0, u, l;
    for (n.filters = 0, l = 0; l < a; ++l)
      e.modified("query", l) && (u = l, ++s);
    if (s === 1)
      s = i[u].one, this.incrementOne(i[u], r[u], n.add, n.rem);
    else
      for (l = 0, s = 0; l < a; ++l)
        !e.modified("query", l) || (s |= i[l].one, this.incrementAll(i[l], r[l], o, n.add), n.rem = n.add);
    return s;
  },
  incrementAll(e, t, n, i) {
    const r = this.value, o = r.seen(), a = r.curr(), s = r.prev(), u = e.index(), l = e.bisect(e.range), c = e.bisect(t), f = c[0], d = c[1], h = l[0], p = l[1], g = e.one;
    let m, y, v;
    if (f < h)
      for (m = f, y = Math.min(h, d); m < y; ++m)
        v = u[m], o[v] !== n && (s[v] = a[v], o[v] = n, i.push(v)), a[v] ^= g;
    else if (f > h)
      for (m = h, y = Math.min(f, p); m < y; ++m)
        v = u[m], o[v] !== n && (s[v] = a[v], o[v] = n, i.push(v)), a[v] ^= g;
    if (d > p)
      for (m = Math.max(f, p), y = d; m < y; ++m)
        v = u[m], o[v] !== n && (s[v] = a[v], o[v] = n, i.push(v)), a[v] ^= g;
    else if (d < p)
      for (m = Math.max(h, d), y = p; m < y; ++m)
        v = u[m], o[v] !== n && (s[v] = a[v], o[v] = n, i.push(v)), a[v] ^= g;
    e.range = t.slice();
  },
  incrementOne(e, t, n, i) {
    const r = this.value, o = r.curr(), a = e.index(), s = e.bisect(e.range), u = e.bisect(t), l = u[0], c = u[1], f = s[0], d = s[1], h = e.one;
    let p, g, m;
    if (l < f)
      for (p = l, g = Math.min(f, c); p < g; ++p)
        m = a[p], o[m] ^= h, n.push(m);
    else if (l > f)
      for (p = f, g = Math.min(l, d); p < g; ++p)
        m = a[p], o[m] ^= h, i.push(m);
    if (c > d)
      for (p = Math.max(l, d), g = c; p < g; ++p)
        m = a[p], o[m] ^= h, n.push(m);
    else if (c < d)
      for (p = Math.max(f, c), g = d; p < g; ++p)
        m = a[p], o[m] ^= h, i.push(m);
    e.range = t.slice();
  }
});
function Ew(e) {
  D.call(this, null, e);
}
Ew.Definition = {
  type: "ResolveFilter",
  metadata: {},
  params: [{
    name: "ignore",
    type: "number",
    required: !0,
    description: "A bit mask indicating which filters to ignore."
  }, {
    name: "filter",
    type: "object",
    required: !0,
    description: "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
G(Ew, D, {
  transform(e, t) {
    const n = ~(e.ignore || 0), i = e.filter, r = i.mask;
    if ((r & n) === 0)
      return t.StopPropagation;
    const o = t.fork(t.ALL), a = i.data(), s = i.curr(), u = i.prev(), l = (c) => s[c] & n ? null : a[c];
    return o.filter(o.MOD, l), r & r - 1 ? (o.filter(o.ADD, (c) => {
      const f = s[c] & n;
      return !f && f ^ u[c] & n ? a[c] : null;
    }), o.filter(o.REM, (c) => {
      const f = s[c] & n;
      return f && !(f ^ (f ^ u[c] & n)) ? a[c] : null;
    })) : (o.filter(o.ADD, l), o.filter(o.REM, (c) => (s[c] & n) === r ? a[c] : null)), o.filter(o.SOURCE, (c) => l(c._index));
  }
});
const DV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crossfilter: ww,
  resolvefilter: Ew
}, Symbol.toStringTag, { value: "Module" })), RV = "RawCode", ds = "Literal", LV = "Property", IV = "Identifier", PV = "ArrayExpression", zV = "BinaryExpression", t5 = "CallExpression", BV = "ConditionalExpression", jV = "LogicalExpression", UV = "MemberExpression", qV = "ObjectExpression", WV = "UnaryExpression";
function Ii(e) {
  this.type = e;
}
Ii.prototype.visit = function(e) {
  let t, n, i;
  if (e(this))
    return 1;
  for (t = GV(this), n = 0, i = t.length; n < i; ++n)
    if (t[n].visit(e))
      return 1;
};
function GV(e) {
  switch (e.type) {
    case PV:
      return e.elements;
    case zV:
    case jV:
      return [e.left, e.right];
    case t5:
      return [e.callee].concat(e.arguments);
    case BV:
      return [e.test, e.consequent, e.alternate];
    case UV:
      return [e.object, e.property];
    case qV:
      return e.properties;
    case LV:
      return [e.key, e.value];
    case WV:
      return [e.argument];
    case IV:
    case ds:
    case RV:
    default:
      return [];
  }
}
var kr, Q, R, Ut, Te, lm = 1, Vf = 2, hs = 3, ha = 4, cm = 5, Ns = 6, dn = 7, Kf = 8, HV = 9;
kr = {};
kr[lm] = "Boolean";
kr[Vf] = "<end>";
kr[hs] = "Identifier";
kr[ha] = "Keyword";
kr[cm] = "Null";
kr[Ns] = "Numeric";
kr[dn] = "Punctuator";
kr[Kf] = "String";
kr[HV] = "RegularExpression";
var YV = "ArrayExpression", XV = "BinaryExpression", VV = "CallExpression", KV = "ConditionalExpression", n5 = "Identifier", JV = "Literal", QV = "LogicalExpression", ZV = "MemberExpression", eK = "ObjectExpression", tK = "Property", nK = "UnaryExpression", gt = "Unexpected token %0", iK = "Unexpected number", rK = "Unexpected string", oK = "Unexpected identifier", aK = "Unexpected reserved word", sK = "Unexpected end of input", mv = "Invalid regular expression", d1 = "Invalid regular expression: missing /", i5 = "Octal literals are not allowed in strict mode.", uK = "Duplicate data property in object literal not allowed in strict mode", At = "ILLEGAL", lf = "Disabled.", lK = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), cK = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function fm(e, t) {
  if (!e)
    throw new Error("ASSERT: " + t);
}
function jr(e) {
  return e >= 48 && e <= 57;
}
function _w(e) {
  return "0123456789abcdefABCDEF".indexOf(e) >= 0;
}
function zc(e) {
  return "01234567".indexOf(e) >= 0;
}
function fK(e) {
  return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0;
}
function cf(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function Jf(e) {
  return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e === 92 || e >= 128 && lK.test(String.fromCharCode(e));
}
function Ip(e) {
  return e === 36 || e === 95 || e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57 || e === 92 || e >= 128 && cK.test(String.fromCharCode(e));
}
const dK = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1
};
function r5() {
  for (; R < Ut; ) {
    const e = Q.charCodeAt(R);
    if (fK(e) || cf(e))
      ++R;
    else
      break;
  }
}
function yv(e) {
  var t, n, i, r = 0;
  for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t)
    R < Ut && _w(Q[R]) ? (i = Q[R++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : Se({}, gt, At);
  return String.fromCharCode(r);
}
function hK() {
  var e, t, n, i;
  for (e = Q[R], t = 0, e === "}" && Se({}, gt, At); R < Ut && (e = Q[R++], !!_w(e)); )
    t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
  return (t > 1114111 || e !== "}") && Se({}, gt, At), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i));
}
function o5() {
  var e, t;
  for (e = Q.charCodeAt(R++), t = String.fromCharCode(e), e === 92 && (Q.charCodeAt(R) !== 117 && Se({}, gt, At), ++R, e = yv("u"), (!e || e === "\\" || !Jf(e.charCodeAt(0))) && Se({}, gt, At), t = e); R < Ut && (e = Q.charCodeAt(R), !!Ip(e)); )
    ++R, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), Q.charCodeAt(R) !== 117 && Se({}, gt, At), ++R, e = yv("u"), (!e || e === "\\" || !Ip(e.charCodeAt(0))) && Se({}, gt, At), t += e);
  return t;
}
function pK() {
  var e, t;
  for (e = R++; R < Ut; ) {
    if (t = Q.charCodeAt(R), t === 92)
      return R = e, o5();
    if (Ip(t))
      ++R;
    else
      break;
  }
  return Q.slice(e, R);
}
function gK() {
  var e, t, n;
  return e = R, t = Q.charCodeAt(R) === 92 ? o5() : pK(), t.length === 1 ? n = hs : dK.hasOwnProperty(t) ? n = ha : t === "null" ? n = cm : t === "true" || t === "false" ? n = lm : n = hs, {
    type: n,
    value: t,
    start: e,
    end: R
  };
}
function h1() {
  var e = R, t = Q.charCodeAt(R), n, i = Q[R], r, o, a;
  switch (t) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      return ++R, {
        type: dn,
        value: String.fromCharCode(t),
        start: e,
        end: R
      };
    default:
      if (n = Q.charCodeAt(R + 1), n === 61)
        switch (t) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            return R += 2, {
              type: dn,
              value: String.fromCharCode(t) + String.fromCharCode(n),
              start: e,
              end: R
            };
          case 33:
          case 61:
            return R += 2, Q.charCodeAt(R) === 61 && ++R, {
              type: dn,
              value: Q.slice(e, R),
              start: e,
              end: R
            };
        }
  }
  if (a = Q.substr(R, 4), a === ">>>=")
    return R += 4, {
      type: dn,
      value: a,
      start: e,
      end: R
    };
  if (o = a.substr(0, 3), o === ">>>" || o === "<<=" || o === ">>=")
    return R += 3, {
      type: dn,
      value: o,
      start: e,
      end: R
    };
  if (r = o.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>")
    return R += 2, {
      type: dn,
      value: r,
      start: e,
      end: R
    };
  if (r === "//" && Se({}, gt, At), "<>=!+-*%&|^/".indexOf(i) >= 0)
    return ++R, {
      type: dn,
      value: i,
      start: e,
      end: R
    };
  Se({}, gt, At);
}
function mK(e) {
  let t = "";
  for (; R < Ut && _w(Q[R]); )
    t += Q[R++];
  return t.length === 0 && Se({}, gt, At), Jf(Q.charCodeAt(R)) && Se({}, gt, At), {
    type: Ns,
    value: parseInt("0x" + t, 16),
    start: e,
    end: R
  };
}
function yK(e) {
  let t = "0" + Q[R++];
  for (; R < Ut && zc(Q[R]); )
    t += Q[R++];
  return (Jf(Q.charCodeAt(R)) || jr(Q.charCodeAt(R))) && Se({}, gt, At), {
    type: Ns,
    value: parseInt(t, 8),
    octal: !0,
    start: e,
    end: R
  };
}
function R$() {
  var e, t, n;
  if (n = Q[R], fm(jr(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = R, e = "", n !== ".") {
    if (e = Q[R++], n = Q[R], e === "0") {
      if (n === "x" || n === "X")
        return ++R, mK(t);
      if (zc(n))
        return yK(t);
      n && jr(n.charCodeAt(0)) && Se({}, gt, At);
    }
    for (; jr(Q.charCodeAt(R)); )
      e += Q[R++];
    n = Q[R];
  }
  if (n === ".") {
    for (e += Q[R++]; jr(Q.charCodeAt(R)); )
      e += Q[R++];
    n = Q[R];
  }
  if (n === "e" || n === "E")
    if (e += Q[R++], n = Q[R], (n === "+" || n === "-") && (e += Q[R++]), jr(Q.charCodeAt(R)))
      for (; jr(Q.charCodeAt(R)); )
        e += Q[R++];
    else
      Se({}, gt, At);
  return Jf(Q.charCodeAt(R)) && Se({}, gt, At), {
    type: Ns,
    value: parseFloat(e),
    start: t,
    end: R
  };
}
function vK() {
  var e = "", t, n, i, r, o = !1;
  for (t = Q[R], fm(t === "'" || t === '"', "String literal must starts with a quote"), n = R, ++R; R < Ut; )
    if (i = Q[R++], i === t) {
      t = "";
      break;
    } else if (i === "\\")
      if (i = Q[R++], !i || !cf(i.charCodeAt(0)))
        switch (i) {
          case "u":
          case "x":
            Q[R] === "{" ? (++R, e += hK()) : e += yv(i);
            break;
          case "n":
            e += `
`;
            break;
          case "r":
            e += "\r";
            break;
          case "t":
            e += "	";
            break;
          case "b":
            e += "\b";
            break;
          case "f":
            e += "\f";
            break;
          case "v":
            e += "\v";
            break;
          default:
            zc(i) ? (r = "01234567".indexOf(i), r !== 0 && (o = !0), R < Ut && zc(Q[R]) && (o = !0, r = r * 8 + "01234567".indexOf(Q[R++]), "0123".indexOf(i) >= 0 && R < Ut && zc(Q[R]) && (r = r * 8 + "01234567".indexOf(Q[R++]))), e += String.fromCharCode(r)) : e += i;
            break;
        }
      else
        i === "\r" && Q[R] === `
` && ++R;
    else {
      if (cf(i.charCodeAt(0)))
        break;
      e += i;
    }
  return t !== "" && Se({}, gt, At), {
    type: Kf,
    value: e,
    octal: o,
    start: n,
    end: R
  };
}
function bK(e, t) {
  let n = e;
  t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
    if (parseInt(r, 16) <= 1114111)
      return "x";
    Se({}, mv);
  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
  try {
    new RegExp(n);
  } catch {
    Se({}, mv);
  }
  try {
    return new RegExp(e, t);
  } catch {
    return null;
  }
}
function xK() {
  var e, t, n, i, r;
  for (e = Q[R], fm(e === "/", "Regular expression literal must start with a slash"), t = Q[R++], n = !1, i = !1; R < Ut; )
    if (e = Q[R++], t += e, e === "\\")
      e = Q[R++], cf(e.charCodeAt(0)) && Se({}, d1), t += e;
    else if (cf(e.charCodeAt(0)))
      Se({}, d1);
    else if (n)
      e === "]" && (n = !1);
    else if (e === "/") {
      i = !0;
      break;
    } else
      e === "[" && (n = !0);
  return i || Se({}, d1), r = t.substr(1, t.length - 2), {
    value: r,
    literal: t
  };
}
function wK() {
  var e, t, n;
  for (t = "", n = ""; R < Ut && (e = Q[R], !!Ip(e.charCodeAt(0))); )
    ++R, e === "\\" && R < Ut ? Se({}, gt, At) : (n += e, t += e);
  return n.search(/[^gimuy]/g) >= 0 && Se({}, mv, n), {
    value: n,
    literal: t
  };
}
function EK() {
  var e, t, n, i;
  return Te = null, r5(), e = R, t = xK(), n = wK(), i = bK(t.value, n.value), {
    literal: t.literal + n.literal,
    value: i,
    regex: {
      pattern: t.value,
      flags: n.value
    },
    start: e,
    end: R
  };
}
function _K(e) {
  return e.type === hs || e.type === ha || e.type === lm || e.type === cm;
}
function a5() {
  if (r5(), R >= Ut)
    return {
      type: Vf,
      start: R,
      end: R
    };
  const e = Q.charCodeAt(R);
  return Jf(e) ? gK() : e === 40 || e === 41 || e === 59 ? h1() : e === 39 || e === 34 ? vK() : e === 46 ? jr(Q.charCodeAt(R + 1)) ? R$() : h1() : jr(e) ? R$() : h1();
}
function mn() {
  const e = Te;
  return R = e.end, Te = a5(), R = e.end, e;
}
function s5() {
  const e = R;
  Te = a5(), R = e;
}
function SK(e) {
  const t = new Ii(YV);
  return t.elements = e, t;
}
function L$(e, t, n) {
  const i = new Ii(e === "||" || e === "&&" ? QV : XV);
  return i.operator = e, i.left = t, i.right = n, i;
}
function AK(e, t) {
  const n = new Ii(VV);
  return n.callee = e, n.arguments = t, n;
}
function $K(e, t, n) {
  const i = new Ii(KV);
  return i.test = e, i.consequent = t, i.alternate = n, i;
}
function Sw(e) {
  const t = new Ii(n5);
  return t.name = e, t;
}
function $c(e) {
  const t = new Ii(JV);
  return t.value = e.value, t.raw = Q.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
}
function I$(e, t, n) {
  const i = new Ii(ZV);
  return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i;
}
function kK(e) {
  const t = new Ii(eK);
  return t.properties = e, t;
}
function P$(e, t, n) {
  const i = new Ii(tK);
  return i.key = t, i.value = n, i.kind = e, i;
}
function CK(e, t) {
  const n = new Ii(nK);
  return n.operator = e, n.argument = t, n.prefix = !0, n;
}
function Se(e, t) {
  var n, i = Array.prototype.slice.call(arguments, 2), r = t.replace(/%(\d)/g, (o, a) => (fm(a < i.length, "Message reference must be in range"), i[a]));
  throw n = new Error(r), n.index = R, n.description = r, n;
}
function dm(e) {
  e.type === Vf && Se(e, sK), e.type === Ns && Se(e, iK), e.type === Kf && Se(e, rK), e.type === hs && Se(e, oK), e.type === ha && Se(e, aK), Se(e, gt, e.value);
}
function qt(e) {
  const t = mn();
  (t.type !== dn || t.value !== e) && dm(t);
}
function Be(e) {
  return Te.type === dn && Te.value === e;
}
function p1(e) {
  return Te.type === ha && Te.value === e;
}
function FK() {
  const e = [];
  for (R = Te.start, qt("["); !Be("]"); )
    Be(",") ? (mn(), e.push(null)) : (e.push(ps()), Be("]") || qt(","));
  return mn(), SK(e);
}
function z$() {
  R = Te.start;
  const e = mn();
  return e.type === Kf || e.type === Ns ? (e.octal && Se(e, i5), $c(e)) : Sw(e.value);
}
function MK() {
  var e, t, n, i;
  if (R = Te.start, e = Te, e.type === hs)
    return n = z$(), qt(":"), i = ps(), P$("init", n, i);
  if (e.type === Vf || e.type === dn)
    dm(e);
  else
    return t = z$(), qt(":"), i = ps(), P$("init", t, i);
}
function TK() {
  var e = [], t, n, i, r = {}, o = String;
  for (R = Te.start, qt("{"); !Be("}"); )
    t = MK(), t.key.type === n5 ? n = t.key.name : n = o(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? Se({}, uK) : r[i] = !0, e.push(t), Be("}") || qt(",");
  return qt("}"), kK(e);
}
function OK() {
  qt("(");
  const e = Aw();
  return qt(")"), e;
}
const NK = {
  if: 1
};
function DK() {
  var e, t, n;
  if (Be("("))
    return OK();
  if (Be("["))
    return FK();
  if (Be("{"))
    return TK();
  if (e = Te.type, R = Te.start, e === hs || NK[Te.value])
    n = Sw(mn().value);
  else if (e === Kf || e === Ns)
    Te.octal && Se(Te, i5), n = $c(mn());
  else {
    if (e === ha)
      throw new Error(lf);
    e === lm ? (t = mn(), t.value = t.value === "true", n = $c(t)) : e === cm ? (t = mn(), t.value = null, n = $c(t)) : Be("/") || Be("/=") ? (n = $c(EK()), s5()) : dm(mn());
  }
  return n;
}
function RK() {
  const e = [];
  if (qt("("), !Be(")"))
    for (; R < Ut && (e.push(ps()), !Be(")")); )
      qt(",");
  return qt(")"), e;
}
function LK() {
  R = Te.start;
  const e = mn();
  return _K(e) || dm(e), Sw(e.value);
}
function IK() {
  return qt("."), LK();
}
function PK() {
  qt("[");
  const e = Aw();
  return qt("]"), e;
}
function zK() {
  var e, t, n;
  for (e = DK(); ; )
    if (Be("."))
      n = IK(), e = I$(".", e, n);
    else if (Be("("))
      t = RK(), e = AK(e, t);
    else if (Be("["))
      n = PK(), e = I$("[", e, n);
    else
      break;
  return e;
}
function B$() {
  const e = zK();
  if (Te.type === dn && (Be("++") || Be("--")))
    throw new Error(lf);
  return e;
}
function bh() {
  var e, t;
  if (Te.type !== dn && Te.type !== ha)
    t = B$();
  else {
    if (Be("++") || Be("--"))
      throw new Error(lf);
    if (Be("+") || Be("-") || Be("~") || Be("!"))
      e = mn(), t = bh(), t = CK(e.value, t);
    else {
      if (p1("delete") || p1("void") || p1("typeof"))
        throw new Error(lf);
      t = B$();
    }
  }
  return t;
}
function j$(e) {
  let t = 0;
  if (e.type !== dn && e.type !== ha)
    return 0;
  switch (e.value) {
    case "||":
      t = 1;
      break;
    case "&&":
      t = 2;
      break;
    case "|":
      t = 3;
      break;
    case "^":
      t = 4;
      break;
    case "&":
      t = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      t = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      t = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      t = 8;
      break;
    case "+":
    case "-":
      t = 9;
      break;
    case "*":
    case "/":
    case "%":
      t = 11;
      break;
  }
  return t;
}
function BK() {
  var e, t, n, i, r, o, a, s, u, l;
  if (e = Te, u = bh(), i = Te, r = j$(i), r === 0)
    return u;
  for (i.prec = r, mn(), t = [e, Te], a = bh(), o = [u, i, a]; (r = j$(Te)) > 0; ) {
    for (; o.length > 2 && r <= o[o.length - 2].prec; )
      a = o.pop(), s = o.pop().value, u = o.pop(), t.pop(), n = L$(s, u, a), o.push(n);
    i = mn(), i.prec = r, o.push(i), t.push(Te), n = bh(), o.push(n);
  }
  for (l = o.length - 1, n = o[l], t.pop(); l > 1; )
    t.pop(), n = L$(o[l - 1].value, o[l - 2], n), l -= 2;
  return n;
}
function ps() {
  var e, t, n;
  return e = BK(), Be("?") && (mn(), t = ps(), qt(":"), n = ps(), e = $K(e, t, n)), e;
}
function Aw() {
  const e = ps();
  if (Be(","))
    throw new Error(lf);
  return e;
}
function $w(e) {
  Q = e, R = 0, Ut = Q.length, Te = null, s5();
  const t = Aw();
  if (Te.type !== Vf)
    throw new Error("Unexpect token after expression.");
  return t;
}
var u5 = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function l5(e) {
  function t(a, s, u, l) {
    let c = e(s[0]);
    return u && (c = u + "(" + c + ")", u.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + a + (l < 0 ? "" : l === 0 ? "()" : "(" + s.slice(1).map(e).join(",") + ")");
  }
  function n(a, s, u) {
    return (l) => t(a, l, s, u);
  }
  const i = "new Date", r = "String", o = "RegExp";
  return {
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(a) {
      a.length < 3 && I("Missing arguments to clamp function."), a.length > 3 && I("Too many arguments to clamp function.");
      const s = a.map(e);
      return "Math.max(" + s[1] + ", Math.min(" + s[2] + "," + s[0] + "))";
    },
    now: "Date.now",
    utc: "Date.UTC",
    datetime: i,
    date: n("getDate", i, 0),
    day: n("getDay", i, 0),
    year: n("getFullYear", i, 0),
    month: n("getMonth", i, 0),
    hours: n("getHours", i, 0),
    minutes: n("getMinutes", i, 0),
    seconds: n("getSeconds", i, 0),
    milliseconds: n("getMilliseconds", i, 0),
    time: n("getTime", i, 0),
    timezoneoffset: n("getTimezoneOffset", i, 0),
    utcdate: n("getUTCDate", i, 0),
    utcday: n("getUTCDay", i, 0),
    utcyear: n("getUTCFullYear", i, 0),
    utcmonth: n("getUTCMonth", i, 0),
    utchours: n("getUTCHours", i, 0),
    utcminutes: n("getUTCMinutes", i, 0),
    utcseconds: n("getUTCSeconds", i, 0),
    utcmilliseconds: n("getUTCMilliseconds", i, 0),
    length: n("length", null, -1),
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: n("toUpperCase", r, 0),
    lower: n("toLowerCase", r, 0),
    substring: n("substring", r),
    split: n("split", r),
    trim: n("trim", r, 0),
    regexp: o,
    test: n("test", o),
    if: function(a) {
      a.length < 3 && I("Missing arguments to if function."), a.length > 3 && I("Too many arguments to if function.");
      const s = a.map(e);
      return "(" + s[0] + "?" + s[1] + ":" + s[2] + ")";
    }
  };
}
function jK(e) {
  const t = e && e.length - 1;
  return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e;
}
function c5(e) {
  e = e || {};
  const t = e.allowed ? Oi(e.allowed) : {}, n = e.forbidden ? Oi(e.forbidden) : {}, i = e.constants || u5, r = (e.functions || l5)(f), o = e.globalvar, a = e.fieldvar, s = fe(o) ? o : (p) => `${o}["${p}"]`;
  let u = {}, l = {}, c = 0;
  function f(p) {
    if (Y(p))
      return p;
    const g = d[p.type];
    return g == null && I("Unsupported type: " + p.type), g(p);
  }
  const d = {
    Literal: (p) => p.raw,
    Identifier: (p) => {
      const g = p.name;
      return c > 0 ? g : ie(n, g) ? I("Illegal identifier: " + g) : ie(i, g) ? i[g] : ie(t, g) ? g : (u[g] = 1, s(g));
    },
    MemberExpression: (p) => {
      const g = !p.computed, m = f(p.object);
      g && (c += 1);
      const y = f(p.property);
      return m === a && (l[jK(y)] = 1), g && (c -= 1), m + (g ? "." + y : "[" + y + "]");
    },
    CallExpression: (p) => {
      p.callee.type !== "Identifier" && I("Illegal callee type: " + p.callee.type);
      const g = p.callee.name, m = p.arguments, y = ie(r, g) && r[g];
      return y || I("Unrecognized function: " + g), fe(y) ? y(m) : y + "(" + m.map(f).join(",") + ")";
    },
    ArrayExpression: (p) => "[" + p.elements.map(f).join(",") + "]",
    BinaryExpression: (p) => "(" + f(p.left) + " " + p.operator + " " + f(p.right) + ")",
    UnaryExpression: (p) => "(" + p.operator + f(p.argument) + ")",
    ConditionalExpression: (p) => "(" + f(p.test) + "?" + f(p.consequent) + ":" + f(p.alternate) + ")",
    LogicalExpression: (p) => "(" + f(p.left) + p.operator + f(p.right) + ")",
    ObjectExpression: (p) => "{" + p.properties.map(f).join(",") + "}",
    Property: (p) => {
      c += 1;
      const g = f(p.key);
      return c -= 1, g + ":" + f(p.value);
    }
  };
  function h(p) {
    const g = {
      code: f(p),
      globals: Object.keys(u),
      fields: Object.keys(l)
    };
    return u = {}, l = {}, g;
  }
  return h.functions = r, h.constants = i, h;
}
function g1(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function UK(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function qK(e) {
  let t, n, i;
  e.length !== 2 ? (t = g1, n = (s, u) => g1(e(s), u), i = (s, u) => e(s) - u) : (t = e === g1 || e === UK ? e : WK, n = e, i = e);
  function r(s, u, l = 0, c = s.length) {
    if (l < c) {
      if (t(u, u) !== 0)
        return c;
      do {
        const f = l + c >>> 1;
        n(s[f], u) < 0 ? l = f + 1 : c = f;
      } while (l < c);
    }
    return l;
  }
  function o(s, u, l = 0, c = s.length) {
    if (l < c) {
      if (t(u, u) !== 0)
        return c;
      do {
        const f = l + c >>> 1;
        n(s[f], u) <= 0 ? l = f + 1 : c = f;
      } while (l < c);
    }
    return l;
  }
  function a(s, u, l = 0, c = s.length) {
    const f = r(s, u, l, c - 1);
    return f > l && i(s[f - 1], u) > -i(s[f], u) ? f - 1 : f;
  }
  return { left: r, center: a, right: o };
}
function WK() {
  return 0;
}
function GK(e, ...t) {
  e = new Th(e), t = t.map(HK);
  e:
    for (const n of e)
      for (const i of t)
        if (!i.has(n)) {
          e.delete(n);
          continue e;
        }
  return e;
}
function HK(e) {
  return e instanceof Th ? e : new Th(e);
}
function YK(...e) {
  const t = new Th();
  for (const n of e)
    for (const i of n)
      t.add(i);
  return t;
}
const kw = "intersect", U$ = "union", XK = "vlMulti", VK = "vlPoint", q$ = "or", KK = "and", Zi = "_vgsid_", ff = En(Zi), JK = "E", QK = "R", ZK = "R-E", eJ = "R-LE", tJ = "R-RE", Pp = "index:unit";
function W$(e, t) {
  for (var n = t.fields, i = t.values, r = n.length, o = 0, a, s; o < r; ++o)
    if (s = n[o], s.getter = En.getter || En(s.field), a = s.getter(e), zo(a) && (a = It(a)), zo(i[o]) && (i[o] = It(i[o])), zo(i[o][0]) && (i[o] = i[o].map(It)), s.type === JK) {
      if (P(i[o]) ? i[o].indexOf(a) < 0 : a !== i[o])
        return !1;
    } else if (s.type === QK) {
      if (!lu(a, i[o]))
        return !1;
    } else if (s.type === tJ) {
      if (!lu(a, i[o], !0, !1))
        return !1;
    } else if (s.type === ZK) {
      if (!lu(a, i[o], !1, !1))
        return !1;
    } else if (s.type === eJ && !lu(a, i[o], !1, !0))
      return !1;
  return !0;
}
function nJ(e, t, n) {
  for (var i = this.context.data[e], r = i ? i.values.value : [], o = i ? i[Pp] && i[Pp].value : void 0, a = n === kw, s = r.length, u = 0, l, c, f, d, h; u < s; ++u)
    if (l = r[u], o && a) {
      if (c = c || {}, f = c[d = l.unit] || 0, f === -1)
        continue;
      if (h = W$(t, l), c[d] = h ? -1 : ++f, h && o.size === 1)
        return !0;
      if (!h && f === o.get(d).count)
        return !1;
    } else if (h = W$(t, l), a ^ h)
      return h;
  return s && a;
}
const f5 = qK(ff), iJ = f5.left, rJ = f5.right;
function oJ(e, t, n) {
  const i = this.context.data[e], r = i ? i.values.value : [], o = i ? i[Pp] && i[Pp].value : void 0, a = n === kw, s = ff(t), u = iJ(r, s);
  if (u === r.length || ff(r[u]) !== s)
    return !1;
  if (o && a) {
    if (o.size === 1)
      return !0;
    if (rJ(r, s) - u < o.size)
      return !1;
  }
  return !0;
}
function aJ(e, t) {
  return e.map((n) => ce(t.fields ? {
    values: t.fields.map((i) => (i.getter || (i.getter = En(i.field)))(n.datum))
  } : {
    [Zi]: ff(n.datum)
  }, t));
}
function sJ(e, t, n, i) {
  for (var r = this.context.data[e], o = r ? r.values.value : [], a = {}, s = {}, u = {}, l, c, f, d, h, p, g, m, y, v, b = o.length, x = 0, E, _; x < b; ++x)
    if (l = o[x], d = l.unit, c = l.fields, f = l.values, c && f) {
      for (E = 0, _ = c.length; E < _; ++E)
        h = c[E], g = a[h.field] || (a[h.field] = {}), m = g[d] || (g[d] = []), u[h.field] = y = h.type.charAt(0), v = m1[`${y}_union`], g[d] = v(m, X(f[E]));
      n && (m = s[d] || (s[d] = []), m.push(X(f).reduce((w, S, C) => (w[c[C].field] = S, w), {})));
    } else
      h = Zi, p = ff(l), g = a[h] || (a[h] = {}), m = g[d] || (g[d] = []), m.push(p), n && (m = s[d] || (s[d] = []), m.push({
        [Zi]: p
      }));
  if (t = t || U$, a[Zi] ? a[Zi] = m1[`${Zi}_${t}`](...Object.values(a[Zi])) : Object.keys(a).forEach((w) => {
    a[w] = Object.keys(a[w]).map((S) => a[w][S]).reduce((S, C) => S === void 0 ? C : m1[`${u[w]}_${t}`](S, C));
  }), o = Object.keys(s), n && o.length) {
    const w = i ? VK : XK;
    a[w] = t === U$ ? {
      [q$]: o.reduce((S, C) => (S.push(...s[C]), S), [])
    } : {
      [KK]: o.map((S) => ({
        [q$]: s[S]
      }))
    };
  }
  return a;
}
var m1 = {
  [`${Zi}_union`]: YK,
  [`${Zi}_intersect`]: GK,
  E_union: function(e, t) {
    if (!e.length)
      return t;
    for (var n = 0, i = t.length; n < i; ++n)
      e.indexOf(t[n]) < 0 && e.push(t[n]);
    return e;
  },
  E_intersect: function(e, t) {
    return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
  },
  R_union: function(e, t) {
    var n = It(t[0]), i = It(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i];
  },
  R_intersect: function(e, t) {
    var n = It(t[0]), i = It(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i];
  }
};
const uJ = ":", lJ = "@";
function Cw(e, t, n, i) {
  t[0].type !== ds && I("First argument to selection functions must be a string literal.");
  const r = t[0].value, o = t.length >= 2 && xe(t).value, a = "unit", s = lJ + a, u = uJ + r;
  o === kw && !ie(i, s) && (i[s] = n.getData(r).indataRef(n, a)), ie(i, u) || (i[u] = n.getData(r).tuplesRef());
}
function d5(e) {
  const t = this.context.data[e];
  return t ? t.values.value : [];
}
function cJ(e, t, n) {
  const i = this.context.data[e]["index:" + t], r = i ? i.value.get(n) : void 0;
  return r && r.count;
}
function fJ(e, t) {
  const n = this.context.dataflow, i = this.context.data[e], r = i.input;
  return n.pulse(r, n.changeset().remove(ei).insert(t)), 1;
}
function dJ(e, t, n) {
  if (e) {
    const i = this.context.dataflow, r = e.mark.source;
    i.pulse(r, i.changeset().encode(e, t));
  }
  return n !== void 0 ? n : e;
}
const Qf = (e) => function(t, n) {
  return this.context.dataflow.locale()[e](n)(t);
}, hJ = Qf("format"), h5 = Qf("timeFormat"), pJ = Qf("utcFormat"), gJ = Qf("timeParse"), mJ = Qf("utcParse"), zd = new Date(2e3, 0, 1);
function hm(e, t, n) {
  return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (zd.setYear(2e3), zd.setMonth(e), zd.setDate(t), h5.call(this, zd, n));
}
function yJ(e) {
  return hm.call(this, e, 1, "%B");
}
function vJ(e) {
  return hm.call(this, e, 1, "%b");
}
function bJ(e) {
  return hm.call(this, 0, 2 + e, "%A");
}
function xJ(e) {
  return hm.call(this, 0, 2 + e, "%a");
}
const wJ = ":", EJ = "@", vv = "%", p5 = "$";
function Fw(e, t, n, i) {
  t[0].type !== ds && I("First argument to data functions must be a string literal.");
  const r = t[0].value, o = wJ + r;
  if (!ie(o, i))
    try {
      i[o] = n.getData(r).tuplesRef();
    } catch {
    }
}
function _J(e, t, n, i) {
  t[0].type !== ds && I("First argument to indata must be a string literal."), t[1].type !== ds && I("Second argument to indata must be a string literal.");
  const r = t[0].value, o = t[1].value, a = EJ + o;
  ie(a, i) || (i[a] = n.getData(r).indataRef(n, o));
}
function vn(e, t, n, i) {
  if (t[0].type === ds)
    G$(n, i, t[0].value);
  else
    for (e in n.scales)
      G$(n, i, e);
}
function G$(e, t, n) {
  const i = vv + n;
  if (!ie(t, i))
    try {
      t[i] = e.scaleRef(n);
    } catch {
    }
}
function co(e, t) {
  if (fe(e))
    return e;
  if (Y(e)) {
    const n = t.scales[e];
    return n && FB(n.value) ? n.value : void 0;
  }
}
function SJ(e, t, n) {
  t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = vn, n._range = vn, n._scale = vn;
  const i = (r) => "_[" + (r.type === ds ? W(vv + r.value) : W(vv) + "+" + e(r)) + "]";
  return {
    _bandwidth: (r) => `this.__bandwidth(${i(r[0])})`,
    _range: (r) => `${i(r[0])}.range()`,
    _scale: (r) => `${i(r[0])}(${e(r[1])})`
  };
}
function Mw(e, t) {
  return function(n, i, r) {
    if (n) {
      const o = co(n, (r || this).context);
      return o && o.path[e](i);
    } else
      return t(i);
  };
}
const AJ = Mw("area", qW), $J = Mw("bounds", YW), kJ = Mw("centroid", ZW);
function CJ(e) {
  const t = this.context.group;
  let n = !1;
  if (t)
    for (; e; ) {
      if (e === t) {
        n = !0;
        break;
      }
      e = e.mark.group;
    }
  return n;
}
function Tw(e, t, n) {
  try {
    e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)));
  } catch (i) {
    e.warn(i);
  }
  return n[n.length - 1];
}
function FJ() {
  return Tw(this.context.dataflow, "warn", arguments);
}
function MJ() {
  return Tw(this.context.dataflow, "info", arguments);
}
function TJ() {
  return Tw(this.context.dataflow, "debug", arguments);
}
function y1(e) {
  const t = e / 255;
  return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function bv(e) {
  const t = Vo(e), n = y1(t.r), i = y1(t.g), r = y1(t.b);
  return 0.2126 * n + 0.7152 * i + 0.0722 * r;
}
function OJ(e, t) {
  const n = bv(e), i = bv(t), r = Math.max(n, i), o = Math.min(n, i);
  return (r + 0.05) / (o + 0.05);
}
function NJ() {
  const e = [].slice.call(arguments);
  return e.unshift({}), ce(...e);
}
function g5(e, t) {
  return e === t || e !== e && t !== t ? !0 : P(e) ? P(t) && e.length === t.length ? DJ(e, t) : !1 : K(e) && K(t) ? m5(e, t) : !1;
}
function DJ(e, t) {
  for (let n = 0, i = e.length; n < i; ++n)
    if (!g5(e[n], t[n]))
      return !1;
  return !0;
}
function m5(e, t) {
  for (const n in e)
    if (!g5(e[n], t[n]))
      return !1;
  return !0;
}
function H$(e) {
  return (t) => m5(e, t);
}
function RJ(e, t, n, i, r, o) {
  const a = this.context.dataflow, s = this.context.data[e], u = s.input, l = a.stamp();
  let c = s.changes, f, d;
  if (a._trigger === !1 || !(u.value.length || t || i))
    return 0;
  if ((!c || c.stamp < l) && (s.changes = c = a.changeset(), c.stamp = l, a.runAfter(() => {
    s.modified = !0, a.pulse(u, c).run();
  }, !0, 1)), n && (f = n === !0 ? ei : P(n) || Eg(n) ? n : H$(n), c.remove(f)), t && c.insert(t), i && (f = H$(i), u.value.some(f) ? c.remove(f) : c.insert(i)), r)
    for (d in o)
      c.modify(r, d, o[d]);
  return 1;
}
function LJ(e) {
  const t = e.touches, n = t[0].clientX - t[1].clientX, i = t[0].clientY - t[1].clientY;
  return Math.hypot(n, i);
}
function IJ(e) {
  const t = e.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
const Y$ = {};
function PJ(e, t) {
  const n = Y$[t] || (Y$[t] = En(t));
  return P(e) ? e.map(n) : n(e);
}
function Ow(e) {
  return P(e) || ArrayBuffer.isView(e) ? e : null;
}
function Nw(e) {
  return Ow(e) || (Y(e) ? e : null);
}
function zJ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return Ow(e).join(...n);
}
function BJ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return Nw(e).indexOf(...n);
}
function jJ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return Nw(e).lastIndexOf(...n);
}
function UJ(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return Nw(e).slice(...n);
}
function qJ(e, t, n) {
  return fe(n) && I("Function argument passed to replace."), String(e).replace(t, n);
}
function WJ(e) {
  return Ow(e).slice().reverse();
}
function GJ(e, t, n) {
  return Ux(e || 0, t || 0, n || 0);
}
function HJ(e, t) {
  const n = co(e, (t || this).context);
  return n && n.bandwidth ? n.bandwidth() : 0;
}
function YJ(e, t) {
  const n = co(e, (t || this).context);
  return n ? n.copy() : void 0;
}
function XJ(e, t) {
  const n = co(e, (t || this).context);
  return n ? n.domain() : [];
}
function VJ(e, t, n) {
  const i = co(e, (n || this).context);
  return i ? P(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
}
function KJ(e, t) {
  const n = co(e, (t || this).context);
  return n && n.range ? n.range() : [];
}
function JJ(e, t, n) {
  const i = co(e, (n || this).context);
  return i ? i(t) : void 0;
}
function QJ(e, t, n, i, r) {
  e = co(e, (r || this).context);
  const o = pO(t, n);
  let a = e.domain(), s = a[0], u = xe(a), l = Wt;
  return u - s ? l = nO(e, s, u) : e = (e.interpolator ? $e("sequential")().interpolator(e.interpolator()) : $e("linear")().interpolate(e.interpolate()).range(e.range())).domain([s = 0, u = 1]), e.ticks && (a = e.ticks(+i || 15), s !== a[0] && a.unshift(s), u !== xe(a) && a.push(u)), a.forEach((c) => o.stop(l(c), e(c))), o;
}
function ZJ(e, t, n) {
  const i = co(e, (n || this).context);
  return function(r) {
    return i ? i.path.context(r)(t) : "";
  };
}
function eQ(e) {
  let t = null;
  return function(n) {
    return n ? ef(n, t = t || Iu(e)) : e;
  };
}
const y5 = (e) => e.data;
function v5(e, t) {
  const n = d5.call(t, e);
  return n.root && n.root.lookup || {};
}
function tQ(e, t, n) {
  const i = v5(e, this), r = i[t], o = i[n];
  return r && o ? r.path(o).map(y5) : void 0;
}
function nQ(e, t) {
  const n = v5(e, this)[t];
  return n ? n.ancestors().map(y5) : void 0;
}
const b5 = () => typeof window < "u" && window || null;
function iQ() {
  const e = b5();
  return e ? e.screen : {};
}
function rQ() {
  const e = b5();
  return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0];
}
function oQ() {
  const e = this.context.dataflow, t = e.container && e.container();
  return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0];
}
function x5(e, t, n) {
  if (!e)
    return [];
  const [i, r] = e, o = new nt().set(i[0], i[1], r[0], r[1]), a = n || this.context.dataflow.scenegraph().root;
  return rN(a, o, aQ(t));
}
function aQ(e) {
  let t = null;
  if (e) {
    const n = X(e.marktype), i = X(e.markname);
    t = (r) => (!n.length || n.some((o) => r.marktype === o)) && (!i.length || i.some((o) => r.name === o));
  }
  return t;
}
function sQ(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  e = X(e);
  const r = e[e.length - 1];
  return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e;
}
function uQ(e) {
  return X(e).reduce((t, n, i) => {
    let [r, o] = n;
    return t += i == 0 ? `M ${r},${o} ` : i === e.length - 1 ? " Z" : `L ${r},${o} `;
  }, "");
}
function lQ(e, t, n) {
  const {
    x: i,
    y: r,
    mark: o
  } = n, a = new nt().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [u, l] of t)
    u < a.x1 && (a.x1 = u), u > a.x2 && (a.x2 = u), l < a.y1 && (a.y1 = l), l > a.y2 && (a.y2 = l);
  return a.translate(i, r), x5([[a.x1, a.y1], [a.x2, a.y2]], e, o).filter((u) => cQ(u.x, u.y, t));
}
function cQ(e, t, n) {
  let i = 0;
  for (let r = 0, o = n.length - 1; r < n.length; o = r++) {
    const [a, s] = n[o], [u, l] = n[r];
    l > t != s > t && e < (a - u) * (t - l) / (s - l) + u && i++;
  }
  return i & 1;
}
const df = {
  random() {
    return ni();
  },
  cumulativeNormal: kg,
  cumulativeLogNormal: Ub,
  cumulativeUniform: Hb,
  densityNormal: Ib,
  densityLogNormal: jb,
  densityUniform: Gb,
  quantileNormal: Cg,
  quantileLogNormal: qb,
  quantileUniform: Yb,
  sampleNormal: $g,
  sampleLogNormal: Bb,
  sampleUniform: Wb,
  isArray: P,
  isBoolean: ua,
  isDate: zo,
  isDefined(e) {
    return e !== void 0;
  },
  isNumber: Oe,
  isObject: K,
  isRegExp: RF,
  isString: Y,
  isTuple: Eg,
  isValid(e) {
    return e != null && e === e;
  },
  toBoolean: mb,
  toDate(e) {
    return yb(e);
  },
  toNumber: It,
  toString: vb,
  indexof: BJ,
  join: zJ,
  lastindexof: jJ,
  replace: qJ,
  reverse: WJ,
  slice: UJ,
  flush: NF,
  lerp: LF,
  merge: NJ,
  pad: zF,
  peek: xe,
  pluck: PJ,
  span: Sf,
  inrange: lu,
  truncate: BF,
  rgb: Vo,
  lab: Gh,
  hcl: Hh,
  hsl: qh,
  luminance: bv,
  contrast: OJ,
  sequence: Pn,
  format: hJ,
  utcFormat: pJ,
  utcParse: mJ,
  utcOffset: bM,
  utcSequence: EM,
  timeFormat: h5,
  timeParse: gJ,
  timeOffset: vM,
  timeSequence: wM,
  timeUnitSpecifier: sM,
  monthFormat: yJ,
  monthAbbrevFormat: vJ,
  dayFormat: bJ,
  dayAbbrevFormat: xJ,
  quarter: FF,
  utcquarter: MF,
  week: lM,
  utcweek: dM,
  dayofyear: uM,
  utcdayofyear: fM,
  warn: FJ,
  info: MJ,
  debug: TJ,
  extent(e) {
    return hr(e);
  },
  inScope: CJ,
  intersect: x5,
  clampRange: TF,
  pinchDistance: LJ,
  pinchAngle: IJ,
  screen: iQ,
  containerSize: oQ,
  windowSize: rQ,
  bandspace: GJ,
  setdata: fJ,
  pathShape: eQ,
  panLinear: AF,
  panLog: $F,
  panPow: kF,
  panSymlog: CF,
  zoomLinear: cb,
  zoomLog: fb,
  zoomPow: Fh,
  zoomSymlog: db,
  encode: dJ,
  modify: RJ,
  lassoAppend: sQ,
  lassoPath: uQ,
  intersectLasso: lQ
}, fQ = ["view", "item", "group", "xy", "x", "y"], dQ = "event.vega.", w5 = "this.", Dw = {}, E5 = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (e) => `_[${W(p5 + e)}]`,
  functions: hQ,
  constants: u5,
  visitors: Dw
}, xv = c5(E5);
function hQ(e) {
  const t = l5(e);
  fQ.forEach((n) => t[n] = dQ + n);
  for (const n in df)
    t[n] = w5 + n;
  return ce(t, SJ(e, df, Dw)), t;
}
function it(e, t, n) {
  return arguments.length === 1 ? df[e] : (df[e] = t, n && (Dw[e] = n), xv && (xv.functions[e] = w5 + e), this);
}
it("bandwidth", HJ, vn);
it("copy", YJ, vn);
it("domain", XJ, vn);
it("range", KJ, vn);
it("invert", VJ, vn);
it("scale", JJ, vn);
it("gradient", QJ, vn);
it("geoArea", AJ, vn);
it("geoBounds", $J, vn);
it("geoCentroid", kJ, vn);
it("geoShape", ZJ, vn);
it("indata", cJ, _J);
it("data", d5, Fw);
it("treePath", tQ, Fw);
it("treeAncestors", nQ, Fw);
it("vlSelectionTest", nJ, Cw);
it("vlSelectionIdTest", oJ, Cw);
it("vlSelectionResolve", sJ, Cw);
it("vlSelectionTuples", aJ);
function vr(e, t) {
  const n = {};
  let i;
  try {
    e = Y(e) ? e : W(e) + "", i = $w(e);
  } catch {
    I("Expression parse error: " + e);
  }
  i.visit((o) => {
    if (o.type !== t5)
      return;
    const a = o.callee.name, s = E5.visitors[a];
    s && s(a, o.arguments, t, n);
  });
  const r = xv(i);
  return r.globals.forEach((o) => {
    const a = p5 + o;
    !ie(n, a) && t.getSignal(o) && (n[a] = t.signalRef(o));
  }), {
    $expr: ce({
      code: r.code
    }, t.options.ast ? {
      ast: i
    } : null),
    $fields: r.fields,
    $params: n
  };
}
function pQ(e) {
  const t = this, n = e.operators || [];
  return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach((i) => t.parseOperator(i)), n.forEach((i) => t.parseOperatorParameters(i)), (e.streams || []).forEach((i) => t.parseStream(i)), (e.updates || []).forEach((i) => t.parseUpdate(i)), t.resolve();
}
const gQ = Oi(["rule"]), X$ = Oi(["group", "image", "rect"]);
function mQ(e, t) {
  let n = "";
  return gQ[t] || (e.x2 && (e.x ? (X$[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (X$[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n;
}
function Rw(e) {
  return (e + "").toLowerCase();
}
function yQ(e) {
  return Rw(e) === "operator";
}
function vQ(e) {
  return Rw(e) === "collect";
}
function Vl(e, t, n) {
  n.endsWith(";") || (n = "return(" + n + ");");
  const i = Function(...t.concat(n));
  return e && e.functions ? i.bind(e.functions) : i;
}
function bQ(e, t, n, i) {
  return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
  : (u > v || v == null) && u != null ? ${i}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
  : v !== v && u === u ? ${i} : `;
}
var xQ = {
  operator: (e, t) => Vl(e, ["_"], t.code),
  parameter: (e, t) => Vl(e, ["datum", "_"], t.code),
  event: (e, t) => Vl(e, ["event"], t.code),
  handler: (e, t) => {
    const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
    return Vl(e, ["_", "event"], n);
  },
  encode: (e, t) => {
    const {
      marktype: n,
      channels: i
    } = t;
    let r = "var o=item,datum=o.datum,m=0,$;";
    for (const o in i) {
      const a = "o[" + W(o) + "]";
      r += `$=${i[o].code};if(${a}!==$)${a}=$,m=1;`;
    }
    return r += mQ(i, n), r += "return m;", Vl(e, ["item", "_"], r);
  },
  codegen: {
    get(e) {
      const t = `[${e.map(W).join("][")}]`, n = Function("_", `return _${t};`);
      return n.path = t, n;
    },
    comparator(e, t) {
      let n;
      const i = (o, a) => {
        const s = t[a];
        let u, l;
        return o.path ? (u = `a${o.path}`, l = `b${o.path}`) : ((n = n || {})["f" + a] = o, u = `this.f${a}(a)`, l = `this.f${a}(b)`), bQ(u, l, -s, s);
      }, r = Function("a", "b", "var u, v; return " + e.map(i).join("") + "0;");
      return n ? r.bind(n) : r;
    }
  }
};
function wQ(e) {
  const t = this;
  yQ(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type);
}
function EQ(e) {
  const t = this;
  if (e.params) {
    const n = t.get(e.id);
    n || I("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
  }
}
function _Q(e, t) {
  t = t || {};
  const n = this;
  for (const i in e) {
    const r = e[i];
    t[i] = P(r) ? r.map((o) => V$(o, n, t)) : V$(r, n, t);
  }
  return t;
}
function V$(e, t, n) {
  if (!e || !K(e))
    return e;
  for (let i = 0, r = K$.length, o; i < r; ++i)
    if (o = K$[i], ie(e, o.key))
      return o.parse(e, t, n);
  return e;
}
var K$ = [{
  key: "$ref",
  parse: SQ
}, {
  key: "$key",
  parse: $Q
}, {
  key: "$expr",
  parse: AQ
}, {
  key: "$field",
  parse: kQ
}, {
  key: "$encode",
  parse: FQ
}, {
  key: "$compare",
  parse: CQ
}, {
  key: "$context",
  parse: MQ
}, {
  key: "$subflow",
  parse: TQ
}, {
  key: "$tupleid",
  parse: OQ
}];
function SQ(e, t) {
  return t.get(e.$ref) || I("Operator not defined: " + e.$ref);
}
function AQ(e, t, n) {
  e.$params && t.parseParameters(e.$params, n);
  const i = "e:" + e.$expr.code;
  return t.fn[i] || (t.fn[i] = Fn(t.parameterExpression(e.$expr), e.$fields));
}
function $Q(e, t) {
  const n = "k:" + e.$key + "_" + !!e.$flat;
  return t.fn[n] || (t.fn[n] = gb(e.$key, e.$flat, t.expr.codegen));
}
function kQ(e, t) {
  if (!e.$field)
    return null;
  const n = "f:" + e.$field + "_" + e.$name;
  return t.fn[n] || (t.fn[n] = En(e.$field, e.$name, t.expr.codegen));
}
function CQ(e, t) {
  const n = "c:" + e.$compare + "_" + e.$order, i = X(e.$compare).map((r) => r && r.$tupleid ? te : r);
  return t.fn[n] || (t.fn[n] = hb(i, e.$order, t.expr.codegen));
}
function FQ(e, t) {
  const n = e.$encode, i = {};
  for (const r in n) {
    const o = n[r];
    i[r] = Fn(t.encodeExpression(o.$expr), o.$fields), i[r].output = o.$output;
  }
  return i;
}
function MQ(e, t) {
  return t;
}
function TQ(e, t) {
  const n = e.$subflow;
  return function(i, r, o) {
    const a = t.fork().parse(n), s = a.get(n.operators[0].id), u = a.signals.parent;
    return u && u.set(o), s.detachSubflow = () => t.detach(a), s;
  };
}
function OQ() {
  return te;
}
function NQ(e) {
  var t = this, n = e.filter != null ? t.eventExpression(e.filter) : void 0, i = e.stream != null ? t.get(e.stream) : void 0, r;
  e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map((o) => t.get(o)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map((o) => t.get(o)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && I("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i);
}
function DQ(e) {
  var t = this, n = K(n = e.source) ? n.$ref : n, i = t.get(n), r = null, o = e.update, a = void 0;
  i || I("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), o && o.$expr && (o.$params && (a = t.parseParameters(o.$params)), o = t.handlerExpression(o.$expr)), t.update(e, i, r, o, a);
}
const RQ = {
  skip: !0
};
function LQ(e) {
  var t = this, n = {};
  if (e.signals) {
    var i = n.signals = {};
    Object.keys(t.signals).forEach((o) => {
      const a = t.signals[o];
      e.signals(o, a) && (i[o] = a.value);
    });
  }
  if (e.data) {
    var r = n.data = {};
    Object.keys(t.data).forEach((o) => {
      const a = t.data[o];
      e.data(o, a) && (r[o] = a.input.value);
    });
  }
  return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map((o) => o.getState(e))), n;
}
function IQ(e) {
  var t = this, n = t.dataflow, i = e.data, r = e.signals;
  Object.keys(r || {}).forEach((o) => {
    n.update(t.signals[o], r[o], RQ);
  }), Object.keys(i || {}).forEach((o) => {
    n.pulse(t.data[o].input, n.changeset().remove(ei).insert(i[o]));
  }), (e.subcontext || []).forEach((o, a) => {
    const s = t.subcontext[a];
    s && s.setState(o);
  });
}
function _5(e, t, n, i) {
  return new S5(e, t, n, i);
}
function S5(e, t, n, i) {
  this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || xQ, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this);
}
function J$(e) {
  this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this);
}
S5.prototype = J$.prototype = {
  fork() {
    const e = new J$(this);
    return (this.subcontext || (this.subcontext = [])).push(e), e;
  },
  detach(e) {
    this.subcontext = this.subcontext.filter((n) => n !== e);
    const t = Object.keys(e.nodes);
    for (const n of t)
      e.nodes[n]._targets = null;
    for (const n of t)
      e.nodes[n].detach();
    e.nodes = null;
  },
  get(e) {
    return this.nodes[e];
  },
  set(e, t) {
    return this.nodes[e] = t;
  },
  add(e, t) {
    const n = this, i = n.dataflow, r = e.value;
    if (n.set(e.id, t), vQ(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
      let o = n.get(e.parent.$ref);
      o ? (i.connect(o, [t]), t.targets().add(o)) : (n.unresolved = n.unresolved || []).push(() => {
        o = n.get(e.parent.$ref), i.connect(o, [t]), t.targets().add(o);
      });
    }
    if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
      for (const o in e.data) {
        const a = n.data[o] || (n.data[o] = {});
        e.data[o].forEach((s) => a[s] = t);
      }
  },
  resolve() {
    return (this.unresolved || []).forEach((e) => e()), delete this.unresolved, this;
  },
  operator(e, t) {
    this.add(e, this.dataflow.add(e.value, t));
  },
  transform(e, t) {
    this.add(e, this.dataflow.add(this.transforms[Rw(t)]));
  },
  stream(e, t) {
    this.set(e.id, t);
  },
  update(e, t, n, i, r) {
    this.dataflow.on(t, n, i, r, e.options);
  },
  operatorExpression(e) {
    return this.expr.operator(this, e);
  },
  parameterExpression(e) {
    return this.expr.parameter(this, e);
  },
  eventExpression(e) {
    return this.expr.event(this, e);
  },
  handlerExpression(e) {
    return this.expr.handler(this, e);
  },
  encodeExpression(e) {
    return this.expr.encode(this, e);
  },
  parse: pQ,
  parseOperator: wQ,
  parseOperatorParameters: EQ,
  parseParameters: _Q,
  parseStream: NQ,
  parseUpdate: DQ,
  getState: LQ,
  setState: IQ
};
function PQ(e) {
  const t = e.container();
  t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), A5(t, e.description()));
}
function A5(e, t) {
  e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t));
}
function zQ(e) {
  e.add(null, (t) => (e._background = t.bg, e._resize = 1, t.bg), {
    bg: e._signals.background
  });
}
const v1 = "default";
function BQ(e) {
  const t = e._signals.cursor || (e._signals.cursor = e.add({
    user: v1,
    item: null
  }));
  e.on(e.events("view", "mousemove"), t, (n, i) => {
    const r = t.value, o = r ? Y(r) ? r : r.user : v1, a = i.item && i.item.cursor || null;
    return r && o === r.user && a == r.item ? r : {
      user: o,
      item: a
    };
  }), e.add(null, function(n) {
    let i = n.cursor, r = this.value;
    return Y(i) || (r = i.item, i = i.user), wv(e, i && i !== v1 ? i : r || i), r;
  }, {
    cursor: t
  });
}
function wv(e, t) {
  const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
  if (n)
    return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t;
}
function zp(e, t) {
  var n = e._runtime.data;
  return ie(n, t) || I("Unrecognized data set: " + t), n[t];
}
function jQ(e, t) {
  return arguments.length < 2 ? zp(this, e).values.value : pm.call(this, e, Ms().remove(ei).insert(t));
}
function pm(e, t) {
  VM(t) || I("Second argument to changes must be a changeset.");
  const n = zp(this, e);
  return n.modified = !0, this.pulse(n.input, t);
}
function UQ(e, t) {
  return pm.call(this, e, Ms().insert(t));
}
function qQ(e, t) {
  return pm.call(this, e, Ms().remove(t));
}
function $5(e) {
  var t = e.padding();
  return Math.max(0, e._viewWidth + t.left + t.right);
}
function k5(e) {
  var t = e.padding();
  return Math.max(0, e._viewHeight + t.top + t.bottom);
}
function gm(e) {
  var t = e.padding(), n = e._origin;
  return [t.left + n[0], t.top + n[1]];
}
function WQ(e) {
  var t = gm(e), n = $5(e), i = k5(e);
  e._renderer.background(e.background()), e._renderer.resize(n, i, t), e._handler.origin(t), e._resizeListeners.forEach((r) => {
    try {
      r(n, i);
    } catch (o) {
      e.error(o);
    }
  });
}
function GQ(e, t, n) {
  var i = e._renderer, r = i && i.canvas(), o, a, s;
  return r && (s = gm(e), a = t.changedTouches ? t.changedTouches[0] : t, o = tm(a, r), o[0] -= s[0], o[1] -= s[1]), t.dataflow = e, t.item = n, t.vega = HQ(e, n, o), t;
}
function HQ(e, t, n) {
  const i = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
  function r(a) {
    var s = i, u;
    if (a) {
      for (u = t; u; u = u.mark.group)
        if (u.mark.name === a) {
          s = u;
          break;
        }
    }
    return s && s.mark && s.mark.interactive ? s : {};
  }
  function o(a) {
    if (!a)
      return n;
    Y(a) && (a = r(a));
    const s = n.slice();
    for (; a; )
      s[0] -= a.x || 0, s[1] -= a.y || 0, a = a.mark && a.mark.group;
    return s;
  }
  return {
    view: Gt(e),
    item: Gt(t || {}),
    group: r,
    xy: o,
    x: (a) => o(a)[0],
    y: (a) => o(a)[1]
  };
}
const Q$ = "view", YQ = "timer", XQ = "window", VQ = {
  trap: !1
};
function KQ(e) {
  const t = ce({
    defaults: {}
  }, e), n = (i, r) => {
    r.forEach((o) => {
      P(i[o]) && (i[o] = Oi(i[o]));
    });
  };
  return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t;
}
function C5(e, t, n, i) {
  e._eventListeners.push({
    type: n,
    sources: X(t),
    handler: i
  });
}
function JQ(e, t) {
  var n = e._eventConfig.defaults, i = n.prevent, r = n.allow;
  return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault();
}
function Bd(e, t, n) {
  const i = e._eventConfig && e._eventConfig[t];
  return i === !1 || K(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
}
function QQ(e, t, n) {
  var i = this, r = new Ag(n), o = function(l, c) {
    i.runAsync(null, () => {
      e === Q$ && JQ(i, t) && l.preventDefault(), r.receive(GQ(i, l, c));
    });
  }, a;
  if (e === YQ)
    Bd(i, "timer", t) && i.timer(o, t);
  else if (e === Q$)
    Bd(i, "view", t) && i.addEventListener(t, o, VQ);
  else if (e === XQ ? Bd(i, "window", t) && typeof window < "u" && (a = [window]) : typeof document < "u" && Bd(i, "selector", t) && (a = Array.from(document.querySelectorAll(e))), !a)
    i.warn("Can not resolve event source: " + e);
  else {
    for (var s = 0, u = a.length; s < u; ++s)
      a[s].addEventListener(t, o);
    C5(i, a, t, o);
  }
  return r;
}
function Z$(e) {
  return e.item;
}
function ek(e) {
  return e.item.mark.source;
}
function tk(e) {
  return function(t, n) {
    return n.vega.view().changeset().encode(n.item, e);
  };
}
function ZQ(e, t) {
  return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "mouseover", Z$), ek, tk(e)), this.on(this.events("view", "mouseout", Z$), ek, tk(t)), this;
}
function eZ() {
  var e = this._tooltip, t = this._timers, n = this._eventListeners, i, r, o;
  for (i = t.length; --i >= 0; )
    t[i].stop();
  for (i = n.length; --i >= 0; )
    for (o = n[i], r = o.sources.length; --r >= 0; )
      o.sources[r].removeEventListener(o.type, o.handler);
  return e && e.call(this, this._handler, null, null, null), this;
}
function zn(e, t, n) {
  const i = document.createElement(e);
  for (const r in t)
    i.setAttribute(r, t[r]);
  return n != null && (i.textContent = n), i;
}
const tZ = "vega-bind", nZ = "vega-bind-name", iZ = "vega-bind-radio";
function rZ(e, t, n) {
  if (!t)
    return;
  const i = n.param;
  let r = n.state;
  return r || (r = n.state = {
    elements: null,
    active: !1,
    set: null,
    update: (a) => {
      a != e.signal(i.signal) && e.runAsync(null, () => {
        r.source = !0, e.signal(i.signal, a);
      });
    }
  }, i.debounce && (r.update = pb(i.debounce, r.update))), (i.input == null && i.element ? oZ : sZ)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
    r.source ? r.source = !1 : r.set(e.signal(i.signal));
  }), r.active = !0), r;
}
function oZ(e, t, n, i) {
  const r = n.event || "input", o = () => e.update(t.value);
  i.signal(n.signal, t.value), t.addEventListener(r, o), C5(i, t, r, o), e.set = (a) => {
    t.value = a, t.dispatchEvent(aZ(r));
  };
}
function aZ(e) {
  return typeof Event < "u" ? new Event(e) : {
    type: e
  };
}
function sZ(e, t, n, i) {
  const r = i.signal(n.signal), o = zn("div", {
    class: tZ
  }), a = n.input === "radio" ? o : o.appendChild(zn("label"));
  a.appendChild(zn("span", {
    class: nZ
  }, n.name || n.signal)), t.appendChild(o);
  let s = uZ;
  switch (n.input) {
    case "checkbox":
      s = lZ;
      break;
    case "select":
      s = cZ;
      break;
    case "radio":
      s = fZ;
      break;
    case "range":
      s = dZ;
      break;
  }
  s(e, a, n, r);
}
function uZ(e, t, n, i) {
  const r = zn("input");
  for (const o in n)
    o !== "signal" && o !== "element" && r.setAttribute(o === "input" ? "type" : o, n[o]);
  r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = (o) => r.value = o;
}
function lZ(e, t, n, i) {
  const r = {
    type: "checkbox",
    name: n.signal
  };
  i && (r.checked = !0);
  const o = zn("input", r);
  t.appendChild(o), o.addEventListener("change", () => e.update(o.checked)), e.elements = [o], e.set = (a) => o.checked = !!a || null;
}
function cZ(e, t, n, i) {
  const r = zn("select", {
    name: n.signal
  }), o = n.labels || [];
  n.options.forEach((a, s) => {
    const u = {
      value: a
    };
    Bp(a, i) && (u.selected = !0), r.appendChild(zn("option", u, (o[s] || a) + ""));
  }), t.appendChild(r), r.addEventListener("change", () => {
    e.update(n.options[r.selectedIndex]);
  }), e.elements = [r], e.set = (a) => {
    for (let s = 0, u = n.options.length; s < u; ++s)
      if (Bp(n.options[s], a)) {
        r.selectedIndex = s;
        return;
      }
  };
}
function fZ(e, t, n, i) {
  const r = zn("span", {
    class: iZ
  }), o = n.labels || [];
  t.appendChild(r), e.elements = n.options.map((a, s) => {
    const u = {
      type: "radio",
      name: n.signal,
      value: a
    };
    Bp(a, i) && (u.checked = !0);
    const l = zn("input", u);
    l.addEventListener("change", () => e.update(a));
    const c = zn("label", {}, (o[s] || a) + "");
    return c.prepend(l), r.appendChild(c), l;
  }), e.set = (a) => {
    const s = e.elements, u = s.length;
    for (let l = 0; l < u; ++l)
      Bp(s[l].value, a) && (s[l].checked = !0);
  };
}
function dZ(e, t, n, i) {
  i = i !== void 0 ? i : (+n.max + +n.min) / 2;
  const r = n.max != null ? n.max : Math.max(100, +i) || 100, o = n.min || Math.min(0, r, +i) || 0, a = n.step || Ho(o, r, 100), s = zn("input", {
    type: "range",
    name: n.signal,
    min: o,
    max: r,
    step: a
  });
  s.value = i;
  const u = zn("span", {}, +i);
  t.appendChild(s), t.appendChild(u);
  const l = () => {
    u.textContent = s.value, e.update(+s.value);
  };
  s.addEventListener("input", l), s.addEventListener("change", l), e.elements = [s], e.set = (c) => {
    s.value = c, u.textContent = c;
  };
}
function Bp(e, t) {
  return e === t || e + "" == t + "";
}
function F5(e, t, n, i, r, o) {
  return t = t || new i(e.loader()), t.initialize(n, $5(e), k5(e), gm(e), r, o).background(e.background());
}
function Lw(e, t) {
  return t ? function() {
    try {
      t.apply(this, arguments);
    } catch (n) {
      e.error(n);
    }
  } : null;
}
function hZ(e, t, n, i) {
  const r = new i(e.loader(), Lw(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, gm(e), e);
  return t && t.handlers().forEach((o) => {
    r.on(o.type, o.handler);
  }), r;
}
function pZ(e, t) {
  const n = this, i = n._renderType, r = n._eventConfig.bind, o = nm(i);
  e = n._el = e ? b1(n, e, !0) : null, PQ(n), o || n.error("Unrecognized renderer type: " + i);
  const a = o.handler || Wf, s = e ? o.renderer : o.headless;
  return n._renderer = s ? F5(n, n._renderer, e, s) : null, n._handler = hZ(n, n._handler, e, a), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = b1(n, t, !0) : e.appendChild(zn("form", {
    class: "vega-bindings"
  })), n._bind.forEach((u) => {
    u.param.element && r !== "container" && (u.element = b1(n, u.param.element, !!u.param.input));
  }), n._bind.forEach((u) => {
    rZ(n, u.element || t, u);
  })), n;
}
function b1(e, t, n) {
  if (typeof t == "string")
    if (typeof document < "u") {
      if (t = document.querySelector(t), !t)
        return e.error("Signal bind element not found: " + t), null;
    } else
      return e.error("DOM document instance not found."), null;
  if (t && n)
    try {
      t.textContent = "";
    } catch (i) {
      t = null, e.error(i);
    }
  return t;
}
const Kl = (e) => +e || 0, gZ = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function nk(e) {
  return K(e) ? {
    top: Kl(e.top),
    bottom: Kl(e.bottom),
    left: Kl(e.left),
    right: Kl(e.right)
  } : gZ(Kl(e));
}
async function Iw(e, t, n, i) {
  const r = nm(t), o = r && r.headless;
  return o || I("Unrecognized renderer type: " + t), await e.runAsync(), F5(e, null, null, o, n, i).renderAsync(e._scenegraph.root);
}
async function mZ(e, t) {
  e !== No.Canvas && e !== No.SVG && e !== No.PNG && I("Unrecognized image type: " + e);
  const n = await Iw(this, e, t);
  return e === No.SVG ? yZ(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png");
}
function yZ(e, t) {
  const n = new Blob([e], {
    type: t
  });
  return window.URL.createObjectURL(n);
}
async function vZ(e, t) {
  return (await Iw(this, No.Canvas, e, t)).canvas();
}
async function bZ(e) {
  return (await Iw(this, No.SVG, e)).svg();
}
function xZ(e, t, n) {
  return _5(e, Tu, df, n).parse(t);
}
function wZ(e) {
  var t = this._runtime.scales;
  return ie(t, e) || I("Unrecognized scale or projection: " + e), t[e].value;
}
var M5 = "width", T5 = "height", Pw = "padding", ik = {
  skip: !0
};
function O5(e, t) {
  var n = e.autosize(), i = e.padding();
  return t - (n && n.contains === Pw ? i.left + i.right : 0);
}
function N5(e, t) {
  var n = e.autosize(), i = e.padding();
  return t - (n && n.contains === Pw ? i.top + i.bottom : 0);
}
function EZ(e) {
  var t = e._signals, n = t[M5], i = t[T5], r = t[Pw];
  function o() {
    e._autosize = e._resize = 1;
  }
  e._resizeWidth = e.add(null, (s) => {
    e._width = s.size, e._viewWidth = O5(e, s.size), o();
  }, {
    size: n
  }), e._resizeHeight = e.add(null, (s) => {
    e._height = s.size, e._viewHeight = N5(e, s.size), o();
  }, {
    size: i
  });
  const a = e.add(null, o, {
    pad: r
  });
  e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, a.rank = r.rank + 1;
}
function _Z(e, t, n, i, r, o) {
  this.runAfter((a) => {
    let s = 0;
    a._autosize = 0, a.width() !== n && (s = 1, a.signal(M5, n, ik), a._resizeWidth.skip(!0)), a.height() !== i && (s = 1, a.signal(T5, i, ik), a._resizeHeight.skip(!0)), a._viewWidth !== e && (a._resize = 1, a._viewWidth = e), a._viewHeight !== t && (a._resize = 1, a._viewHeight = t), (a._origin[0] !== r[0] || a._origin[1] !== r[1]) && (a._resize = 1, a._origin = r), s && a.run("enter"), o && a.runAfter((u) => u.resize());
  }, !1, 1);
}
function SZ(e) {
  return this._runtime.getState(e || {
    data: AZ,
    signals: $Z,
    recurse: !0
  });
}
function AZ(e, t) {
  return t.modified && P(t.input.value) && e.indexOf("_:vega:_");
}
function $Z(e, t) {
  return !(e === "parent" || t instanceof Tu.proxy);
}
function kZ(e) {
  return this.runAsync(null, (t) => {
    t._trigger = !1, t._runtime.setState(e);
  }, (t) => {
    t._trigger = !0;
  }), this;
}
function CZ(e, t) {
  function n(i) {
    e({
      timestamp: Date.now(),
      elapsed: i
    });
  }
  this._timers.push(tY(n, t));
}
function FZ(e, t, n, i) {
  const r = e.element();
  r && r.setAttribute("title", MZ(i));
}
function MZ(e) {
  return e == null ? "" : P(e) ? D5(e) : K(e) && !zo(e) ? TZ(e) : e + "";
}
function TZ(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return t + ": " + (P(n) ? D5(n) : R5(n));
  }).join(`
`);
}
function D5(e) {
  return "[" + e.map(R5).join(", ") + "]";
}
function R5(e) {
  return P(e) ? "[\u2026]" : K(e) && !zo(e) ? "{\u2026}" : e;
}
function L5(e, t) {
  const n = this;
  if (t = t || {}, gu.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
    const o = ce({}, e.locale, t.locale);
    n.locale(zM(o.number, o.time));
  }
  n._el = null, n._elBind = null, n._renderType = t.renderer || No.Canvas, n._scenegraph = new v2();
  const i = n._scenegraph.root;
  n._renderer = null, n._tooltip = t.tooltip || FZ, n._redraw = !0, n._handler = new Wf().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = KQ(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
  const r = xZ(n, e, t.expr);
  n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map((o) => ({
    state: null,
    param: ce({}, o)
  })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = O5(n, n._width), n._viewHeight = N5(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, EZ(n), zQ(n), BQ(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind);
}
function jd(e, t) {
  return ie(e._signals, t) ? e._signals[t] : I("Unrecognized signal name: " + W(t));
}
function I5(e, t) {
  const n = (e._targets || []).filter((i) => i._update && i._update.handler === t);
  return n.length ? n[0] : null;
}
function rk(e, t, n, i) {
  let r = I5(n, i);
  return r || (r = Lw(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e;
}
function ok(e, t, n) {
  const i = I5(t, n);
  return i && t._targets.remove(i), e;
}
G(L5, gu, {
  async evaluate(e, t, n) {
    if (await gu.prototype.evaluate.call(this, e, t), this._redraw || this._resize)
      try {
        this._renderer && (this._resize && (this._resize = 0, WQ(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
      } catch (i) {
        this.error(i);
      }
    return n && ih(this, n), this;
  },
  dirty(e) {
    this._redraw = !0, this._renderer && this._renderer.dirty(e);
  },
  description(e) {
    if (arguments.length) {
      const t = e != null ? e + "" : null;
      return t !== this._desc && A5(this._el, this._desc = t), this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(e, t, n) {
    const i = jd(this, e);
    return arguments.length === 1 ? i.value : this.update(i, t, n);
  },
  width(e) {
    return arguments.length ? this.signal("width", e) : this.signal("width");
  },
  height(e) {
    return arguments.length ? this.signal("height", e) : this.signal("height");
  },
  padding(e) {
    return arguments.length ? this.signal("padding", nk(e)) : nk(this.signal("padding"));
  },
  autosize(e) {
    return arguments.length ? this.signal("autosize", e) : this.signal("autosize");
  },
  background(e) {
    return arguments.length ? this.signal("background", e) : this.signal("background");
  },
  renderer(e) {
    return arguments.length ? (nm(e) || I("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
  },
  tooltip(e) {
    return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip;
  },
  loader(e) {
    return arguments.length ? (e !== this._loader && (gu.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader;
  },
  resize() {
    return this._autosize = 1, this.touch(jd(this, "autosize"));
  },
  _resetRenderer() {
    this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind));
  },
  _resizeView: _Z,
  addEventListener(e, t, n) {
    let i = t;
    return n && n.trap === !1 || (i = Lw(this, t), i.raw = t), this._handler.on(e, i), this;
  },
  removeEventListener(e, t) {
    for (var n = this._handler.handlers(e), i = n.length, r, o; --i >= 0; )
      if (o = n[i].type, r = n[i].handler, e === o && (t === r || t === r.raw)) {
        this._handler.off(o, r);
        break;
      }
    return this;
  },
  addResizeListener(e) {
    const t = this._resizeListeners;
    return t.indexOf(e) < 0 && t.push(e), this;
  },
  removeResizeListener(e) {
    var t = this._resizeListeners, n = t.indexOf(e);
    return n >= 0 && t.splice(n, 1), this;
  },
  addSignalListener(e, t) {
    return rk(this, e, jd(this, e), t);
  },
  removeSignalListener(e, t) {
    return ok(this, jd(this, e), t);
  },
  addDataListener(e, t) {
    return rk(this, e, zp(this, e).values, t);
  },
  removeDataListener(e, t) {
    return ok(this, zp(this, e).values, t);
  },
  globalCursor(e) {
    if (arguments.length) {
      if (this._globalCursor !== !!e) {
        const t = wv(this, null);
        this._globalCursor = !!e, t && wv(this, t);
      }
      return this;
    } else
      return this._globalCursor;
  },
  preventDefault(e) {
    return arguments.length ? (this._preventDefault = e, this) : this._preventDefault;
  },
  timer: CZ,
  events: QQ,
  finalize: eZ,
  hover: ZQ,
  data: jQ,
  change: pm,
  insert: UQ,
  remove: qQ,
  scale: wZ,
  initialize: pZ,
  toImageURL: mZ,
  toCanvas: vZ,
  toSVG: bZ,
  getState: SZ,
  setState: kZ
});
const OZ = "view", jp = "[", Up = "]", P5 = "{", z5 = "}", NZ = ":", B5 = ",", DZ = "@", RZ = ">", LZ = /[[\]{}]/, IZ = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let j5, U5;
function pa(e, t, n) {
  return j5 = t || OZ, U5 = n || IZ, q5(e.trim()).map(Ev);
}
function PZ(e) {
  return U5[e];
}
function Bc(e, t, n, i, r) {
  const o = e.length;
  let a = 0, s;
  for (; t < o; ++t) {
    if (s = e[t], !a && s === n)
      return t;
    r && r.indexOf(s) >= 0 ? --a : i && i.indexOf(s) >= 0 && ++a;
  }
  return t;
}
function q5(e) {
  const t = [], n = e.length;
  let i = 0, r = 0;
  for (; r < n; )
    r = Bc(e, r, B5, jp + P5, Up + z5), t.push(e.substring(i, r).trim()), i = ++r;
  if (t.length === 0)
    throw "Empty event selector: " + e;
  return t;
}
function Ev(e) {
  return e[0] === "[" ? zZ(e) : BZ(e);
}
function zZ(e) {
  const t = e.length;
  let n = 1, i;
  if (n = Bc(e, n, Up, jp, Up), n === t)
    throw "Empty between selector: " + e;
  if (i = q5(e.substring(1, n)), i.length !== 2)
    throw "Between selector must have two elements: " + e;
  if (e = e.slice(n + 1).trim(), e[0] !== RZ)
    throw "Expected '>' after between selector: " + e;
  i = i.map(Ev);
  const r = Ev(e.slice(1).trim());
  return r.between ? {
    between: i,
    stream: r
  } : (r.between = i, r);
}
function BZ(e) {
  const t = {
    source: j5
  }, n = [];
  let i = [0, 0], r = 0, o = 0, a = e.length, s = 0, u, l;
  if (e[a - 1] === z5) {
    if (s = e.lastIndexOf(P5), s >= 0) {
      try {
        i = jZ(e.substring(s + 1, a - 1));
      } catch {
        throw "Invalid throttle specification: " + e;
      }
      e = e.slice(0, s).trim(), a = e.length;
    } else
      throw "Unmatched right brace: " + e;
    s = 0;
  }
  if (!a)
    throw e;
  if (e[0] === DZ && (r = ++s), u = Bc(e, s, NZ), u < a && (n.push(e.substring(o, u).trim()), o = s = ++u), s = Bc(e, s, jp), s === a)
    n.push(e.substring(o, a).trim());
  else if (n.push(e.substring(o, s).trim()), l = [], o = ++s, o === a)
    throw "Unmatched left bracket: " + e;
  for (; s < a; ) {
    if (s = Bc(e, s, Up), s === a)
      throw "Unmatched left bracket: " + e;
    if (l.push(e.substring(o, s).trim()), s < a - 1 && e[++s] !== jp)
      throw "Expected left bracket: " + e;
    o = ++s;
  }
  if (!(a = n.length) || LZ.test(n[a - 1]))
    throw "Invalid event selector: " + e;
  return a > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : PZ(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), l != null && (t.filter = l), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t;
}
function jZ(e) {
  const t = e.split(B5);
  if (!e.length || t.length > 2)
    throw e;
  return t.map((n) => {
    const i = +n;
    if (i !== i)
      throw e;
    return i;
  });
}
function UZ(e) {
  return K(e) ? e : {
    type: e || "pad"
  };
}
const Jl = (e) => +e || 0, qZ = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function WZ(e) {
  return K(e) ? e.signal ? e : {
    top: Jl(e.top),
    bottom: Jl(e.bottom),
    left: Jl(e.left),
    right: Jl(e.right)
  } : qZ(Jl(e));
}
const mt = (e) => K(e) && !P(e) ? ce({}, e) : {
  value: e
};
function ak(e, t, n, i) {
  return n != null ? (K(n) && !P(n) || P(n) && n.length && K(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
    value: n
  }, 1) : 0;
}
function Ct(e, t, n) {
  for (const i in t)
    ak(e, i, t[i]);
  for (const i in n)
    ak(e, i, n[i], "update");
}
function wl(e, t, n) {
  for (const i in t)
    n && ie(n, i) || (e[i] = ce(e[i] || {}, t[i]));
  return e;
}
function su(e, t) {
  return t && (t.enter && t.enter[e] || t.update && t.update[e]);
}
const zw = "mark", Bw = "frame", jw = "scope", GZ = "axis", HZ = "axis-domain", YZ = "axis-grid", XZ = "axis-label", VZ = "axis-tick", KZ = "axis-title", JZ = "legend", QZ = "legend-band", ZZ = "legend-entry", eee = "legend-gradient", W5 = "legend-label", tee = "legend-symbol", nee = "legend-title", iee = "title", ree = "title-text", oee = "title-subtitle";
function aee(e, t, n, i, r) {
  const o = {}, a = {};
  let s, u, l, c;
  u = "lineBreak", t === "text" && r[u] != null && !su(u, e) && x1(o, u, r[u]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === Bw ? r.group : n === zw ? ce({}, r.mark, r[t]) : null;
  for (u in c)
    l = su(u, e) || (u === "fill" || u === "stroke") && (su("fill", e) || su("stroke", e)), l || x1(o, u, c[u]);
  X(i).forEach((f) => {
    const d = r.style && r.style[f];
    for (const h in d)
      su(h, e) || x1(o, h, d[h]);
  }), e = ce({}, e);
  for (u in o)
    c = o[u], c.signal ? (s = s || {})[u] = c : a[u] = c;
  return e.enter = ce(a, e.enter), s && (e.update = ce(s, e.update)), e;
}
function x1(e, t, n) {
  e[t] = n && n.signal ? {
    signal: n.signal
  } : {
    value: n
  };
}
const G5 = (e) => Y(e) ? W(e) : e.signal ? `(${e.signal})` : H5(e);
function mm(e) {
  if (e.gradient != null)
    return uee(e);
  let t = e.signal ? `(${e.signal})` : e.color ? see(e.color) : e.field != null ? H5(e.field) : e.value !== void 0 ? W(e.value) : void 0;
  return e.scale != null && (t = lee(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${xh(e.exponent)})`), e.mult != null && (t += `*${xh(e.mult)}`), e.offset != null && (t += `+${xh(e.offset)}`), e.round && (t = `round(${t})`), t;
}
const Ud = (e, t, n, i) => `(${e}(${[t, n, i].map(mm).join(",")})+'')`;
function see(e) {
  return e.c ? Ud("hcl", e.h, e.c, e.l) : e.h || e.s ? Ud("hsl", e.h, e.s, e.l) : e.l || e.a ? Ud("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? Ud("rgb", e.r, e.g, e.b) : null;
}
function uee(e) {
  const t = [e.start, e.stop, e.count].map((n) => n == null ? null : W(n));
  for (; t.length && xe(t) == null; )
    t.pop();
  return t.unshift(G5(e.gradient)), `gradient(${t.join(",")})`;
}
function xh(e) {
  return K(e) ? "(" + mm(e) + ")" : e;
}
function H5(e) {
  return Y5(K(e) ? e : {
    datum: e
  });
}
function Y5(e) {
  let t, n, i;
  if (e.signal)
    t = "datum", i = e.signal;
  else if (e.group || e.parent) {
    for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0; )
      t += ".mark.group";
    e.parent ? (i = e.parent, t += ".datum") : i = e.group;
  } else
    e.datum ? (t = "datum", i = e.datum) : I("Invalid field reference: " + W(e));
  return e.signal || (i = Y(i) ? Er(i).map(W).join("][") : Y5(i)), t + "[" + i + "]";
}
function lee(e, t) {
  const n = G5(e.scale);
  return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + xh(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t;
}
function cee(e) {
  let t = "";
  return e.forEach((n) => {
    const i = mm(n);
    t += n.test ? `(${n.test})?${i}:` : i;
  }), xe(t) === ":" && (t += "null"), t;
}
function X5(e, t, n, i, r, o) {
  const a = {};
  o = o || {}, o.encoders = {
    $encode: a
  }, e = aee(e, t, n, i, r.config);
  for (const s in e)
    a[s] = fee(e[s], t, o, r);
  return o;
}
function fee(e, t, n, i) {
  const r = {}, o = {};
  for (const a in e)
    e[a] != null && (r[a] = hee(dee(e[a]), i, n, o));
  return {
    $expr: {
      marktype: t,
      channels: r
    },
    $fields: Object.keys(o),
    $output: Object.keys(e)
  };
}
function dee(e) {
  return P(e) ? cee(e) : mm(e);
}
function hee(e, t, n, i) {
  const r = vr(e, t);
  return r.$fields.forEach((o) => i[o] = 1), ce(n, r.$params), r.$expr;
}
const pee = "outer", gee = ["value", "update", "init", "react", "bind"];
function sk(e, t) {
  I(e + ' for "outer" push: ' + W(t));
}
function V5(e, t) {
  const n = e.name;
  if (e.push === pee)
    t.signals[n] || sk("No prior signal definition", n), gee.forEach((i) => {
      e[i] !== void 0 && sk("Invalid property ", i);
    });
  else {
    const i = t.addSignal(n, e.value);
    e.react === !1 && (i.react = !1), e.bind && t.addBinding(n, e.bind);
  }
}
function _v(e, t, n, i) {
  this.id = -1, this.type = e, this.value = t, this.params = n, i && (this.parent = i);
}
function ym(e, t, n, i) {
  return new _v(e, t, n, i);
}
function qp(e, t) {
  return ym("operator", e, t);
}
function ee(e) {
  const t = {
    $ref: e.id
  };
  return e.id < 0 && (e.refs = e.refs || []).push(t), t;
}
function hf(e, t) {
  return t ? {
    $field: e,
    $name: t
  } : {
    $field: e
  };
}
const Sv = hf("key");
function uk(e, t) {
  return {
    $compare: e,
    $order: t
  };
}
function mee(e, t) {
  const n = {
    $key: e
  };
  return t && (n.$flat = !0), n;
}
const yee = "ascending", vee = "descending";
function bee(e) {
  return K(e) ? (e.order === vee ? "-" : "+") + vm(e.op, e.field) : "";
}
function vm(e, t) {
  return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "");
}
const Uw = "scope", Av = "view";
function ut(e) {
  return e && e.signal;
}
function xee(e) {
  return e && e.expr;
}
function wh(e) {
  if (ut(e))
    return !0;
  if (K(e)) {
    for (const t in e)
      if (wh(e[t]))
        return !0;
  }
  return !1;
}
function pi(e, t) {
  return e != null ? e : t;
}
function es(e) {
  return e && e.signal || e;
}
const lk = "timer";
function pf(e, t) {
  return (e.merge ? Eee : e.stream ? _ee : e.type ? See : I("Invalid stream specification: " + W(e)))(e, t);
}
function wee(e) {
  return e === Uw ? Av : e || Av;
}
function Eee(e, t) {
  const n = e.merge.map((r) => pf(r, t)), i = qw({
    merge: n
  }, e, t);
  return t.addStream(i).id;
}
function _ee(e, t) {
  const n = pf(e.stream, t), i = qw({
    stream: n
  }, e, t);
  return t.addStream(i).id;
}
function See(e, t) {
  let n;
  e.type === lk ? (n = t.event(lk, e.throttle), e = {
    between: e.between,
    filter: e.filter
  }) : n = t.event(wee(e.source), e.type);
  const i = qw({
    stream: n
  }, e, t);
  return Object.keys(i).length === 1 ? n : t.addStream(i).id;
}
function qw(e, t, n) {
  let i = t.between;
  return i && (i.length !== 2 && I('Stream "between" parameter must have 2 entries: ' + W(t)), e.between = [pf(i[0], n), pf(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(Aee(t.marktype, t.markname, t.markrole)), t.source === Uw && i.push("inScope(event.item)"), i.length && (e.filter = vr("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e;
}
function Aee(e, t, n) {
  const i = "event.item";
  return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "");
}
const $ee = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function kee(e, t, n) {
  const i = e.encode, r = {
    target: n
  };
  let o = e.events, a = e.update, s = [];
  o || I("Signal update missing events specification."), Y(o) && (o = pa(o, t.isSubscope() ? Uw : Av)), o = X(o).filter((u) => u.signal || u.scale ? (s.push(u), 0) : 1), s.length > 1 && (s = [Fee(s)]), o.length && s.push(o.length > 1 ? {
    merge: o
  } : o[0]), i != null && (a && I("Signal encode and update are mutually exclusive."), a = "encode(item()," + W(i) + ")"), r.update = Y(a) ? vr(a, t) : a.expr != null ? vr(a.expr, t) : a.value != null ? a.value : a.signal != null ? {
    $expr: $ee,
    $params: {
      $value: t.signalRef(a.signal)
    }
  } : I("Invalid signal update specification."), e.force && (r.options = {
    force: !0
  }), s.forEach((u) => t.addUpdate(ce(Cee(u, t), r)));
}
function Cee(e, t) {
  return {
    source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : pf(e, t)
  };
}
function Fee(e) {
  return {
    signal: "[" + e.map((t) => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
  };
}
function Mee(e, t) {
  const n = t.getSignal(e.name);
  let i = e.update;
  e.init && (i ? I("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = vr(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach((r) => kee(r, t, n.id));
}
const Re = (e) => (t, n, i) => ym(e, n, t || void 0, i), K5 = Re("aggregate"), Tee = Re("axisticks"), J5 = Re("bound"), Pi = Re("collect"), ck = Re("compare"), Oee = Re("datajoin"), Q5 = Re("encode"), Nee = Re("expression"), Dee = Re("facet"), Ree = Re("field"), Lee = Re("key"), Iee = Re("legendentries"), Pee = Re("load"), zee = Re("mark"), Bee = Re("multiextent"), jee = Re("multivalues"), Uee = Re("overlap"), qee = Re("params"), Z5 = Re("prefacet"), Wee = Re("projection"), Gee = Re("proxy"), Hee = Re("relay"), eR = Re("render"), Yee = Re("scale"), Ds = Re("sieve"), Xee = Re("sortitems"), tR = Re("viewlayout"), Vee = Re("values");
let Kee = 0;
const nR = {
  min: "min",
  max: "max",
  count: "sum"
};
function Jee(e, t) {
  const n = e.type || "linear";
  K3(n) || I("Unrecognized scale type: " + W(n)), t.addScale(e.name, {
    type: n,
    domain: void 0
  });
}
function Qee(e, t) {
  const n = t.getScale(e.name).params;
  let i;
  n.domain = iR(e.domain, e, t), e.range != null && (n.range = oR(e, t, n)), e.interpolate != null && ute(e.interpolate, n), e.nice != null && (n.nice = ste(e.nice)), e.bins != null && (n.bins = ate(e.bins, t));
  for (i in e)
    ie(n, i) || i === "name" || (n[i] = Kn(e[i], t));
}
function Kn(e, t) {
  return K(e) ? e.signal ? t.signalRef(e.signal) : I("Unsupported object: " + W(e)) : e;
}
function Eh(e, t) {
  return e.signal ? t.signalRef(e.signal) : e.map((n) => Kn(n, t));
}
function bm(e) {
  I("Can not find data set: " + W(e));
}
function iR(e, t, n) {
  if (!e) {
    (t.domainMin != null || t.domainMax != null) && I("No scale domain defined for domainMin/domainMax to override.");
    return;
  }
  return e.signal ? n.signalRef(e.signal) : (P(e) ? Zee : e.fields ? tte : ete)(e, t, n);
}
function Zee(e, t, n) {
  return e.map((i) => Kn(i, n));
}
function ete(e, t, n) {
  const i = n.getData(e.data);
  return i || bm(e.data), Lu(t.type) ? i.valuesRef(n, e.field, rR(e.sort, !1)) : Z3(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field);
}
function tte(e, t, n) {
  const i = e.data, r = e.fields.reduce((o, a) => (a = Y(a) ? {
    data: i,
    field: a
  } : P(a) || a.signal ? nte(a, n) : a, o.push(a), o), []);
  return (Lu(t.type) ? ite : Z3(t.type) ? rte : ote)(e, n, r);
}
function nte(e, t) {
  const n = "_:vega:_" + Kee++, i = Pi({});
  if (P(e))
    i.value = {
      $ingest: e
    };
  else if (e.signal) {
    const r = "setdata(" + W(n) + "," + e.signal + ")";
    i.params.input = t.signalRef(r);
  }
  return t.addDataPipeline(n, [i, Ds({})]), {
    data: n,
    field: "data"
  };
}
function ite(e, t, n) {
  const i = rR(e.sort, !0);
  let r, o;
  const a = n.map((l) => {
    const c = t.getData(l.data);
    return c || bm(l.data), c.countsRef(t, l.field, i);
  }), s = {
    groupby: Sv,
    pulse: a
  };
  i && (r = i.op || "count", o = i.field ? vm(r, i.field) : "count", s.ops = [nR[r]], s.fields = [t.fieldRef(o)], s.as = [o]), r = t.add(K5(s));
  const u = t.add(Pi({
    pulse: ee(r)
  }));
  return o = t.add(Vee({
    field: Sv,
    sort: t.sortRef(i),
    pulse: ee(u)
  })), ee(o);
}
function rR(e, t) {
  return e && (!e.field && !e.op ? K(e) ? e.field = "key" : e = {
    field: "key"
  } : !e.field && e.op !== "count" ? I("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !nR[e.op] && I("Multiple domain scales can not be sorted using " + e.op)), e;
}
function rte(e, t, n) {
  const i = n.map((r) => {
    const o = t.getData(r.data);
    return o || bm(r.data), o.domainRef(t, r.field);
  });
  return ee(t.add(jee({
    values: i
  })));
}
function ote(e, t, n) {
  const i = n.map((r) => {
    const o = t.getData(r.data);
    return o || bm(r.data), o.extentRef(t, r.field);
  });
  return ee(t.add(Bee({
    extents: i
  })));
}
function ate(e, t) {
  return e.signal || P(e) ? Eh(e, t) : t.objectProperty(e);
}
function ste(e) {
  return K(e) ? {
    interval: Kn(e.interval),
    step: Kn(e.step)
  } : Kn(e);
}
function ute(e, t) {
  t.interpolate = Kn(e.type || e), e.gamma != null && (t.interpolateGamma = Kn(e.gamma));
}
function oR(e, t, n) {
  const i = t.config.range;
  let r = e.range;
  if (r.signal)
    return t.signalRef(r.signal);
  if (Y(r)) {
    if (i && ie(i, r))
      return e = ce({}, e, {
        range: i[r]
      }), oR(e, t, n);
    r === "width" ? r = [0, {
      signal: "width"
    }] : r === "height" ? r = Lu(e.type) ? [0, {
      signal: "height"
    }] : [{
      signal: "height"
    }, 0] : I("Unrecognized scale range value: " + W(r));
  } else if (r.scheme) {
    n.scheme = P(r.scheme) ? Eh(r.scheme, t) : Kn(r.scheme, t), r.extent && (n.schemeExtent = Eh(r.extent, t)), r.count && (n.schemeCount = Kn(r.count, t));
    return;
  } else if (r.step) {
    n.rangeStep = Kn(r.step, t);
    return;
  } else {
    if (Lu(e.type) && !P(r))
      return iR(r, e, t);
    P(r) || I("Unsupported range type: " + W(r));
  }
  return r.map((o) => (P(o) ? Eh : Kn)(o, t));
}
function lte(e, t) {
  const n = t.config.projection || {}, i = {};
  for (const r in e)
    r !== "name" && (i[r] = $v(e[r], r, t));
  for (const r in n)
    i[r] == null && (i[r] = $v(n[r], r, t));
  t.addProjection(e.name, i);
}
function $v(e, t, n) {
  return P(e) ? e.map((i) => $v(i, t, n)) : K(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : I("Unsupported parameter object: " + W(e)) : e;
}
const zi = "top", El = "left", _l = "right", ta = "bottom", aR = "center", cte = "vertical", fte = "start", dte = "middle", hte = "end", kv = "index", Ww = "label", pte = "offset", Hu = "perc", gte = "perc2", Qn = "value", Zf = "guide-label", Gw = "guide-title", mte = "group-title", yte = "group-subtitle", fk = "symbol", _h = "gradient", Cv = "discrete", Fv = "size", vte = "shape", bte = "fill", xte = "stroke", wte = "strokeWidth", Ete = "strokeDash", _te = "opacity", Hw = [Fv, vte, bte, xte, wte, Ete, _te], ed = {
  name: 1,
  style: 1,
  interactive: 1
}, we = {
  value: 0
}, Zn = {
  value: 1
}, xm = "group", sR = "rect", Yw = "rule", Ste = "symbol", Rs = "text";
function gf(e) {
  return e.type = xm, e.interactive = e.interactive || !1, e;
}
function Mn(e, t) {
  const n = (i, r) => pi(e[i], pi(t[i], r));
  return n.isVertical = (i) => cte === pi(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => pi(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => pi(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => pi(e.columns, pi(t.columns, +n.isVertical(!0))), n;
}
function uR(e, t) {
  const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
  return n && n.signal ? n : n ? n.value : null;
}
function Ate(e, t, n) {
  const i = t.config.style[n];
  return i && i[e];
}
function wm(e, t, n) {
  return `item.anchor === '${fte}' ? ${e} : item.anchor === '${hte}' ? ${t} : ${n}`;
}
const Xw = wm(W(El), W(_l), W(aR));
function $te(e) {
  const t = e("tickBand");
  let n = e("tickOffset"), i, r;
  return t ? t.signal ? (i = {
    signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
  }, r = {
    signal: `(${t.signal}) === 'extent'`
  }, K(n) || (n = {
    signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
  })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = 0.5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
    extra: r,
    band: i,
    offset: n
  };
}
function lR(e, t) {
  return t ? e ? K(e) ? Object.assign({}, e, {
    offset: lR(e.offset, t)
  }) : {
    value: e,
    offset: t
  } : t : e;
}
function qn(e, t) {
  return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = wl(e.encode, t, ed)) : e.interactive = !1, e;
}
function kte(e, t, n, i) {
  const r = Mn(e, n), o = r.isVertical(), a = r.gradientThickness(), s = r.gradientLength();
  let u, l, c, f, d;
  o ? (l = [0, 1], c = [0, 0], f = a, d = s) : (l = [0, 0], c = [1, 0], f = s, d = a);
  const h = {
    enter: u = {
      opacity: we,
      x: we,
      y: we,
      width: mt(f),
      height: mt(d)
    },
    update: ce({}, u, {
      opacity: Zn,
      fill: {
        gradient: t,
        start: l,
        stop: c
      }
    }),
    exit: {
      opacity: we
    }
  };
  return Ct(h, {
    stroke: r("gradientStrokeColor"),
    strokeWidth: r("gradientStrokeWidth")
  }, {
    opacity: r("gradientOpacity")
  }), qn({
    type: sR,
    role: eee,
    encode: h
  }, i);
}
function Cte(e, t, n, i, r) {
  const o = Mn(e, n), a = o.isVertical(), s = o.gradientThickness(), u = o.gradientLength();
  let l, c, f, d, h = "";
  a ? (l = "y", f = "y2", c = "x", d = "width", h = "1-") : (l = "x", f = "x2", c = "y", d = "height");
  const p = {
    opacity: we,
    fill: {
      scale: t,
      field: Qn
    }
  };
  p[l] = {
    signal: h + "datum." + Hu,
    mult: u
  }, p[c] = we, p[f] = {
    signal: h + "datum." + gte,
    mult: u
  }, p[d] = mt(s);
  const g = {
    enter: p,
    update: ce({}, p, {
      opacity: Zn
    }),
    exit: {
      opacity: we
    }
  };
  return Ct(g, {
    stroke: o("gradientStrokeColor"),
    strokeWidth: o("gradientStrokeWidth")
  }, {
    opacity: o("gradientOpacity")
  }), qn({
    type: sR,
    role: QZ,
    key: Qn,
    from: r,
    encode: g
  }, i);
}
const Fte = `datum.${Hu}<=0?"${El}":datum.${Hu}>=1?"${_l}":"${aR}"`, Mte = `datum.${Hu}<=0?"${ta}":datum.${Hu}>=1?"${zi}":"${dte}"`;
function dk(e, t, n, i) {
  const r = Mn(e, t), o = r.isVertical(), a = mt(r.gradientThickness()), s = r.gradientLength();
  let u = r("labelOverlap"), l, c, f, d, h = "";
  const p = {
    enter: l = {
      opacity: we
    },
    update: c = {
      opacity: Zn,
      text: {
        field: Ww
      }
    },
    exit: {
      opacity: we
    }
  };
  return Ct(p, {
    fill: r("labelColor"),
    fillOpacity: r("labelOpacity"),
    font: r("labelFont"),
    fontSize: r("labelFontSize"),
    fontStyle: r("labelFontStyle"),
    fontWeight: r("labelFontWeight"),
    limit: pi(e.labelLimit, t.gradientLabelLimit)
  }), o ? (l.align = {
    value: "left"
  }, l.baseline = c.baseline = {
    signal: Mte
  }, f = "y", d = "x", h = "1-") : (l.align = c.align = {
    signal: Fte
  }, l.baseline = {
    value: "top"
  }, f = "x", d = "y"), l[f] = c[f] = {
    signal: h + "datum." + Hu,
    mult: s
  }, l[d] = c[d] = a, a.offset = pi(e.labelOffset, t.gradientLabelOffset) || 0, u = u ? {
    separation: r("labelSeparation"),
    method: u,
    order: "datum." + kv
  } : void 0, qn({
    type: Rs,
    role: W5,
    style: Zf,
    key: Qn,
    from: i,
    encode: p,
    overlap: u
  }, n);
}
function Tte(e, t, n, i, r) {
  const o = Mn(e, t), a = n.entries, s = !!(a && a.interactive), u = a ? a.name : void 0, l = o("clipHeight"), c = o("symbolOffset"), f = {
    data: "value"
  }, d = `(${r}) ? datum.${pte} : datum.${Fv}`, h = l ? mt(l) : {
    field: Fv
  }, p = `datum.${kv}`, g = `max(1, ${r})`;
  let m, y, v, b, x;
  h.mult = 0.5, m = {
    enter: y = {
      opacity: we,
      x: {
        signal: d,
        mult: 0.5,
        offset: c
      },
      y: h
    },
    update: v = {
      opacity: Zn,
      x: y.x,
      y: y.y
    },
    exit: {
      opacity: we
    }
  };
  let E = null, _ = null;
  e.fill || (E = t.symbolBaseFillColor, _ = t.symbolBaseStrokeColor), Ct(m, {
    fill: o("symbolFillColor", E),
    shape: o("symbolType"),
    size: o("symbolSize"),
    stroke: o("symbolStrokeColor", _),
    strokeDash: o("symbolDash"),
    strokeDashOffset: o("symbolDashOffset"),
    strokeWidth: o("symbolStrokeWidth")
  }, {
    opacity: o("symbolOpacity")
  }), Hw.forEach(($) => {
    e[$] && (v[$] = y[$] = {
      scale: e[$],
      field: Qn
    });
  });
  const w = qn({
    type: Ste,
    role: tee,
    key: Qn,
    from: f,
    clip: l ? !0 : void 0,
    encode: m
  }, n.symbols), S = mt(c);
  S.offset = o("labelOffset"), m = {
    enter: y = {
      opacity: we,
      x: {
        signal: d,
        offset: S
      },
      y: h
    },
    update: v = {
      opacity: Zn,
      text: {
        field: Ww
      },
      x: y.x,
      y: y.y
    },
    exit: {
      opacity: we
    }
  }, Ct(m, {
    align: o("labelAlign"),
    baseline: o("labelBaseline"),
    fill: o("labelColor"),
    fillOpacity: o("labelOpacity"),
    font: o("labelFont"),
    fontSize: o("labelFontSize"),
    fontStyle: o("labelFontStyle"),
    fontWeight: o("labelFontWeight"),
    limit: o("labelLimit")
  });
  const C = qn({
    type: Rs,
    role: W5,
    style: Zf,
    key: Qn,
    from: f,
    encode: m
  }, n.labels);
  return m = {
    enter: {
      noBound: {
        value: !l
      },
      width: we,
      height: l ? mt(l) : we,
      opacity: we
    },
    exit: {
      opacity: we
    },
    update: v = {
      opacity: Zn,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }, o.isVertical(!0) ? (b = `ceil(item.mark.items.length / ${g})`, v.row.signal = `${p}%${b}`, v.column.signal = `floor(${p} / ${b})`, x = {
    field: ["row", p]
  }) : (v.row.signal = `floor(${p} / ${g})`, v.column.signal = `${p} % ${g}`, x = {
    field: p
  }), v.column.signal = `(${r})?${v.column.signal}:${p}`, i = {
    facet: {
      data: i,
      name: "value",
      groupby: kv
    }
  }, gf({
    role: jw,
    from: i,
    encode: wl(m, a, ed),
    marks: [w, C],
    name: u,
    interactive: s,
    sort: x
  });
}
function Ote(e, t) {
  const n = Mn(e, t);
  return {
    align: n("gridAlign"),
    columns: n.entryColumns(),
    center: {
      row: !0,
      column: !1
    },
    padding: {
      row: n("rowPadding"),
      column: n("columnPadding")
    }
  };
}
const Vw = 'item.orient === "left"', Kw = 'item.orient === "right"', Em = `(${Vw} || ${Kw})`, Nte = `datum.vgrad && ${Em}`, Dte = wm('"top"', '"bottom"', '"middle"'), Rte = wm('"right"', '"left"', '"center"'), Lte = `datum.vgrad && ${Kw} ? (${Rte}) : (${Em} && !(datum.vgrad && ${Vw})) ? "left" : ${Xw}`, Ite = `item._anchor || (${Em} ? "middle" : "start")`, Pte = `${Nte} ? (${Vw} ? -90 : 90) : 0`, zte = `${Em} ? (datum.vgrad ? (${Kw} ? "bottom" : "top") : ${Dte}) : "top"`;
function Bte(e, t, n, i) {
  const r = Mn(e, t), o = {
    enter: {
      opacity: we
    },
    update: {
      opacity: Zn,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: we
    }
  };
  return Ct(o, {
    orient: r("titleOrient"),
    _anchor: r("titleAnchor"),
    anchor: {
      signal: Ite
    },
    angle: {
      signal: Pte
    },
    align: {
      signal: Lte
    },
    baseline: {
      signal: zte
    },
    text: e.title,
    fill: r("titleColor"),
    fillOpacity: r("titleOpacity"),
    font: r("titleFont"),
    fontSize: r("titleFontSize"),
    fontStyle: r("titleFontStyle"),
    fontWeight: r("titleFontWeight"),
    limit: r("titleLimit"),
    lineHeight: r("titleLineHeight")
  }, {
    align: r("titleAlign"),
    baseline: r("titleBaseline")
  }), qn({
    type: Rs,
    role: nee,
    style: Gw,
    from: i,
    encode: o
  }, n);
}
function jte(e, t) {
  let n;
  return K(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + hk(e.path) + ")" : e.sphere && (n = "geoShape(" + hk(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
}
function hk(e) {
  return K(e) && e.signal ? e.signal : W(e);
}
function cR(e) {
  const t = e.role || "";
  return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === xm ? jw : t || zw;
}
function Ute(e) {
  return {
    marktype: e.type,
    name: e.name || void 0,
    role: e.role || cR(e),
    zindex: +e.zindex || void 0,
    aria: e.aria,
    description: e.description
  };
}
function qte(e, t) {
  return e && e.signal ? t.signalRef(e.signal) : e !== !1;
}
function Jw(e, t) {
  const n = QM(e.type);
  n || I("Unrecognized transform type: " + W(e.type));
  const i = ym(n.type.toLowerCase(), null, fR(n, e, t));
  return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i;
}
function fR(e, t, n) {
  const i = {}, r = e.params.length;
  for (let o = 0; o < r; ++o) {
    const a = e.params[o];
    i[a.name] = Wte(a, t, n);
  }
  return i;
}
function Wte(e, t, n) {
  const i = e.type, r = t[e.name];
  if (i === "index")
    return Gte(e, t, n);
  if (r === void 0) {
    e.required && I("Missing required " + W(t.type) + " parameter: " + W(e.name));
    return;
  } else {
    if (i === "param")
      return Hte(e, t, n);
    if (i === "projection")
      return n.projectionRef(t[e.name]);
  }
  return e.array && !ut(r) ? r.map((o) => pk(e, o, n)) : pk(e, r, n);
}
function pk(e, t, n) {
  const i = e.type;
  if (ut(t))
    return mk(i) ? I("Expression references can not be signals.") : w1(i) ? n.fieldRef(t) : yk(i) ? n.compareRef(t) : n.signalRef(t.signal);
  {
    const r = e.expr || w1(i);
    return r && Yte(t) ? n.exprRef(t.expr, t.as) : r && Xte(t) ? hf(t.field, t.as) : mk(i) ? vr(t, n) : Vte(i) ? ee(n.getData(t).values) : w1(i) ? hf(t) : yk(i) ? n.compareRef(t) : t;
  }
}
function Gte(e, t, n) {
  return Y(t.from) || I('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
}
function Hte(e, t, n) {
  const i = t[e.name];
  return e.array ? (P(i) || I("Expected an array of sub-parameters. Instead: " + W(i)), i.map((r) => gk(e, r, n))) : gk(e, i, n);
}
function gk(e, t, n) {
  const i = e.params.length;
  let r;
  for (let a = 0; a < i; ++a) {
    r = e.params[a];
    for (const s in r.key)
      if (r.key[s] !== t[s]) {
        r = null;
        break;
      }
    if (r)
      break;
  }
  r || I("Unsupported parameter: " + W(t));
  const o = ce(fR(r, t, n), r.key);
  return ee(n.add(qee(o)));
}
const Yte = (e) => e && e.expr, Xte = (e) => e && e.field, Vte = (e) => e === "data", mk = (e) => e === "expr", w1 = (e) => e === "field", yk = (e) => e === "compare";
function Kte(e, t, n) {
  let i, r, o, a, s;
  return e ? (i = e.facet) && (t || I("Only group marks can be faceted."), i.field != null ? a = s = Sh(i, n) : (e.data ? s = ee(n.getData(e.data).aggregate) : (o = Jw(ce({
    type: "aggregate",
    groupby: X(i.groupby)
  }, i.aggregate), n), o.params.key = n.keyRef(i.groupby), o.params.pulse = Sh(i, n), a = s = ee(n.add(o))), r = n.keyRef(i.groupby, !0))) : a = ee(n.add(Pi(null, [{}]))), a || (a = Sh(e, n)), {
    key: r,
    pulse: a,
    parent: s
  };
}
function Sh(e, t) {
  return e.$ref ? e : e.data && e.data.$ref ? e.data : ee(t.getData(e.data).output);
}
function gs(e, t, n, i, r) {
  this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {};
}
gs.fromEntries = function(e, t) {
  const n = t.length, i = t[n - 1], r = t[n - 2];
  let o = t[0], a = null, s = 1;
  for (o && o.type === "load" && (o = t[1]), e.add(t[0]); s < n; ++s)
    t[s].params.pulse = ee(t[s - 1]), e.add(t[s]), t[s].type === "aggregate" && (a = t[s]);
  return new gs(e, o, r, i, a);
};
function dR(e) {
  return Y(e) ? e : null;
}
function vk(e, t, n) {
  const i = vm(n.op, n.field);
  let r;
  if (t.ops) {
    for (let o = 0, a = t.as.length; o < a; ++o)
      if (t.as[o] === i)
        return;
  } else
    t.ops = ["count"], t.fields = [null], t.as = ["count"];
  n.op && (t.ops.push((r = n.op.signal) ? e.signalRef(r) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(i));
}
function Ql(e, t, n, i, r, o, a) {
  const s = t[n] || (t[n] = {}), u = bee(o);
  let l = dR(r), c, f;
  if (l != null && (e = t.scope, l = l + (u ? "|" + u : ""), c = s[l]), !c) {
    const d = o ? {
      field: Sv,
      pulse: t.countsRef(e, r, o)
    } : {
      field: e.fieldRef(r),
      pulse: ee(t.output)
    };
    u && (d.sort = e.sortRef(o)), f = e.add(ym(i, void 0, d)), a && (t.index[r] = f), c = ee(f), l != null && (s[l] = c);
  }
  return c;
}
gs.prototype = {
  countsRef(e, t, n) {
    const i = this, r = i.counts || (i.counts = {}), o = dR(t);
    let a, s, u;
    return o != null && (e = i.scope, a = r[o]), a ? n && n.field && vk(e, a.agg.params, n) : (u = {
      groupby: e.fieldRef(t, "key"),
      pulse: ee(i.output)
    }, n && n.field && vk(e, u, n), s = e.add(K5(u)), a = e.add(Pi({
      pulse: ee(s)
    })), a = {
      agg: s,
      ref: ee(a)
    }, o != null && (r[o] = a)), a.ref;
  },
  tuplesRef() {
    return ee(this.values);
  },
  extentRef(e, t) {
    return Ql(e, this, "extent", "extent", t, !1);
  },
  domainRef(e, t) {
    return Ql(e, this, "domain", "values", t, !1);
  },
  valuesRef(e, t, n) {
    return Ql(e, this, "vals", "values", t, n || !0);
  },
  lookupRef(e, t) {
    return Ql(e, this, "lookup", "tupleindex", t, !1);
  },
  indataRef(e, t) {
    return Ql(e, this, "indata", "tupleindex", t, !0, !0);
  }
};
function Jte(e, t, n) {
  const i = e.from.facet, r = i.name, o = Sh(i, t);
  let a;
  i.name || I("Facet must have a name: " + W(i)), i.data || I("Facet must reference a data set: " + W(i)), i.field ? a = t.add(Z5({
    field: t.fieldRef(i.field),
    pulse: o
  })) : i.groupby ? a = t.add(Dee({
    key: t.keyRef(i.groupby),
    group: ee(t.proxy(n.parent)),
    pulse: o
  })) : I("Facet must specify groupby or field: " + W(i));
  const s = t.fork(), u = s.add(Pi()), l = s.add(Ds({
    pulse: ee(u)
  }));
  s.addData(r, new gs(s, u, u, l)), s.addSignal("parent", null), a.params.subflow = {
    $subflow: s.parse(e).toRuntime()
  };
}
function Qte(e, t, n) {
  const i = t.add(Z5({
    pulse: n.pulse
  })), r = t.fork();
  r.add(Ds()), r.addSignal("parent", null), i.params.subflow = {
    $subflow: r.parse(e).toRuntime()
  };
}
function hR(e, t, n) {
  const i = e.remove, r = e.insert, o = e.toggle, a = e.modify, s = e.values, u = t.add(qp()), l = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, o, a, s].map((f) => f == null ? "null" : f).join(",") + "),0)", c = vr(l, t);
  u.update = c.$expr, u.params = c.$params;
}
function _m(e, t) {
  const n = cR(e), i = e.type === xm, r = e.from && e.from.facet, o = e.overlap;
  let a = e.layout || n === jw || n === Bw, s, u, l, c, f, d, h;
  const p = n === zw || a || r, g = Kte(e.from, i, t);
  u = t.add(Oee({
    key: g.key || (e.key ? hf(e.key) : void 0),
    pulse: g.pulse,
    clean: !i
  }));
  const m = ee(u);
  u = l = t.add(Pi({
    pulse: m
  })), u = t.add(zee({
    markdef: Ute(e),
    interactive: qte(e.interactive, t),
    clip: jte(e.clip, t),
    context: {
      $context: !0
    },
    groups: t.lookup(),
    parent: t.signals.parent ? t.signalRef("parent") : null,
    index: t.markpath(),
    pulse: ee(u)
  }));
  const y = ee(u);
  u = c = t.add(Q5(X5(e.encode, e.type, n, e.style, t, {
    mod: !1,
    pulse: y
  }))), u.params.parent = t.encode(), e.transform && e.transform.forEach((_) => {
    const w = Jw(_, t), S = w.metadata;
    (S.generates || S.changes) && I("Mark transforms should not generate new data."), S.nomod || (c.params.mod = !0), w.params.pulse = ee(u), t.add(u = w);
  }), e.sort && (u = t.add(Xee({
    sort: t.compareRef(e.sort),
    pulse: ee(u)
  })));
  const v = ee(u);
  (r || a) && (a = t.add(tR({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    mark: y,
    pulse: v
  })), d = ee(a));
  const b = t.add(J5({
    mark: y,
    pulse: d || v
  }));
  h = ee(b), i && (p && (s = t.operators, s.pop(), a && s.pop()), t.pushState(v, d || h, m), r ? Jte(e, t, g) : p ? Qte(e, t, g) : t.parse(e), t.popState(), p && (a && s.push(a), s.push(b))), o && (h = Zte(o, h, t));
  const x = t.add(eR({
    pulse: h
  })), E = t.add(Ds({
    pulse: ee(x)
  }, void 0, t.parent()));
  e.name != null && (f = e.name, t.addData(f, new gs(t, l, x, E)), e.on && e.on.forEach((_) => {
    (_.insert || _.remove || _.toggle) && I("Marks only support modify triggers."), hR(_, t, f);
  }));
}
function Zte(e, t, n) {
  const i = e.method, r = e.bound, o = e.separation, a = {
    separation: ut(o) ? n.signalRef(o.signal) : o,
    method: ut(i) ? n.signalRef(i.signal) : i,
    pulse: t
  };
  if (e.order && (a.sort = n.compareRef({
    field: e.order
  })), r) {
    const s = r.tolerance;
    a.boundTolerance = ut(s) ? n.signalRef(s.signal) : +s, a.boundScale = n.scaleRef(r.scale), a.boundOrient = r.orient;
  }
  return ee(n.add(Uee(a)));
}
function ene(e, t) {
  const n = t.config.legend, i = e.encode || {}, r = Mn(e, n), o = i.legend || {}, a = o.name || void 0, s = o.interactive, u = o.style, l = {};
  let c = 0, f, d, h;
  Hw.forEach((b) => e[b] ? (l[b] = e[b], c = c || e[b]) : 0), c || I("Missing valid scale for legend.");
  const p = tne(e, t.scaleType(c)), g = {
    title: e.title != null,
    scales: l,
    type: p,
    vgrad: p !== "symbol" && r.isVertical()
  }, m = ee(t.add(Pi(null, [g]))), y = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }, v = ee(t.add(Iee(d = {
    type: p,
    scale: t.scaleRef(c),
    count: t.objectProperty(r("tickCount")),
    limit: t.property(r("symbolLimit")),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  })));
  return p === _h ? (h = [kte(e, c, n, i.gradient), dk(e, n, i.labels, v)], d.count = d.count || t.signalRef(`max(2,2*floor((${es(r.gradientLength())})/100))`)) : p === Cv ? h = [Cte(e, c, n, i.gradient, v), dk(e, n, i.labels, v)] : (f = Ote(e, n), h = [Tte(e, n, i, v, es(f.columns))], d.size = rne(e, t, h[0].marks)), h = [gf({
    role: ZZ,
    from: m,
    encode: y,
    marks: h,
    layout: f,
    interactive: s
  })], g.title && h.push(Bte(e, n, i.title, m)), _m(gf({
    role: JZ,
    from: m,
    encode: wl(ine(r, e, n), o, ed),
    marks: h,
    aria: r("aria"),
    description: r("description"),
    zindex: r("zindex"),
    name: a,
    interactive: s,
    style: u
  }), t);
}
function tne(e, t) {
  let n = e.type || fk;
  return !e.type && nne(e) === 1 && (e.fill || e.stroke) && (n = Yx(t) ? _h : xy(t) ? Cv : fk), n !== _h ? n : xy(t) ? Cv : _h;
}
function nne(e) {
  return Hw.reduce((t, n) => t + (e[n] ? 1 : 0), 0);
}
function ine(e, t, n) {
  const i = {
    enter: {},
    update: {}
  };
  return Ct(i, {
    orient: e("orient"),
    offset: e("offset"),
    padding: e("padding"),
    titlePadding: e("titlePadding"),
    cornerRadius: e("cornerRadius"),
    fill: e("fillColor"),
    stroke: e("strokeColor"),
    strokeWidth: n.strokeWidth,
    strokeDash: n.strokeDash,
    x: e("legendX"),
    y: e("legendY"),
    format: t.format,
    formatType: t.formatType
  }), i;
}
function rne(e, t, n) {
  const i = es(bk("size", e, n)), r = es(bk("strokeWidth", e, n)), o = es(one(n[1].encode, t, Zf));
  return vr(`max(ceil(sqrt(${i})+${r}),${o})`, t);
}
function bk(e, t, n) {
  return t[e] ? `scale("${t[e]}",datum)` : uR(e, n[0].encode);
}
function one(e, t, n) {
  return uR("fontSize", e) || Ate("fontSize", t, n);
}
const ane = `item.orient==="${El}"?-90:item.orient==="${_l}"?90:0`;
function sne(e, t) {
  e = Y(e) ? {
    text: e
  } : e;
  const n = Mn(e, t.config.title), i = e.encode || {}, r = i.group || {}, o = r.name || void 0, a = r.interactive, s = r.style, u = [], l = {}, c = ee(t.add(Pi(null, [l])));
  return u.push(cne(e, n, une(e), c)), e.subtitle && u.push(fne(e, n, i.subtitle, c)), _m(gf({
    role: iee,
    from: c,
    encode: lne(n, r),
    marks: u,
    aria: n("aria"),
    description: n("description"),
    zindex: n("zindex"),
    name: o,
    interactive: a,
    style: s
  }), t);
}
function une(e) {
  const t = e.encode;
  return t && t.title || ce({
    name: e.name,
    interactive: e.interactive,
    style: e.style
  }, t);
}
function lne(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return Ct(n, {
    orient: e("orient"),
    anchor: e("anchor"),
    align: {
      signal: Xw
    },
    angle: {
      signal: ane
    },
    limit: e("limit"),
    frame: e("frame"),
    offset: e("offset") || 0,
    padding: e("subtitlePadding")
  }), wl(n, t, ed);
}
function cne(e, t, n, i) {
  const r = {
    value: 0
  }, o = e.text, a = {
    enter: {
      opacity: r
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: r
    }
  };
  return Ct(a, {
    text: o,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("color"),
    font: t("font"),
    fontSize: t("fontSize"),
    fontStyle: t("fontStyle"),
    fontWeight: t("fontWeight"),
    lineHeight: t("lineHeight")
  }, {
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), qn({
    type: Rs,
    role: ree,
    style: mte,
    from: i,
    encode: a
  }, n);
}
function fne(e, t, n, i) {
  const r = {
    value: 0
  }, o = e.subtitle, a = {
    enter: {
      opacity: r
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: r
    }
  };
  return Ct(a, {
    text: o,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("subtitleColor"),
    font: t("subtitleFont"),
    fontSize: t("subtitleFontSize"),
    fontStyle: t("subtitleFontStyle"),
    fontWeight: t("subtitleFontWeight"),
    lineHeight: t("subtitleLineHeight")
  }, {
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), qn({
    type: Rs,
    role: oee,
    style: yte,
    from: i,
    encode: a
  }, n);
}
function dne(e, t) {
  const n = [];
  e.transform && e.transform.forEach((i) => {
    n.push(Jw(i, t));
  }), e.on && e.on.forEach((i) => {
    hR(i, t, e.name);
  }), t.addDataPipeline(e.name, hne(e, t, n));
}
function hne(e, t, n) {
  const i = [];
  let r = null, o = !1, a = !1, s, u, l, c, f;
  for (e.values ? ut(e.values) || wh(e.format) ? (i.push(xk(t, e)), i.push(r = Aa())) : i.push(r = Aa({
    $ingest: e.values,
    $format: e.format
  })) : e.url ? wh(e.url) || wh(e.format) ? (i.push(xk(t, e)), i.push(r = Aa())) : i.push(r = Aa({
    $request: e.url,
    $format: e.format
  })) : e.source && (r = s = X(e.source).map((d) => ee(t.getData(d).output)), i.push(null)), u = 0, l = n.length; u < l; ++u)
    c = n[u], f = c.metadata, !r && !f.source && i.push(r = Aa()), i.push(c), f.generates && (a = !0), f.modifies && !a && (o = !0), f.source ? r = c : f.changes && (r = null);
  return s && (l = s.length - 1, i[0] = Hee({
    derive: o,
    pulse: l ? s : s[0]
  }), (o || l) && i.splice(1, 0, Aa())), r || i.push(Aa()), i.push(Ds({})), i;
}
function Aa(e) {
  const t = Pi({}, e);
  return t.metadata = {
    source: !0
  }, t;
}
function xk(e, t) {
  return Pee({
    url: t.url ? e.property(t.url) : void 0,
    async: t.async ? e.property(t.async) : void 0,
    values: t.values ? e.property(t.values) : void 0,
    format: e.objectProperty(t.format)
  });
}
const pR = (e) => e === ta || e === zi, Sm = (e, t, n) => ut(e) ? yne(e.signal, t, n) : e === El || e === zi ? t : n, yt = (e, t, n) => ut(e) ? gne(e.signal, t, n) : pR(e) ? t : n, Fi = (e, t, n) => ut(e) ? mne(e.signal, t, n) : pR(e) ? n : t, gR = (e, t, n) => ut(e) ? vne(e.signal, t, n) : e === zi ? {
  value: t
} : {
  value: n
}, pne = (e, t, n) => ut(e) ? bne(e.signal, t, n) : e === _l ? {
  value: t
} : {
  value: n
}, gne = (e, t, n) => mR(`${e} === '${zi}' || ${e} === '${ta}'`, t, n), mne = (e, t, n) => mR(`${e} !== '${zi}' && ${e} !== '${ta}'`, t, n), yne = (e, t, n) => Qw(`${e} === '${El}' || ${e} === '${zi}'`, t, n), vne = (e, t, n) => Qw(`${e} === '${zi}'`, t, n), bne = (e, t, n) => Qw(`${e} === '${_l}'`, t, n), mR = (e, t, n) => (t = t != null ? mt(t) : t, n = n != null ? mt(n) : n, wk(t) && wk(n) ? (t = t ? t.signal || W(t.value) : null, n = n ? n.signal || W(n.value) : null, {
  signal: `${e} ? (${t}) : (${n})`
}) : [ce({
  test: e
}, t)].concat(n || [])), wk = (e) => e == null || Object.keys(e).length === 1, Qw = (e, t, n) => ({
  signal: `${e} ? (${pu(t)}) : (${pu(n)})`
}), xne = (e, t, n, i, r) => ({
  signal: (i != null ? `${e} === '${El}' ? (${pu(i)}) : ` : "") + (n != null ? `${e} === '${ta}' ? (${pu(n)}) : ` : "") + (r != null ? `${e} === '${_l}' ? (${pu(r)}) : ` : "") + (t != null ? `${e} === '${zi}' ? (${pu(t)}) : ` : "") + "(null)"
}), pu = (e) => ut(e) ? e.signal : e == null ? null : W(e), wne = (e, t) => t === 0 ? 0 : ut(e) ? {
  signal: `(${e.signal}) * ${t}`
} : {
  value: e * t
}, bu = (e, t) => {
  const n = e.signal;
  return n && n.endsWith("(null)") ? {
    signal: n.slice(0, -6) + t.signal
  } : e;
};
function eu(e, t, n, i) {
  let r;
  if (t && ie(t, e))
    return t[e];
  if (ie(n, e))
    return n[e];
  if (e.startsWith("title")) {
    switch (e) {
      case "titleColor":
        r = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        r = e[5].toLowerCase() + e.slice(6);
    }
    return i[Gw][r];
  } else if (e.startsWith("label")) {
    switch (e) {
      case "labelColor":
        r = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        r = e[5].toLowerCase() + e.slice(6);
    }
    return i[Zf][r];
  }
  return null;
}
function Ek(e) {
  const t = {};
  for (const n of e)
    if (!!n)
      for (const i in n)
        t[i] = 1;
  return Object.keys(t);
}
function Ene(e, t) {
  var n = t.config, i = n.style, r = n.axis, o = t.scaleType(e.scale) === "band" && n.axisBand, a = e.orient, s, u, l;
  if (ut(a)) {
    const f = Ek([n.axisX, n.axisY]), d = Ek([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
    s = {};
    for (l of f)
      s[l] = yt(a, eu(l, n.axisX, r, i), eu(l, n.axisY, r, i));
    u = {};
    for (l of d)
      u[l] = xne(a.signal, eu(l, n.axisTop, r, i), eu(l, n.axisBottom, r, i), eu(l, n.axisLeft, r, i), eu(l, n.axisRight, r, i));
  } else
    s = a === zi || a === ta ? n.axisX : n.axisY, u = n["axis" + a[0].toUpperCase() + a.slice(1)];
  return s || u || o ? ce({}, r, s, u, o) : r;
}
function _ne(e, t, n, i) {
  const r = Mn(e, t), o = e.orient;
  let a, s;
  const u = {
    enter: a = {
      opacity: we
    },
    update: s = {
      opacity: Zn
    },
    exit: {
      opacity: we
    }
  };
  Ct(u, {
    stroke: r("domainColor"),
    strokeCap: r("domainCap"),
    strokeDash: r("domainDash"),
    strokeDashOffset: r("domainDashOffset"),
    strokeWidth: r("domainWidth"),
    strokeOpacity: r("domainOpacity")
  });
  const l = _k(e, 0), c = _k(e, 1);
  return a.x = s.x = yt(o, l, we), a.x2 = s.x2 = yt(o, c), a.y = s.y = Fi(o, l, we), a.y2 = s.y2 = Fi(o, c), qn({
    type: Yw,
    role: HZ,
    from: i,
    encode: u
  }, n);
}
function _k(e, t) {
  return {
    scale: e.scale,
    range: t
  };
}
function Sne(e, t, n, i, r) {
  const o = Mn(e, t), a = e.orient, s = e.gridScale, u = Sm(a, 1, -1), l = Ane(e.offset, u);
  let c, f, d;
  const h = {
    enter: c = {
      opacity: we
    },
    update: d = {
      opacity: Zn
    },
    exit: f = {
      opacity: we
    }
  };
  Ct(h, {
    stroke: o("gridColor"),
    strokeCap: o("gridCap"),
    strokeDash: o("gridDash"),
    strokeDashOffset: o("gridDashOffset"),
    strokeOpacity: o("gridOpacity"),
    strokeWidth: o("gridWidth")
  });
  const p = {
    scale: e.scale,
    field: Qn,
    band: r.band,
    extra: r.extra,
    offset: r.offset,
    round: o("tickRound")
  }, g = yt(a, {
    signal: "height"
  }, {
    signal: "width"
  }), m = s ? {
    scale: s,
    range: 0,
    mult: u,
    offset: l
  } : {
    value: 0,
    offset: l
  }, y = s ? {
    scale: s,
    range: 1,
    mult: u,
    offset: l
  } : ce(g, {
    mult: u,
    offset: l
  });
  return c.x = d.x = yt(a, p, m), c.y = d.y = Fi(a, p, m), c.x2 = d.x2 = Fi(a, y), c.y2 = d.y2 = yt(a, y), f.x = yt(a, p), f.y = Fi(a, p), qn({
    type: Yw,
    role: YZ,
    key: Qn,
    from: i,
    encode: h
  }, n);
}
function Ane(e, t) {
  if (t !== 1)
    if (!K(e))
      e = ut(t) ? {
        signal: `(${t.signal}) * (${e || 0})`
      } : t * (e || 0);
    else {
      let n = e = ce({}, e);
      for (; n.mult != null; )
        if (K(n.mult))
          n = n.mult = ce({}, n.mult);
        else
          return n.mult = ut(t) ? {
            signal: `(${n.mult}) * (${t.signal})`
          } : n.mult * t, e;
      n.mult = t;
    }
  return e;
}
function $ne(e, t, n, i, r, o) {
  const a = Mn(e, t), s = e.orient, u = Sm(s, -1, 1);
  let l, c, f;
  const d = {
    enter: l = {
      opacity: we
    },
    update: f = {
      opacity: Zn
    },
    exit: c = {
      opacity: we
    }
  };
  Ct(d, {
    stroke: a("tickColor"),
    strokeCap: a("tickCap"),
    strokeDash: a("tickDash"),
    strokeDashOffset: a("tickDashOffset"),
    strokeOpacity: a("tickOpacity"),
    strokeWidth: a("tickWidth")
  });
  const h = mt(r);
  h.mult = u;
  const p = {
    scale: e.scale,
    field: Qn,
    band: o.band,
    extra: o.extra,
    offset: o.offset,
    round: a("tickRound")
  };
  return f.y = l.y = yt(s, we, p), f.y2 = l.y2 = yt(s, h), c.x = yt(s, p), f.x = l.x = Fi(s, we, p), f.x2 = l.x2 = Fi(s, h), c.y = Fi(s, p), qn({
    type: Yw,
    role: VZ,
    key: Qn,
    from: i,
    encode: d
  }, n);
}
function E1(e, t, n, i, r) {
  return {
    signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + i + "," + r + ")"
  };
}
function kne(e, t, n, i, r, o) {
  const a = Mn(e, t), s = e.orient, u = e.scale, l = Sm(s, -1, 1), c = es(a("labelFlush")), f = es(a("labelFlushOffset")), d = a("labelAlign"), h = a("labelBaseline");
  let p = c === 0 || !!c, g;
  const m = mt(r);
  m.mult = l, m.offset = mt(a("labelPadding") || 0), m.offset.mult = l;
  const y = {
    scale: u,
    field: Qn,
    band: 0.5,
    offset: lR(o.offset, a("labelOffset"))
  }, v = yt(s, p ? E1(u, c, '"left"', '"right"', '"center"') : {
    value: "center"
  }, pne(s, "left", "right")), b = yt(s, gR(s, "bottom", "top"), p ? E1(u, c, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  }), x = E1(u, c, `-(${f})`, f, 0);
  p = p && f;
  const E = {
    opacity: we,
    x: yt(s, y, m),
    y: Fi(s, y, m)
  }, _ = {
    enter: E,
    update: g = {
      opacity: Zn,
      text: {
        field: Ww
      },
      x: E.x,
      y: E.y,
      align: v,
      baseline: b
    },
    exit: {
      opacity: we,
      x: E.x,
      y: E.y
    }
  };
  Ct(_, {
    dx: !d && p ? yt(s, x) : null,
    dy: !h && p ? Fi(s, x) : null
  }), Ct(_, {
    angle: a("labelAngle"),
    fill: a("labelColor"),
    fillOpacity: a("labelOpacity"),
    font: a("labelFont"),
    fontSize: a("labelFontSize"),
    fontWeight: a("labelFontWeight"),
    fontStyle: a("labelFontStyle"),
    limit: a("labelLimit"),
    lineHeight: a("labelLineHeight")
  }, {
    align: d,
    baseline: h
  });
  const w = a("labelBound");
  let S = a("labelOverlap");
  return S = S || w ? {
    separation: a("labelSeparation"),
    method: S,
    order: "datum.index",
    bound: w ? {
      scale: u,
      orient: s,
      tolerance: w
    } : null
  } : void 0, g.align !== v && (g.align = bu(g.align, v)), g.baseline !== b && (g.baseline = bu(g.baseline, b)), qn({
    type: Rs,
    role: XZ,
    style: Zf,
    key: Qn,
    from: i,
    encode: _,
    overlap: S
  }, n);
}
function Cne(e, t, n, i) {
  const r = Mn(e, t), o = e.orient, a = Sm(o, -1, 1);
  let s, u;
  const l = {
    enter: s = {
      opacity: we,
      anchor: mt(r("titleAnchor", null)),
      align: {
        signal: Xw
      }
    },
    update: u = ce({}, s, {
      opacity: Zn,
      text: mt(e.title)
    }),
    exit: {
      opacity: we
    }
  }, c = {
    signal: `lerp(range("${e.scale}"), ${wm(0, 1, 0.5)})`
  };
  return u.x = yt(o, c), u.y = Fi(o, c), s.angle = yt(o, we, wne(a, 90)), s.baseline = yt(o, gR(o, ta, zi), {
    value: ta
  }), u.angle = s.angle, u.baseline = s.baseline, Ct(l, {
    fill: r("titleColor"),
    fillOpacity: r("titleOpacity"),
    font: r("titleFont"),
    fontSize: r("titleFontSize"),
    fontStyle: r("titleFontStyle"),
    fontWeight: r("titleFontWeight"),
    limit: r("titleLimit"),
    lineHeight: r("titleLineHeight")
  }, {
    align: r("titleAlign"),
    angle: r("titleAngle"),
    baseline: r("titleBaseline")
  }), Fne(r, o, l, n), l.update.align = bu(l.update.align, s.align), l.update.angle = bu(l.update.angle, s.angle), l.update.baseline = bu(l.update.baseline, s.baseline), qn({
    type: Rs,
    role: KZ,
    style: Gw,
    from: i,
    encode: l
  }, n);
}
function Fne(e, t, n, i) {
  const r = (s, u) => s != null ? (n.update[u] = bu(mt(s), n.update[u]), !1) : !su(u, i), o = r(e("titleX"), "x"), a = r(e("titleY"), "y");
  n.enter.auto = a === o ? mt(a) : yt(t, mt(a), mt(o));
}
function Mne(e, t) {
  const n = Ene(e, t), i = e.encode || {}, r = i.axis || {}, o = r.name || void 0, a = r.interactive, s = r.style, u = Mn(e, n), l = $te(u), c = {
    scale: e.scale,
    ticks: !!u("ticks"),
    labels: !!u("labels"),
    grid: !!u("grid"),
    domain: !!u("domain"),
    title: e.title != null
  }, f = ee(t.add(Pi({}, [c]))), d = ee(t.add(Tee({
    scale: t.scaleRef(e.scale),
    extra: t.property(l.extra),
    count: t.objectProperty(e.tickCount),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  }))), h = [];
  let p;
  return c.grid && h.push(Sne(e, n, i.grid, d, l)), c.ticks && (p = u("tickSize"), h.push($ne(e, n, i.ticks, d, p, l))), c.labels && (p = c.ticks ? p : 0, h.push(kne(e, n, i.labels, d, p, l))), c.domain && h.push(_ne(e, n, i.domain, f)), c.title && h.push(Cne(e, n, i.title, f)), _m(gf({
    role: GZ,
    from: f,
    encode: wl(Tne(u, e), r, ed),
    marks: h,
    aria: u("aria"),
    description: u("description"),
    zindex: u("zindex"),
    name: o,
    interactive: a,
    style: s
  }), t);
}
function Tne(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return Ct(n, {
    orient: e("orient"),
    offset: e("offset") || 0,
    position: pi(t.position, 0),
    titlePadding: e("titlePadding"),
    minExtent: e("minExtent"),
    maxExtent: e("maxExtent"),
    range: {
      signal: `abs(span(range("${t.scale}")))`
    },
    translate: e("translate"),
    format: t.format,
    formatType: t.formatType
  }), n;
}
function yR(e, t, n) {
  const i = X(e.signals), r = X(e.scales);
  return n || i.forEach((o) => V5(o, t)), X(e.projections).forEach((o) => lte(o, t)), r.forEach((o) => Jee(o, t)), X(e.data).forEach((o) => dne(o, t)), r.forEach((o) => Qee(o, t)), (n || i).forEach((o) => Mee(o, t)), X(e.axes).forEach((o) => Mne(o, t)), X(e.marks).forEach((o) => _m(o, t)), X(e.legends).forEach((o) => ene(o, t)), e.title && sne(e.title, t), t.parseLambdas(), t;
}
const One = (e) => wl({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, e);
function Nne(e, t) {
  const n = t.config, i = ee(t.root = t.add(qp())), r = Dne(e, n);
  r.forEach((l) => V5(l, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
  const o = t.add(Pi()), a = t.add(Q5(X5(One(e.encode), xm, Bw, e.style, t, {
    pulse: ee(o)
  }))), s = t.add(tR({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    autosize: t.signalRef("autosize"),
    mark: i,
    pulse: ee(a)
  }));
  t.operators.pop(), t.pushState(ee(a), ee(s), null), yR(e, t, r), t.operators.push(s);
  let u = t.add(J5({
    mark: i,
    pulse: ee(s)
  }));
  return u = t.add(eR({
    pulse: ee(u)
  })), u = t.add(Ds({
    pulse: ee(u)
  })), t.addData("root", new gs(t, o, o, u)), t;
}
function Zl(e, t) {
  return t && t.signal ? {
    name: e,
    update: t.signal
  } : {
    name: e,
    value: t
  };
}
function Dne(e, t) {
  const n = (a) => pi(e[a], t[a]), i = [Zl("background", n("background")), Zl("autosize", UZ(n("autosize"))), Zl("padding", WZ(n("padding"))), Zl("width", n("width") || 0), Zl("height", n("height") || 0)], r = i.reduce((a, s) => (a[s.name] = s, a), {}), o = {};
  return X(e.signals).forEach((a) => {
    ie(r, a.name) ? a = ce(r[a.name], a) : i.push(a), o[a.name] = a;
  }), X(t.signals).forEach((a) => {
    !ie(o, a.name) && !ie(r, a.name) && i.push(a);
  }), i;
}
function vR(e, t) {
  this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
}
function Sk(e) {
  this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath;
}
vR.prototype = Sk.prototype = {
  parse(e) {
    return yR(e, this);
  },
  fork() {
    return new Sk(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    return this.finish(), {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(e) {
    return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach((t) => {
      t.$ref = e.id;
    }), e.refs = null), e;
  },
  proxy(e) {
    const t = e instanceof _v ? ee(e) : e;
    return this.add(Gee({
      value: t
    }));
  },
  addStream(e) {
    return this.streams.push(e), e.id = this.id(), e;
  },
  addUpdate(e) {
    return this.updates.push(e), e;
  },
  finish() {
    let e, t;
    this.root && (this.root.root = !0);
    for (e in this.signals)
      this.signals[e].signal = e;
    for (e in this.scales)
      this.scales[e].scale = e;
    function n(i, r, o) {
      let a, s;
      i && (a = i.data || (i.data = {}), s = a[r] || (a[r] = []), s.push(o));
    }
    for (e in this.data) {
      t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
      for (const i in t.index)
        n(t.index[i], e, "index:" + i);
    }
    return this;
  },
  pushState(e, t, n) {
    this._encode.push(ee(this.add(Ds({
      pulse: e
    })))), this._parent.push(t), this._lookup.push(n ? ee(this.proxy(n)) : null), this._markpath.push(-1);
  },
  popState() {
    this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
  },
  parent() {
    return xe(this._parent);
  },
  encode() {
    return xe(this._encode);
  },
  lookup() {
    return xe(this._lookup);
  },
  markpath() {
    const e = this._markpath;
    return ++e[e.length - 1];
  },
  fieldRef(e, t) {
    if (Y(e))
      return hf(e, t);
    e.signal || I("Unsupported field reference: " + W(e));
    const n = e.signal;
    let i = this.field[n];
    if (!i) {
      const r = {
        name: this.signalRef(n)
      };
      t && (r.as = t), this.field[n] = i = ee(this.add(Ree(r)));
    }
    return i;
  },
  compareRef(e) {
    let t = !1;
    const n = (o) => ut(o) ? (t = !0, this.signalRef(o.signal)) : xee(o) ? (t = !0, this.exprRef(o.expr)) : o, i = X(e.field).map(n), r = X(e.order).map(n);
    return t ? ee(this.add(ck({
      fields: i,
      orders: r
    }))) : uk(i, r);
  },
  keyRef(e, t) {
    let n = !1;
    const i = (o) => ut(o) ? (n = !0, ee(r[o.signal])) : o, r = this.signals;
    return e = X(e).map(i), n ? ee(this.add(Lee({
      fields: e,
      flat: t
    }))) : mee(e, t);
  },
  sortRef(e) {
    if (!e)
      return e;
    const t = vm(e.op, e.field), n = e.order || yee;
    return n.signal ? ee(this.add(ck({
      fields: t,
      orders: this.signalRef(n.signal)
    }))) : uk(t, n);
  },
  event(e, t) {
    const n = e + ":" + t;
    if (!this.events[n]) {
      const i = this.id();
      this.streams.push({
        id: i,
        source: e,
        type: t
      }), this.events[n] = i;
    }
    return this.events[n];
  },
  hasOwnSignal(e) {
    return ie(this.signals, e);
  },
  addSignal(e, t) {
    this.hasOwnSignal(e) && I("Duplicate signal name: " + W(e));
    const n = t instanceof _v ? t : this.add(qp(t));
    return this.signals[e] = n;
  },
  getSignal(e) {
    return this.signals[e] || I("Unrecognized signal name: " + W(e)), this.signals[e];
  },
  signalRef(e) {
    return this.signals[e] ? ee(this.signals[e]) : (ie(this.lambdas, e) || (this.lambdas[e] = this.add(qp(null))), ee(this.lambdas[e]));
  },
  parseLambdas() {
    const e = Object.keys(this.lambdas);
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t], r = vr(i, this), o = this.lambdas[i];
      o.params = r.$params, o.update = r.$expr;
    }
  },
  property(e) {
    return e && e.signal ? this.signalRef(e.signal) : e;
  },
  objectProperty(e) {
    return !e || !K(e) ? e : this.signalRef(e.signal || Zw(e));
  },
  exprRef(e, t) {
    const n = {
      expr: vr(e, this)
    };
    return t && (n.expr.$name = t), ee(this.add(Nee(n)));
  },
  addBinding(e, t) {
    this.bindings || I("Nested signals do not support binding: " + W(e)), this.bindings.push(ce({
      signal: e
    }, t));
  },
  addScaleProj(e, t) {
    ie(this.scales, e) && I("Duplicate scale or projection name: " + W(e)), this.scales[e] = this.add(t);
  },
  addScale(e, t) {
    this.addScaleProj(e, Yee(t));
  },
  addProjection(e, t) {
    this.addScaleProj(e, Wee(t));
  },
  getScale(e) {
    return this.scales[e] || I("Unrecognized scale name: " + W(e)), this.scales[e];
  },
  scaleRef(e) {
    return ee(this.getScale(e));
  },
  scaleType(e) {
    return this.getScale(e).params.type;
  },
  projectionRef(e) {
    return this.scaleRef(e);
  },
  projectionType(e) {
    return this.scaleType(e);
  },
  addData(e, t) {
    return ie(this.data, e) && I("Duplicate data set name: " + W(e)), this.data[e] = t;
  },
  getData(e) {
    return this.data[e] || I("Undefined data set name: " + W(e)), this.data[e];
  },
  addDataPipeline(e, t) {
    return ie(this.data, e) && I("Duplicate data set name: " + W(e)), this.addData(e, gs.fromEntries(this, t));
  }
};
function Zw(e) {
  return (P(e) ? Rne : Lne)(e);
}
function Rne(e) {
  const t = e.length;
  let n = "[";
  for (let i = 0; i < t; ++i) {
    const r = e[i];
    n += (i > 0 ? "," : "") + (K(r) ? r.signal || Zw(r) : W(r));
  }
  return n + "]";
}
function Lne(e) {
  let t = "{", n = 0, i, r;
  for (i in e)
    r = e[i], t += (++n > 1 ? "," : "") + W(i) + ":" + (K(r) ? r.signal || Zw(r) : W(r));
  return t + "}";
}
function Ine() {
  const e = "sans-serif", i = "#4c78a8", r = "#000", o = "#888", a = "#ddd";
  return {
    description: "Vega visualization",
    padding: 0,
    autosize: "pad",
    background: null,
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    group: null,
    mark: null,
    arc: {
      fill: i
    },
    area: {
      fill: i
    },
    image: null,
    line: {
      stroke: i,
      strokeWidth: 2
    },
    path: {
      stroke: i
    },
    rect: {
      fill: i
    },
    rule: {
      stroke: r
    },
    shape: {
      stroke: i
    },
    symbol: {
      fill: i,
      size: 64
    },
    text: {
      fill: r,
      font: e,
      fontSize: 11
    },
    trail: {
      fill: i,
      size: 2
    },
    style: {
      "guide-label": {
        fill: r,
        font: e,
        fontSize: 10
      },
      "guide-title": {
        fill: r,
        font: e,
        fontSize: 11,
        fontWeight: "bold"
      },
      "group-title": {
        fill: r,
        font: e,
        fontSize: 13,
        fontWeight: "bold"
      },
      "group-subtitle": {
        fill: r,
        font: e,
        fontSize: 12
      },
      point: {
        size: 30,
        strokeWidth: 2,
        shape: "circle"
      },
      circle: {
        size: 30,
        strokeWidth: 2
      },
      square: {
        size: 30,
        strokeWidth: 2,
        shape: "square"
      },
      cell: {
        fill: "transparent",
        stroke: a
      },
      view: {
        fill: "transparent"
      }
    },
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: !0,
      domainWidth: 1,
      domainColor: o,
      grid: !1,
      gridWidth: 1,
      gridColor: a,
      labels: !0,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: !0,
      tickColor: o,
      tickOffset: 0,
      tickRound: !0,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    axisBand: {
      tickOffset: -0.5
    },
    projection: {
      type: "mercator"
    },
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: a,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: !0,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: o,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function Pne(e, t, n) {
  return K(e) || I("Input Vega specification must be an object."), t = ll(Ine(), t, e.config), Nne(e, new vR(t, n)).toRuntime();
}
var zne = "5.25.0";
ce(Tu, j9, sW, zW, AH, bY, HX, AX, XX, yV, kV, DV);
const Bne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  version: zne,
  Dataflow: gu,
  EventStream: Ag,
  MultiPulse: Ob,
  Operator: Le,
  Parameters: Sg,
  Pulse: jo,
  Transform: D,
  changeset: Ms,
  definition: QM,
  ingest: Ce,
  isTuple: Eg,
  transform: ZM,
  transforms: Tu,
  tupleid: te,
  interpolate: Xx,
  interpolateColors: Gg,
  interpolateRange: eO,
  quantizeInterpolator: tO,
  scale: $e,
  scheme: Vx,
  projection: H2,
  View: L5,
  defaultLocale: kb,
  formatLocale: Lh,
  locale: zM,
  resetDefaultLocale: j8,
  timeFormatLocale: Xc,
  expressionFunction: it,
  parse: Pne,
  runtimeContext: _5,
  codegenExpression: c5,
  parseExpression: $w,
  parseSelector: pa,
  Debug: xF,
  Error: sb,
  Info: bF,
  None: vF,
  Warn: ub,
  accessor: Fn,
  accessorFields: Bt,
  accessorName: Ze,
  array: X,
  ascending: hg,
  clampRange: TF,
  compare: hb,
  constant: Gt,
  debounce: pb,
  error: I,
  extend: ce,
  extent: hr,
  extentIndex: OF,
  falsy: xo,
  fastmap: fl,
  field: En,
  flush: NF,
  hasOwnProperty: ie,
  id: _f,
  identity: Wt,
  inherits: G,
  inrange: lu,
  isArray: P,
  isBoolean: ua,
  isDate: zo,
  isFunction: fe,
  isIterable: DF,
  isNumber: Oe,
  isObject: K,
  isRegExp: RF,
  isString: Y,
  key: gb,
  lerp: LF,
  logger: lb,
  lruCache: IF,
  merge: PF,
  mergeConfig: ll,
  one: ul,
  pad: zF,
  panLinear: AF,
  panLog: $F,
  panPow: kF,
  panSymlog: CF,
  peek: xe,
  quarter: FF,
  repeat: sc,
  span: Sf,
  splitAccessPath: Er,
  stringValue: W,
  toBoolean: mb,
  toDate: yb,
  toNumber: It,
  toSet: Oi,
  toString: vb,
  truncate: BF,
  truthy: ei,
  utcquarter: MF,
  visitArray: _o,
  writeConfig: cl,
  zero: Co,
  zoomLinear: cb,
  zoomLog: fb,
  zoomPow: Fh,
  zoomSymlog: db,
  bandwidthNRD: Lb,
  bin: tT,
  bootstrapCI: nT,
  cumulativeLogNormal: Ub,
  cumulativeNormal: kg,
  cumulativeUniform: Hb,
  densityLogNormal: jb,
  densityNormal: Ib,
  densityUniform: Gb,
  dotbin: iT,
  quantileLogNormal: qb,
  quantileNormal: Cg,
  quantileUniform: Yb,
  quantiles: Db,
  quartiles: Rb,
  get random() {
    return ni;
  },
  randomInteger: Gz,
  randomKDE: zb,
  randomLCG: Wz,
  randomLogNormal: oT,
  randomMixture: aT,
  randomNormal: Pb,
  randomUniform: sT,
  regressionConstant: Xb,
  regressionExp: lT,
  regressionLinear: Vb,
  regressionLoess: dT,
  regressionLog: uT,
  regressionPoly: fT,
  regressionPow: cT,
  regressionQuad: Kb,
  sampleCurve: Mg,
  sampleLogNormal: Bb,
  sampleNormal: $g,
  sampleUniform: Wb,
  setRandom: Uz,
  DATE: Sn,
  DAY: Lt,
  DAYOFYEAR: mr,
  HOURS: Bn,
  MILLISECONDS: Ni,
  MINUTES: jn,
  MONTH: jt,
  QUARTER: _n,
  SECONDS: ti,
  TIME_UNITS: Eb,
  WEEK: at,
  YEAR: $t,
  dayofyear: uM,
  timeBin: AM,
  timeFloor: gM,
  timeInterval: pl,
  timeOffset: vM,
  timeSequence: wM,
  timeUnitSpecifier: sM,
  timeUnits: _b,
  utcFloor: mM,
  utcInterval: gl,
  utcOffset: bM,
  utcSequence: EM,
  utcdayofyear: fM,
  utcweek: dM,
  week: lM,
  format: nh,
  formats: Mb,
  inferType: jM,
  inferTypes: UM,
  loader: xg,
  read: GM,
  responseType: WM,
  typeParsers: uy,
  path: Og,
  Bounds: nt,
  CanvasHandler: Wf,
  CanvasRenderer: np,
  Gradient: pO,
  GroupItem: Xg,
  Handler: Zo,
  Item: Yg,
  Marks: Un,
  RenderType: No,
  Renderer: Ar,
  ResourceLoader: n2,
  SVGHandler: x2,
  SVGRenderer: $2,
  SVGStringRenderer: k2,
  Scenegraph: v2,
  boundClip: uN,
  boundContext: Bf,
  boundItem: ky,
  boundMark: NO,
  boundStroke: uo,
  domChild: gn,
  domClear: vi,
  domCreate: To,
  domFind: b2,
  font: Zg,
  fontFamily: qf,
  fontSize: Sr,
  intersect: rN,
  intersectBoxLine: cu,
  intersectPath: i2,
  intersectPoint: r2,
  intersectRule: EO,
  lineHeight: Jo,
  markup: A2,
  multiLineOffset: g2,
  pathCurves: Zx,
  pathEqual: lN,
  pathParse: Iu,
  pathRectangle: yO,
  pathRender: ef,
  pathSymbols: mO,
  pathTrail: vO,
  point: tm,
  renderModule: nm,
  resetSVGClipId: xO,
  resetSVGDefIds: Aq,
  sceneEqual: C2,
  sceneFromJSON: RO,
  scenePickVisit: Kh,
  sceneToJSON: DO,
  sceneVisit: Di,
  sceneZOrder: o2,
  serializeXML: KO,
  textMetrics: Ci
}, Symbol.toStringTag, { value: "Module" }));
function jne(e, t, n) {
  let i;
  t.x2 && (t.x ? (n && e.x > e.x2 && (i = e.x, e.x = e.x2, e.x2 = i), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (i = e.y, e.y = e.y2, e.y2 = i), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2);
}
var Une = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
}, qne = {
  "*": (e, t) => e * t,
  "+": (e, t) => e + t,
  "-": (e, t) => e - t,
  "/": (e, t) => e / t,
  "%": (e, t) => e % t,
  ">": (e, t) => e > t,
  "<": (e, t) => e < t,
  "<=": (e, t) => e <= t,
  ">=": (e, t) => e >= t,
  "==": (e, t) => e == t,
  "!=": (e, t) => e != t,
  "===": (e, t) => e === t,
  "!==": (e, t) => e !== t,
  "&": (e, t) => e & t,
  "|": (e, t) => e | t,
  "^": (e, t) => e ^ t,
  "<<": (e, t) => e << t,
  ">>": (e, t) => e >> t,
  ">>>": (e, t) => e >>> t
}, Wne = {
  "+": (e) => +e,
  "-": (e) => -e,
  "~": (e) => ~e,
  "!": (e) => !e
};
const Gne = Array.prototype.slice, $a = (e, t, n) => {
  const i = n ? n(t[0]) : t[0];
  return i[e].apply(i, Gne.call(t, 1));
}, Hne = (e, t, n, i, r, o, a) => new Date(e, t || 0, n != null ? n : 1, i || 0, r || 0, o || 0, a || 0);
var Yne = {
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
  now: Date.now,
  utc: Date.UTC,
  datetime: Hne,
  date: (e) => new Date(e).getDate(),
  day: (e) => new Date(e).getDay(),
  year: (e) => new Date(e).getFullYear(),
  month: (e) => new Date(e).getMonth(),
  hours: (e) => new Date(e).getHours(),
  minutes: (e) => new Date(e).getMinutes(),
  seconds: (e) => new Date(e).getSeconds(),
  milliseconds: (e) => new Date(e).getMilliseconds(),
  time: (e) => new Date(e).getTime(),
  timezoneoffset: (e) => new Date(e).getTimezoneOffset(),
  utcdate: (e) => new Date(e).getUTCDate(),
  utcday: (e) => new Date(e).getUTCDay(),
  utcyear: (e) => new Date(e).getUTCFullYear(),
  utcmonth: (e) => new Date(e).getUTCMonth(),
  utchours: (e) => new Date(e).getUTCHours(),
  utcminutes: (e) => new Date(e).getUTCMinutes(),
  utcseconds: (e) => new Date(e).getUTCSeconds(),
  utcmilliseconds: (e) => new Date(e).getUTCMilliseconds(),
  length: (e) => e.length,
  join: function() {
    return $a("join", arguments);
  },
  indexof: function() {
    return $a("indexOf", arguments);
  },
  lastindexof: function() {
    return $a("lastIndexOf", arguments);
  },
  slice: function() {
    return $a("slice", arguments);
  },
  reverse: (e) => e.slice().reverse(),
  parseFloat,
  parseInt,
  upper: (e) => String(e).toUpperCase(),
  lower: (e) => String(e).toLowerCase(),
  substring: function() {
    return $a("substring", arguments, String);
  },
  split: function() {
    return $a("split", arguments, String);
  },
  replace: function() {
    return $a("replace", arguments, String);
  },
  trim: (e) => String(e).trim(),
  regexp: RegExp,
  test: (e, t) => RegExp(e).test(t)
};
const Xne = ["view", "item", "group", "xy", "x", "y"], Vne = {
  Literal: (e, t) => t.value,
  Identifier: (e, t) => {
    const n = t.name;
    return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : Une[n] || e.params["$" + n];
  },
  MemberExpression: (e, t) => {
    const n = !t.computed, i = e(t.object);
    n && (e.memberDepth += 1);
    const r = e(t.property);
    return n && (e.memberDepth -= 1), i[r];
  },
  CallExpression: (e, t) => {
    const n = t.arguments;
    let i = t.callee.name;
    return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Yne[i]).apply(e.fn, n.map(e));
  },
  ArrayExpression: (e, t) => t.elements.map(e),
  BinaryExpression: (e, t) => qne[t.operator](e(t.left), e(t.right)),
  UnaryExpression: (e, t) => Wne[t.operator](e(t.argument)),
  ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
  LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
  ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
    e.memberDepth += 1;
    const r = e(i.key);
    return e.memberDepth -= 1, n[r] = e(i.value), n;
  }, {})
};
function ec(e, t, n, i, r, o) {
  const a = (s) => Vne[s.type](a, s);
  return a.memberDepth = 0, a.fn = Object.create(t), a.params = n, a.datum = i, a.event = r, a.item = o, Xne.forEach((s) => a.fn[s] = (...u) => r.vega[s](...u)), a(e);
}
var Kne = {
  operator(e, t) {
    const n = t.ast, i = e.functions;
    return (r) => ec(n, i, r);
  },
  parameter(e, t) {
    const n = t.ast, i = e.functions;
    return (r, o) => ec(n, i, o, r);
  },
  event(e, t) {
    const n = t.ast, i = e.functions;
    return (r) => ec(n, i, void 0, void 0, r);
  },
  handler(e, t) {
    const n = t.ast, i = e.functions;
    return (r, o) => {
      const a = o.item && o.item.datum;
      return ec(n, i, r, a, o);
    };
  },
  encode(e, t) {
    const {
      marktype: n,
      channels: i
    } = t, r = e.functions, o = n === "group" || n === "image" || n === "rect";
    return (a, s) => {
      const u = a.datum;
      let l = 0, c;
      for (const f in i)
        c = ec(i[f].ast, r, s, u, void 0, a), a[f] !== c && (a[f] = c, l = 1);
      return n !== "rule" && jne(a, i, o), l;
    };
  }
};
const Jne = "vega-lite", Qne = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer', Zne = "5.14.1", eie = [
  "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
  "Dominik Moritz (https://www.domoritz.de)",
  "Arvind Satyanarayan (https://arvindsatya.com)",
  "Jeffrey Heer (https://jheer.org)"
], tie = "https://vega.github.io/vega-lite/", nie = "Vega-Lite is a concise high-level language for interactive visualization.", iie = [
  "vega",
  "chart",
  "visualization"
], rie = "build/vega-lite.js", oie = "build/vega-lite.min.js", aie = "build/vega-lite.min.js", sie = "build/src/index", uie = "build/src/index.d.ts", lie = {
  vl2pdf: "./bin/vl2pdf",
  vl2png: "./bin/vl2png",
  vl2svg: "./bin/vl2svg",
  vl2vg: "./bin/vl2vg"
}, cie = [
  "bin",
  "build",
  "src",
  "vega-lite*",
  "tsconfig.json"
], fie = {
  changelog: "conventional-changelog -p angular -r 2",
  prebuild: "yarn clean:build",
  build: "yarn build:only",
  "build:only": "tsc -p tsconfig.build.json && rollup -c",
  "prebuild:examples": "yarn build:only",
  "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
  "prebuild:examples-full": "yarn build:only",
  "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
  "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
  "build:toc": "yarn build:jekyll && scripts/generate-toc",
  "build:site": "rollup -c site/rollup.config.mjs",
  "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
  "build:versions": "scripts/update-version.sh",
  clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
  "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
  data: "rsync -r node_modules/vega-datasets/data/* site/data",
  schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
  renameschema: "scripts/rename-schema.sh",
  presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
  site: "yarn site:only",
  "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
  prettierbase: "prettier '**/*.{md,css,yml}'",
  format: "eslint . --fix && yarn prettierbase --write",
  lint: "eslint . && yarn prettierbase --check",
  jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
  test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
  "test:cover": "yarn jest --collectCoverage test/",
  "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
  "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
  "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
  watch: "tsc -p tsconfig.build.json -w",
  "watch:site": "yarn build:site -w",
  "watch:test": "yarn jest --watch test/",
  "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
  release: "release-it"
}, die = {
  type: "git",
  url: "https://github.com/vega/vega-lite.git"
}, hie = "BSD-3-Clause", pie = {
  url: "https://github.com/vega/vega-lite/issues"
}, gie = {
  "@babel/core": "^7.21.8",
  "@babel/plugin-proposal-class-properties": "^7.18.6",
  "@babel/preset-env": "^7.21.5",
  "@babel/preset-typescript": "^7.21.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-alias": "^5.0.0",
  "@rollup/plugin-babel": "^6.0.3",
  "@rollup/plugin-commonjs": "^25.0.0",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.0.2",
  "@rollup/plugin-terser": "^0.4.1",
  "@types/chai": "^4.3.5",
  "@types/d3": "^7.4.0",
  "@types/jest": "^27.4.1",
  "@types/pako": "^2.0.0",
  "@typescript-eslint/eslint-plugin": "^5.59.5",
  "@typescript-eslint/parser": "^5.59.5",
  ajv: "^8.12.0",
  "ajv-formats": "^2.1.1",
  chai: "^4.3.7",
  cheerio: "^1.0.0-rc.12",
  "conventional-changelog-cli": "^3.0.0",
  d3: "^7.8.4",
  "del-cli": "^5.0.0",
  eslint: "^8.40.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-jest": "^27.2.1",
  "eslint-plugin-prettier": "^4.2.1",
  "highlight.js": "^11.8.0",
  jest: "^27.5.1",
  "jest-dev-server": "^6.1.1",
  mkdirp: "^3.0.1",
  pako: "^2.1.0",
  prettier: "^2.8.8",
  puppeteer: "^15.0.0",
  "release-it": "^16.1.2",
  rollup: "^3.21.6",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-sourcemaps": "^0.6.3",
  serve: "^14.2.0",
  terser: "^5.17.3",
  "ts-jest": "^29.1.0",
  "ts-json-schema-generator": "^1.2.0",
  typescript: "~4.9.5",
  "vega-cli": "^5.25.0",
  "vega-datasets": "^2.7.0",
  "vega-embed": "^6.22.1",
  "vega-tooltip": "^0.32.0",
  "yaml-front-matter": "^4.1.1"
}, mie = {
  "@types/clone": "~2.1.1",
  clone: "~2.1.2",
  "fast-deep-equal": "~3.1.3",
  "fast-json-stable-stringify": "~2.1.0",
  "json-stringify-pretty-compact": "~3.0.0",
  tslib: "~2.5.0",
  "vega-event-selector": "~3.0.1",
  "vega-expression": "~5.1.0",
  "vega-util": "~1.17.2",
  yargs: "~17.7.2"
}, yie = {
  vega: "^5.24.0"
}, vie = {
  node: ">=16"
}, bie = {
  name: Jne,
  author: Qne,
  version: Zne,
  collaborators: eie,
  homepage: tie,
  description: nie,
  keywords: iie,
  main: rie,
  unpkg: oie,
  jsdelivr: aie,
  module: sie,
  types: uie,
  bin: lie,
  files: cie,
  scripts: fie,
  repository: die,
  license: hie,
  bugs: pie,
  devDependencies: gie,
  dependencies: mie,
  peerDependencies: yie,
  engines: vie
};
var bR = { exports: {} };
(function(e) {
  var t = function() {
    function n(d, h) {
      return h != null && d instanceof h;
    }
    var i;
    try {
      i = Map;
    } catch {
      i = function() {
      };
    }
    var r;
    try {
      r = Set;
    } catch {
      r = function() {
      };
    }
    var o;
    try {
      o = Promise;
    } catch {
      o = function() {
      };
    }
    function a(d, h, p, g, m) {
      typeof h == "object" && (p = h.depth, g = h.prototype, m = h.includeNonEnumerable, h = h.circular);
      var y = [], v = [], b = typeof Buffer < "u";
      typeof h > "u" && (h = !0), typeof p > "u" && (p = 1 / 0);
      function x(E, _) {
        if (E === null)
          return null;
        if (_ === 0)
          return E;
        var w, S;
        if (typeof E != "object")
          return E;
        if (n(E, i))
          w = new i();
        else if (n(E, r))
          w = new r();
        else if (n(E, o))
          w = new o(function(N, L) {
            E.then(function(z) {
              N(x(z, _ - 1));
            }, function(z) {
              L(x(z, _ - 1));
            });
          });
        else if (a.__isArray(E))
          w = [];
        else if (a.__isRegExp(E))
          w = new RegExp(E.source, f(E)), E.lastIndex && (w.lastIndex = E.lastIndex);
        else if (a.__isDate(E))
          w = new Date(E.getTime());
        else {
          if (b && Buffer.isBuffer(E))
            return Buffer.allocUnsafe ? w = Buffer.allocUnsafe(E.length) : w = new Buffer(E.length), E.copy(w), w;
          n(E, Error) ? w = Object.create(E) : typeof g > "u" ? (S = Object.getPrototypeOf(E), w = Object.create(S)) : (w = Object.create(g), S = g);
        }
        if (h) {
          var C = y.indexOf(E);
          if (C != -1)
            return v[C];
          y.push(E), v.push(w);
        }
        n(E, i) && E.forEach(function(N, L) {
          var z = x(L, _ - 1), J = x(N, _ - 1);
          w.set(z, J);
        }), n(E, r) && E.forEach(function(N) {
          var L = x(N, _ - 1);
          w.add(L);
        });
        for (var $ in E) {
          var A;
          S && (A = Object.getOwnPropertyDescriptor(S, $)), !(A && A.set == null) && (w[$] = x(E[$], _ - 1));
        }
        if (Object.getOwnPropertySymbols)
          for (var M = Object.getOwnPropertySymbols(E), $ = 0; $ < M.length; $++) {
            var F = M[$], O = Object.getOwnPropertyDescriptor(E, F);
            O && !O.enumerable && !m || (w[F] = x(E[F], _ - 1), O.enumerable || Object.defineProperty(w, F, {
              enumerable: !1
            }));
          }
        if (m)
          for (var k = Object.getOwnPropertyNames(E), $ = 0; $ < k.length; $++) {
            var T = k[$], O = Object.getOwnPropertyDescriptor(E, T);
            O && O.enumerable || (w[T] = x(E[T], _ - 1), Object.defineProperty(w, T, {
              enumerable: !1
            }));
          }
        return w;
      }
      return x(d, p);
    }
    a.clonePrototype = function(h) {
      if (h === null)
        return null;
      var p = function() {
      };
      return p.prototype = h, new p();
    };
    function s(d) {
      return Object.prototype.toString.call(d);
    }
    a.__objToStr = s;
    function u(d) {
      return typeof d == "object" && s(d) === "[object Date]";
    }
    a.__isDate = u;
    function l(d) {
      return typeof d == "object" && s(d) === "[object Array]";
    }
    a.__isArray = l;
    function c(d) {
      return typeof d == "object" && s(d) === "[object RegExp]";
    }
    a.__isRegExp = c;
    function f(d) {
      var h = "";
      return d.global && (h += "g"), d.ignoreCase && (h += "i"), d.multiline && (h += "m"), h;
    }
    return a.__getRegExpFlags = f, a;
  }();
  e.exports && (e.exports = t);
})(bR);
const xie = bR.exports;
var wie = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var i, r, o;
    if (Array.isArray(t)) {
      if (i = t.length, i != n.length)
        return !1;
      for (r = i; r-- !== 0; )
        if (!e(t[r], n[r]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (o = Object.keys(t), i = o.length, i !== Object.keys(n).length)
      return !1;
    for (r = i; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, o[r]))
        return !1;
    for (r = i; r-- !== 0; ) {
      var a = o[r];
      if (!e(t[a], n[a]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, eE = function(e, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  var n = typeof t.cycles == "boolean" ? t.cycles : !1, i = t.cmp && function(o) {
    return function(a) {
      return function(s, u) {
        var l = { key: s, value: a[s] }, c = { key: u, value: a[u] };
        return o(l, c);
      };
    };
  }(t.cmp), r = [];
  return function o(a) {
    if (a && a.toJSON && typeof a.toJSON == "function" && (a = a.toJSON()), a !== void 0) {
      if (typeof a == "number")
        return isFinite(a) ? "" + a : "null";
      if (typeof a != "object")
        return JSON.stringify(a);
      var s, u;
      if (Array.isArray(a)) {
        for (u = "[", s = 0; s < a.length; s++)
          s && (u += ","), u += o(a[s]) || "null";
        return u + "]";
      }
      if (a === null)
        return "null";
      if (r.indexOf(a) !== -1) {
        if (n)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var l = r.push(a) - 1, c = Object.keys(a).sort(i && i(a));
      for (u = "", s = 0; s < c.length; s++) {
        var f = c[s], d = o(a[f]);
        !d || (u && (u += ","), u += JSON.stringify(f) + ":" + d);
      }
      return r.splice(l, 1), "{" + u + "}";
    }
  }(e);
};
function tE(e) {
  return !!e.or;
}
function nE(e) {
  return !!e.and;
}
function iE(e) {
  return !!e.not;
}
function Ah(e, t) {
  if (iE(e))
    Ah(e.not, t);
  else if (nE(e))
    for (const n of e.and)
      Ah(n, t);
  else if (tE(e))
    for (const n of e.or)
      Ah(n, t);
  else
    t(e);
}
function xu(e, t) {
  return iE(e) ? { not: xu(e.not, t) } : nE(e) ? { and: e.and.map((n) => xu(n, t)) } : tE(e) ? { or: e.or.map((n) => xu(n, t)) } : t(e);
}
const rr = wie, ae = xie;
function xR(e) {
  throw new Error(e);
}
function Yu(e, t) {
  const n = {};
  for (const i of t)
    ie(e, i) && (n[i] = e[i]);
  return n;
}
function bn(e, t) {
  const n = { ...e };
  for (const i of t)
    delete n[i];
  return n;
}
Set.prototype.toJSON = function() {
  return `Set(${[...this].map((e) => eE(e)).join(",")})`;
};
const Pe = eE;
function ge(e) {
  if (Oe(e))
    return e;
  const t = Y(e) ? e : eE(e);
  if (t.length < 250)
    return t;
  let n = 0;
  for (let i = 0; i < t.length; i++) {
    const r = t.charCodeAt(i);
    n = (n << 5) - n + r, n = n & n;
  }
  return n;
}
function Mv(e) {
  return e === !1 || e === null;
}
function me(e, t) {
  return e.includes(t);
}
function ms(e, t) {
  let n = 0;
  for (const [i, r] of e.entries())
    if (t(r, i, n++))
      return !0;
  return !1;
}
function rE(e, t) {
  let n = 0;
  for (const [i, r] of e.entries())
    if (!t(r, i, n++))
      return !1;
  return !0;
}
function wR(e, ...t) {
  for (const n of t)
    Eie(e, n != null ? n : {});
  return e;
}
function Eie(e, t) {
  for (const n of B(t))
    cl(e, n, t[n], !0);
}
function or(e, t) {
  const n = [], i = {};
  let r;
  for (const o of e)
    r = t(o), !(r in i) && (i[r] = 1, n.push(o));
  return n;
}
function _ie(e, t) {
  const n = B(e), i = B(t);
  if (n.length !== i.length)
    return !1;
  for (const r of n)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function ER(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function oE(e, t) {
  for (const n of e)
    if (t.has(n))
      return !0;
  return !1;
}
function Tv(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e) {
    const r = Er(n).map((a, s) => s === 0 ? a : `[${a}]`), o = r.map((a, s) => r.slice(0, s + 1).join(""));
    for (const a of o)
      t.add(a);
  }
  return t;
}
function aE(e, t) {
  return e === void 0 || t === void 0 ? !0 : oE(Tv(e), Tv(t));
}
function De(e) {
  return B(e).length === 0;
}
const B = Object.keys, kt = Object.values, na = Object.entries;
function mf(e) {
  return e === !0 || e === !1;
}
function We(e) {
  const t = e.replace(/\W/g, "_");
  return (e.match(/^\d+/) ? "_" : "") + t;
}
function jc(e, t) {
  return iE(e) ? `!(${jc(e.not, t)})` : nE(e) ? `(${e.and.map((n) => jc(n, t)).join(") && (")})` : tE(e) ? `(${e.or.map((n) => jc(n, t)).join(") || (")})` : t(e);
}
function Wp(e, t) {
  if (t.length === 0)
    return !0;
  const n = t.shift();
  return n in e && Wp(e[n], t) && delete e[n], De(e);
}
function td(e) {
  return e.charAt(0).toUpperCase() + e.substr(1);
}
function sE(e, t = "datum") {
  const n = Er(e), i = [];
  for (let r = 1; r <= n.length; r++) {
    const o = `[${n.slice(0, r).map(W).join("][")}]`;
    i.push(`${t}${o}`);
  }
  return i.join(" && ");
}
function _R(e, t = "datum") {
  return `${t}[${W(Er(e).join("."))}]`;
}
function Sie(e) {
  return e.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function ri(e) {
  return `${Er(e).map(Sie).join("\\.")}`;
}
function ys(e, t, n) {
  return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n);
}
function uE(e) {
  return `${Er(e).join(".")}`;
}
function Xu(e) {
  return e ? Er(e).length : 0;
}
function tt(...e) {
  for (const t of e)
    if (t !== void 0)
      return t;
}
let SR = 42;
function AR(e) {
  const t = ++SR;
  return e ? String(e) + t : t;
}
function Aie() {
  SR = 42;
}
function $R(e) {
  return kR(e) ? e : `__${e}`;
}
function kR(e) {
  return e.startsWith("__");
}
function yf(e) {
  if (e !== void 0)
    return (e % 360 + 360) % 360;
}
function Am(e) {
  return Oe(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e));
}
const Zr = "row", eo = "column", $m = "facet", Ge = "x", bt = "y", Bi = "x2", Cr = "y2", ga = "xOffset", Sl = "yOffset", ji = "radius", fo = "radius2", si = "theta", ho = "theta2", Ui = "latitude", qi = "longitude", Wi = "latitude2", oi = "longitude2", $n = "color", Fr = "fill", Mr = "stroke", kn = "shape", po = "size", Ls = "angle", go = "opacity", ma = "fillOpacity", ya = "strokeOpacity", va = "strokeWidth", ba = "strokeDash", nd = "text", Vu = "order", id = "detail", km = "key", vs = "tooltip", Cm = "href", Fm = "url", Mm = "description", $ie = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
}, CR = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function FR(e) {
  return e in CR;
}
const lE = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function MR(e) {
  switch (e) {
    case Ui:
      return "y";
    case Wi:
      return "y2";
    case qi:
      return "x";
    case oi:
      return "x2";
  }
}
function TR(e) {
  return e in lE;
}
const kie = B(lE), cE = {
  ...$ie,
  ...CR,
  ...lE,
  xOffset: 1,
  yOffset: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
};
function wu(e) {
  return e === $n || e === Fr || e === Mr;
}
const OR = {
  row: 1,
  column: 1,
  facet: 1
}, Jn = B(OR), fE = {
  ...cE,
  ...OR
}, Cie = B(fE), { order: Epe, detail: _pe, tooltip: Spe, ...Fie } = fE, { row: Ape, column: $pe, facet: kpe, ...Mie } = Fie;
function Tie(e) {
  return !!Mie[e];
}
function NR(e) {
  return !!fE[e];
}
const Oie = [Bi, Cr, Wi, oi, ho, fo];
function DR(e) {
  return Is(e) !== e;
}
function Is(e) {
  switch (e) {
    case Bi:
      return Ge;
    case Cr:
      return bt;
    case Wi:
      return Ui;
    case oi:
      return qi;
    case ho:
      return si;
    case fo:
      return ji;
  }
  return e;
}
function ia(e) {
  if (FR(e))
    switch (e) {
      case si:
        return "startAngle";
      case ho:
        return "endAngle";
      case ji:
        return "outerRadius";
      case fo:
        return "innerRadius";
    }
  return e;
}
function Tr(e) {
  switch (e) {
    case Ge:
      return Bi;
    case bt:
      return Cr;
    case Ui:
      return Wi;
    case qi:
      return oi;
    case si:
      return ho;
    case ji:
      return fo;
  }
}
function Cn(e) {
  switch (e) {
    case Ge:
    case Bi:
      return "width";
    case bt:
    case Cr:
      return "height";
  }
}
function RR(e) {
  switch (e) {
    case Ge:
      return "xOffset";
    case bt:
      return "yOffset";
    case Bi:
      return "x2Offset";
    case Cr:
      return "y2Offset";
    case si:
      return "thetaOffset";
    case ji:
      return "radiusOffset";
    case ho:
      return "theta2Offset";
    case fo:
      return "radius2Offset";
  }
}
function dE(e) {
  switch (e) {
    case Ge:
      return "xOffset";
    case bt:
      return "yOffset";
  }
}
function LR(e) {
  switch (e) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
const Nie = B(cE), {
  x: Cpe,
  y: Fpe,
  x2: Mpe,
  y2: Tpe,
  xOffset: Ope,
  yOffset: Npe,
  latitude: Dpe,
  longitude: Rpe,
  latitude2: Lpe,
  longitude2: Ipe,
  theta: Ppe,
  theta2: zpe,
  radius: Bpe,
  radius2: jpe,
  ...hE
} = cE, Die = B(hE), pE = {
  x: 1,
  y: 1
}, Or = B(pE);
function xt(e) {
  return e in pE;
}
const gE = {
  theta: 1,
  radius: 1
}, Rie = B(gE);
function Tm(e) {
  return e === "width" ? Ge : bt;
}
const IR = { xOffset: 1, yOffset: 1 };
function Al(e) {
  return e in IR;
}
const {
  text: Upe,
  tooltip: qpe,
  href: Wpe,
  url: Gpe,
  description: Hpe,
  detail: Ype,
  key: Xpe,
  order: Vpe,
  ...PR
} = hE, Lie = B(PR);
function Iie(e) {
  return !!hE[e];
}
function Pie(e) {
  switch (e) {
    case $n:
    case Fr:
    case Mr:
    case po:
    case kn:
    case go:
    case va:
    case ba:
      return !0;
    case ma:
    case ya:
    case Ls:
      return !1;
  }
}
const zR = {
  ...pE,
  ...gE,
  ...IR,
  ...PR
}, Om = B(zR);
function mo(e) {
  return !!zR[e];
}
function zie(e, t) {
  return jie(e)[t];
}
const BR = {
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
}, { geoshape: Kpe, ...Bie } = BR;
function jie(e) {
  switch (e) {
    case $n:
    case Fr:
    case Mr:
    case Mm:
    case id:
    case km:
    case vs:
    case Cm:
    case Vu:
    case go:
    case ma:
    case ya:
    case va:
    case $m:
    case Zr:
    case eo:
      return BR;
    case Ge:
    case bt:
    case ga:
    case Sl:
    case Ui:
    case qi:
      return Bie;
    case Bi:
    case Cr:
    case Wi:
    case oi:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case po:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case ba:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case kn:
      return { point: "always", geoshape: "always" };
    case nd:
      return { text: "always" };
    case Ls:
      return { point: "always", square: "always", text: "always" };
    case Fm:
      return { image: "always" };
    case si:
      return { text: "always", arc: "always" };
    case ji:
      return { text: "always", arc: "always" };
    case ho:
    case fo:
      return { arc: "always" };
  }
}
function _1(e) {
  switch (e) {
    case Ge:
    case bt:
    case si:
    case ji:
    case ga:
    case Sl:
    case po:
    case Ls:
    case va:
    case go:
    case ma:
    case ya:
    case Bi:
    case Cr:
    case ho:
    case fo:
      return;
    case $m:
    case Zr:
    case eo:
    case kn:
    case ba:
    case nd:
    case vs:
    case Cm:
    case Fm:
    case Mm:
      return "discrete";
    case $n:
    case Fr:
    case Mr:
      return "flexible";
    case Ui:
    case qi:
    case Wi:
    case oi:
    case id:
    case km:
    case Vu:
      return;
  }
}
const Uie = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
}, qie = {
  count: 1,
  min: 1,
  max: 1
};
function ao(e) {
  return !!e && !!e.argmin;
}
function xa(e) {
  return !!e && !!e.argmax;
}
function mE(e) {
  return Y(e) && !!Uie[e];
}
const Wie = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function jR(e) {
  return Y(e) && Wie.has(e);
}
function Gie(e) {
  return Y(e) && me(["min", "max"], e);
}
const Hie = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]), Yie = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);
function UR(e) {
  return ua(e) && (e = Wm(e, void 0)), "bin" + B(e).map((t) => Nm(e[t]) ? We(`_${t}_${na(e[t])}`) : We(`_${t}_${e[t]}`)).join("");
}
function ze(e) {
  return e === !0 || Ps(e) && !e.binned;
}
function _t(e) {
  return e === "binned" || Ps(e) && e.binned === !0;
}
function Ps(e) {
  return K(e);
}
function Nm(e) {
  return e == null ? void 0 : e.param;
}
function Ak(e) {
  switch (e) {
    case Zr:
    case eo:
    case po:
    case $n:
    case Fr:
    case Mr:
    case va:
    case go:
    case ma:
    case ya:
    case kn:
      return 6;
    case ba:
      return 4;
    default:
      return 10;
  }
}
function rd(e) {
  return !!(e != null && e.expr);
}
function pn(e) {
  const t = B(e || {}), n = {};
  for (const i of t)
    n[i] = Ln(e[i]);
  return n;
}
function qR(e) {
  const {
    anchor: t,
    frame: n,
    offset: i,
    orient: r,
    angle: o,
    limit: a,
    color: s,
    subtitleColor: u,
    subtitleFont: l,
    subtitleFontSize: c,
    subtitleFontStyle: f,
    subtitleFontWeight: d,
    subtitleLineHeight: h,
    subtitlePadding: p,
    ...g
  } = e, m = {
    ...g,
    ...s ? { fill: s } : {}
  }, y = {
    ...t ? { anchor: t } : {},
    ...n ? { frame: n } : {},
    ...i ? { offset: i } : {},
    ...r ? { orient: r } : {},
    ...o !== void 0 ? { angle: o } : {},
    ...a !== void 0 ? { limit: a } : {}
  }, v = {
    ...u ? { subtitleColor: u } : {},
    ...l ? { subtitleFont: l } : {},
    ...c ? { subtitleFontSize: c } : {},
    ...f ? { subtitleFontStyle: f } : {},
    ...d ? { subtitleFontWeight: d } : {},
    ...h ? { subtitleLineHeight: h } : {},
    ...p ? { subtitlePadding: p } : {}
  }, b = Yu(e, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig: m, subtitleMarkConfig: b, nonMarkTitleProperties: y, subtitle: v };
}
function ko(e) {
  return Y(e) || P(e) && Y(e[0]);
}
function Z(e) {
  return !!(e != null && e.signal);
}
function wa(e) {
  return !!e.step;
}
function Xie(e) {
  return P(e) ? !1 : "fields" in e && !("data" in e);
}
function Vie(e) {
  return P(e) ? !1 : "fields" in e && "data" in e;
}
function Vr(e) {
  return P(e) ? !1 : "field" in e && "data" in e;
}
const Kie = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
}, Jie = B(Kie), Qie = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
}, Ov = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];
function WR(e) {
  const t = P(e.condition) ? e.condition.map($k) : $k(e.condition);
  return {
    ...Ln(e),
    condition: t
  };
}
function Ln(e) {
  if (rd(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function $k(e) {
  if (rd(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function je(e) {
  if (rd(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return Z(e) ? e : e !== void 0 ? { value: e } : void 0;
}
function Zie(e) {
  return Z(e) ? e.signal : W(e);
}
function kk(e) {
  return Z(e) ? e.signal : W(e.value);
}
function Ai(e) {
  return Z(e) ? e.signal : e == null ? null : W(e);
}
function ere(e, t, n) {
  for (const i of n) {
    const r = so(i, t.markDef, t.config);
    r !== void 0 && (e[i] = je(r));
  }
  return e;
}
function GR(e) {
  var t;
  return [].concat(e.type, (t = e.style) != null ? t : []);
}
function Me(e, t, n, i = {}) {
  const { vgChannel: r, ignoreVgConfig: o } = i;
  return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : o && (!r || r === e) ? void 0 : so(e, t, n, i);
}
function so(e, t, n, { vgChannel: i } = {}) {
  return tt(
    i ? Gp(e, t, n.style) : void 0,
    Gp(e, t, n.style),
    i ? n[t.type][i] : void 0,
    n[t.type][e],
    i ? n.mark[i] : n.mark[e]
  );
}
function Gp(e, t, n) {
  return HR(e, GR(t), n);
}
function HR(e, t, n) {
  t = X(t);
  let i;
  for (const r of t) {
    const o = n[r];
    o && o[e] !== void 0 && (i = o[e]);
  }
  return i;
}
function YR(e, t) {
  return X(e).reduce((n, i) => {
    var r;
    return n.field.push(H(i, t)), n.order.push((r = i.sort) != null ? r : "ascending"), n;
  }, { field: [], order: [] });
}
function XR(e, t) {
  const n = [...e];
  return t.forEach((i) => {
    for (const r of n)
      if (rr(r, i))
        return;
    n.push(i);
  }), n;
}
function VR(e, t) {
  return rr(e, t) || !t ? e : e ? [...X(e), ...X(t)].join(", ") : t;
}
function KR(e, t) {
  const n = e.value, i = t.value;
  if (n == null || i === null)
    return {
      explicit: e.explicit,
      value: null
    };
  if ((ko(n) || Z(n)) && (ko(i) || Z(i)))
    return {
      explicit: e.explicit,
      value: VR(n, i)
    };
  if (ko(n) || Z(n))
    return {
      explicit: e.explicit,
      value: n
    };
  if (ko(i) || Z(i))
    return {
      explicit: e.explicit,
      value: i
    };
  if (!ko(n) && !Z(n) && !ko(i) && !Z(i))
    return {
      explicit: e.explicit,
      value: XR(n, i)
    };
  throw new Error("It should never reach here");
}
function yE(e) {
  return `Invalid specification ${Pe(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
const tre = 'Autosize "fit" only works for single views and layered views.';
function Ck(e) {
  return `${e == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
}
function Fk(e) {
  const t = e == "width" ? "Width" : "Height", n = e == "width" ? "x" : "y";
  return `${t} "container" only works well with autosize "fit" or "fit-${n}".`;
}
function Mk(e) {
  return e ? `Dropping "fit-${e}" because spec has discrete ${Cn(e)}.` : 'Dropping "fit" because spec has discrete size.';
}
function vE(e) {
  return `Unknown field for ${e}. Cannot calculate view size.`;
}
function Tk(e) {
  return `Cannot project a selection on encoding channel "${e}", which has no field.`;
}
function nre(e, t) {
  return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`;
}
function ire(e) {
  return `The "nearest" transform is not supported for ${e} marks.`;
}
function JR(e) {
  return `Selection not supported for ${e} yet.`;
}
function rre(e) {
  return `Cannot find a selection named "${e}".`;
}
const ore = "Scale bindings are currently only supported for scales with unbinned, continuous domains.", are = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function sre(e) {
  return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`;
}
function ure(e) {
  return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
const lre = "The same selection must be used to override scale domains in a layered view.", cre = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
function fre(e) {
  return `Unknown repeated value "${e}".`;
}
function Ok(e) {
  return `The "columns" property cannot be used when "${e}" has nested row/column.`;
}
const dre = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function hre(e) {
  return `Unrecognized parse "${e}".`;
}
function Nk(e, t, n) {
  return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`;
}
const pre = "Attempt to add the same child twice.";
function gre(e) {
  return `Ignoring an invalid transform: ${Pe(e)}.`;
}
const mre = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function Dk(e) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`;
}
function yre(e) {
  const { parentProjection: t, projection: n } = e;
  return `Layer's shared projection ${Pe(t)} is overridden by a child projection ${Pe(n)}.`;
}
const vre = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function bre(e) {
  return `${e}Offset dropped because ${e} is continuous`;
}
function xre(e) {
  return `There is no ${e} encoding. Replacing ${e}Offset encoding as ${e}.`;
}
function wre(e, t, n) {
  return `Channel ${e} is a ${t}. Converted to {value: ${Pe(n)}}.`;
}
function QR(e) {
  return `Invalid field type "${e}".`;
}
function Ere(e, t) {
  return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`;
}
function _re(e) {
  return `Invalid aggregation operator "${e}".`;
}
function ZR(e, t) {
  const { fill: n, stroke: i } = t;
  return `Dropping color ${e} as the plot also has ${n && i ? "fill and stroke" : n ? "fill" : "stroke"}.`;
}
function Sre(e) {
  return `Position range does not support relative band size for ${e}.`;
}
function Nv(e, t) {
  return `Dropping ${Pe(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`;
}
const Are = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function Dm(e, t, n) {
  return `${e} dropped as it is incompatible with "${t}"${n ? ` when ${n}` : ""}.`;
}
function $re(e) {
  return `${e} encoding has no scale, so specified scale is ignored.`;
}
function kre(e) {
  return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`;
}
function Cre(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned).`;
}
function Fre(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function Mre(e) {
  return `Facet encoding dropped as ${e.join(" and ")} ${e.length > 1 ? "are" : "is"} also specified.`;
}
function S1(e, t) {
  return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t === "ordinal" ? "order" : "magnitude"}.`;
}
function Tre(e) {
  return `The ${e} for range marks cannot be an expression`;
}
function Ore(e, t) {
  return `Line mark is for continuous lines and thus cannot be used with ${e && t ? "x2 and y2" : e ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`;
}
function Nre(e, t) {
  return `Specified orient "${e}" overridden with "${t}".`;
}
function Dre(e) {
  return `Cannot use the scale property "${e}" with non-color channel.`;
}
function Rre(e) {
  return `Cannot use the relative band size with ${e} scale.`;
}
function Lre(e) {
  return `Using unaggregated domain with raw field has no effect (${Pe(e)}).`;
}
function Ire(e) {
  return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`;
}
function Pre(e) {
  return `Unaggregated domain is currently unsupported for log scale (${Pe(e)}).`;
}
function zre(e) {
  return `Cannot apply size to non-oriented mark "${e}".`;
}
function Bre(e, t, n) {
  return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`;
}
function jre(e, t) {
  return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`;
}
function e6(e, t, n) {
  return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`;
}
function t6(e) {
  return `The step for "${e}" is dropped because the ${e === "width" ? "x" : "y"} is continuous.`;
}
function Ure(e, t, n, i) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${Pe(n)} and ${Pe(i)}). Using ${Pe(n)}.`;
}
function qre(e, t, n, i) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${Pe(n)} and ${Pe(i)}). Using the union of the two domains.`;
}
function Wre(e) {
  return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`;
}
function Gre(e) {
  return `Dropping sort property ${Pe(e)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
const Rk = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.", Hre = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.", Yre = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.", Xre = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function Vre(e) {
  return `Cannot stack "${e}" if there is already "${e}2".`;
}
function Kre(e) {
  return `Cannot stack non-linear scale (${e}).`;
}
function Jre(e) {
  return `Stacking is applied even though the aggregate function is non-summative ("${e}").`;
}
function Hp(e, t) {
  return `Invalid ${e}: ${Pe(t)}.`;
}
function Qre(e) {
  return `Dropping day from datetime ${Pe(e)} as day cannot be combined with other units.`;
}
function Zre(e, t) {
  return `${t ? "extent " : ""}${t && e ? "and " : ""}${e ? "center " : ""}${t && e ? "are " : "is "}not needed when data are aggregated.`;
}
function eoe(e, t, n) {
  return `${e} is not usually used with ${t} for ${n}.`;
}
function toe(e, t) {
  return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`;
}
function Lk(e) {
  return `1D error band does not support ${e}.`;
}
function n6(e) {
  return `Channel ${e} is required for "binned" bin.`;
}
function noe(e) {
  return `Channel ${e} should not be used with "binned" bin.`;
}
function ioe(e) {
  return `Domain for ${e} is required for threshold scale.`;
}
globalThis && globalThis.__classPrivateFieldSet;
globalThis && globalThis.__classPrivateFieldGet;
const i6 = lb(ub);
let Ku = i6;
function roe(e) {
  return Ku = e, Ku;
}
function ooe() {
  return Ku = i6, Ku;
}
function U(...e) {
  Ku.warn(...e);
}
function aoe(...e) {
  Ku.debug(...e);
}
function zs(e) {
  if (e && K(e)) {
    for (const t of xE)
      if (t in e)
        return !0;
  }
  return !1;
}
const r6 = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], soe = r6.map((e) => e.substr(0, 3)), o6 = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"], uoe = o6.map((e) => e.substr(0, 3));
function loe(e) {
  if (Am(e) && (e = +e), Oe(e))
    return e > 4 && U(Hp("quarter", e)), e - 1;
  throw new Error(Hp("quarter", e));
}
function coe(e) {
  if (Am(e) && (e = +e), Oe(e))
    return e - 1;
  {
    const t = e.toLowerCase(), n = r6.indexOf(t);
    if (n !== -1)
      return n;
    const i = t.substr(0, 3), r = soe.indexOf(i);
    if (r !== -1)
      return r;
    throw new Error(Hp("month", e));
  }
}
function foe(e) {
  if (Am(e) && (e = +e), Oe(e))
    return e % 7;
  {
    const t = e.toLowerCase(), n = o6.indexOf(t);
    if (n !== -1)
      return n;
    const i = t.substr(0, 3), r = uoe.indexOf(i);
    if (r !== -1)
      return r;
    throw new Error(Hp("day", e));
  }
}
function bE(e, t) {
  const n = [];
  if (t && e.day !== void 0 && B(e).length > 1 && (U(Qre(e)), e = ae(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
    const i = t ? coe(e.month) : e.month;
    n.push(i);
  } else if (e.quarter !== void 0) {
    const i = t ? loe(e.quarter) : e.quarter;
    n.push(Oe(i) ? i * 3 : `${i}*3`);
  } else
    n.push(0);
  if (e.date !== void 0)
    n.push(e.date);
  else if (e.day !== void 0) {
    const i = t ? foe(e.day) : e.day;
    n.push(Oe(i) ? i + 1 : `${i}+1`);
  } else
    n.push(1);
  for (const i of ["hours", "minutes", "seconds", "milliseconds"]) {
    const r = e[i];
    n.push(typeof r > "u" ? 0 : r);
  }
  return n;
}
function bs(e) {
  const n = bE(e, !0).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function doe(e) {
  const n = bE(e, !1).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function hoe(e) {
  const t = bE(e, !0);
  return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t);
}
const a6 = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
}, xE = B(a6);
function poe(e) {
  return !!a6[e];
}
function Bs(e) {
  return K(e) ? e.binned : s6(e);
}
function s6(e) {
  return e && e.startsWith("binned");
}
function wE(e) {
  return e.startsWith("utc");
}
function goe(e) {
  return e.substring(3);
}
const moe = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function Rm(e) {
  return xE.filter((t) => l6(e, t));
}
function u6(e) {
  const t = Rm(e);
  return t[t.length - 1];
}
function l6(e, t) {
  const n = e.indexOf(t);
  return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f");
}
function yoe(e, t, { end: n } = { end: !1 }) {
  const i = sE(t), r = wE(e) ? "utc" : "";
  function o(u) {
    return u === "quarter" ? `(${r}quarter(${i})-1)` : `${r}${u}(${i})`;
  }
  let a;
  const s = {};
  for (const u of xE)
    l6(e, u) && (s[u] = o(u), a = u);
  return n && (s[a] += "+1"), doe(s);
}
function c6(e) {
  if (!e)
    return;
  const t = Rm(e);
  return `timeUnitSpecifier(${Pe(t)}, ${Pe(moe)})`;
}
function voe(e, t, n) {
  if (!e)
    return;
  const i = c6(e);
  return `${n || wE(e) ? "utc" : "time"}Format(${t}, ${i})`;
}
function vt(e) {
  if (!e)
    return;
  let t;
  return Y(e) ? s6(e) ? t = {
    unit: e.substring(6),
    binned: !0
  } : t = {
    unit: e
  } : K(e) && (t = {
    ...e,
    ...e.unit ? { unit: e.unit } : {}
  }), wE(t.unit) && (t.utc = !0, t.unit = goe(t.unit)), t;
}
function boe(e) {
  const { utc: t, ...n } = vt(e);
  return n.unit ? (t ? "utc" : "") + B(n).map((i) => We(`${i === "unit" ? "" : `_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + B(n).map((i) => We(`_${i}_${n[i]}`)).join("");
}
function f6(e, t = (n) => n) {
  const n = vt(e), i = u6(n.unit);
  if (i && i !== "day") {
    const r = {
      year: 2001,
      month: 1,
      date: 1,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    }, { step: o, part: a } = d6(i, n.step), s = {
      ...r,
      [a]: +r[a] + o
    };
    return `${t(bs(s))} - ${t(bs(r))}`;
  }
}
const xoe = {
  year: 1,
  month: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
function woe(e) {
  return !!xoe[e];
}
function d6(e, t = 1) {
  if (woe(e))
    return { part: e, step: t };
  switch (e) {
    case "day":
    case "dayofyear":
      return { part: "date", step: t };
    case "quarter":
      return { part: "month", step: t * 3 };
    case "week":
      return { part: "date", step: t * 7 };
  }
}
function Eoe(e) {
  return e == null ? void 0 : e.param;
}
function EE(e) {
  return !!(e != null && e.field) && e.equal !== void 0;
}
function _E(e) {
  return !!(e != null && e.field) && e.lt !== void 0;
}
function SE(e) {
  return !!(e != null && e.field) && e.lte !== void 0;
}
function AE(e) {
  return !!(e != null && e.field) && e.gt !== void 0;
}
function $E(e) {
  return !!(e != null && e.field) && e.gte !== void 0;
}
function kE(e) {
  if (e != null && e.field) {
    if (P(e.range) && e.range.length === 2)
      return !0;
    if (Z(e.range))
      return !0;
  }
  return !1;
}
function CE(e) {
  return !!(e != null && e.field) && (P(e.oneOf) || P(e.in));
}
function _oe(e) {
  return !!(e != null && e.field) && e.valid !== void 0;
}
function h6(e) {
  return CE(e) || EE(e) || kE(e) || _E(e) || AE(e) || SE(e) || $E(e);
}
function Vi(e, t) {
  return Gm(e, { timeUnit: t, wrapTime: !0 });
}
function Soe(e, t) {
  return e.map((n) => Vi(n, t));
}
function p6(e, t = !0) {
  const { field: n } = e, i = vt(e.timeUnit), { unit: r, binned: o } = i || {}, a = H(e, { expr: "datum" }), s = r ? `time(${o ? a : yoe(r, n)})` : a;
  if (EE(e))
    return `${s}===${Vi(e.equal, r)}`;
  if (_E(e)) {
    const u = e.lt;
    return `${s}<${Vi(u, r)}`;
  } else if (AE(e)) {
    const u = e.gt;
    return `${s}>${Vi(u, r)}`;
  } else if (SE(e)) {
    const u = e.lte;
    return `${s}<=${Vi(u, r)}`;
  } else if ($E(e)) {
    const u = e.gte;
    return `${s}>=${Vi(u, r)}`;
  } else {
    if (CE(e))
      return `indexof([${Soe(e.oneOf, r).join(",")}], ${s}) !== -1`;
    if (_oe(e))
      return FE(s, e.valid);
    if (kE(e)) {
      const { range: u } = e, l = Z(u) ? { signal: `${u.signal}[0]` } : u[0], c = Z(u) ? { signal: `${u.signal}[1]` } : u[1];
      if (l !== null && c !== null && t)
        return "inrange(" + s + ", [" + Vi(l, r) + ", " + Vi(c, r) + "])";
      const f = [];
      return l !== null && f.push(`${s} >= ${Vi(l, r)}`), c !== null && f.push(`${s} <= ${Vi(c, r)}`), f.length > 0 ? f.join(" && ") : "true";
    }
  }
  throw new Error(`Invalid field predicate: ${Pe(e)}`);
}
function FE(e, t = !0) {
  return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`;
}
function Aoe(e) {
  return h6(e) && e.timeUnit ? {
    ...e,
    timeUnit: vt(e.timeUnit)
  } : e;
}
const od = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function $oe(e) {
  return e === "quantitative" || e === "temporal";
}
function g6(e) {
  return e === "ordinal" || e === "nominal";
}
const xs = od.quantitative, ME = od.ordinal, Ju = od.temporal, TE = od.nominal, $l = od.geojson;
function koe(e) {
  if (e)
    switch (e = e.toLowerCase(), e) {
      case "q":
      case xs:
        return "quantitative";
      case "t":
      case Ju:
        return "temporal";
      case "o":
      case ME:
        return "ordinal";
      case "n":
      case TE:
        return "nominal";
      case $l:
        return "geojson";
    }
}
const xn = {
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  SYMLOG: "symlog",
  IDENTITY: "identity",
  SEQUENTIAL: "sequential",
  TIME: "time",
  UTC: "utc",
  QUANTILE: "quantile",
  QUANTIZE: "quantize",
  THRESHOLD: "threshold",
  BIN_ORDINAL: "bin-ordinal",
  ORDINAL: "ordinal",
  POINT: "point",
  BAND: "band"
}, Dv = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
function Coe(e, t) {
  const n = Dv[e], i = Dv[t];
  return n === i || n === "ordinal-position" && i === "time" || i === "ordinal-position" && n === "time";
}
const Foe = {
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  time: 0,
  utc: 0,
  point: 10,
  band: 11,
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function Ik(e) {
  return Foe[e];
}
const m6 = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]), y6 = /* @__PURE__ */ new Set([
  ...m6,
  "time",
  "utc"
]);
function v6(e) {
  return m6.has(e);
}
const b6 = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]), Moe = /* @__PURE__ */ new Set([
  ...y6,
  ...b6,
  "sequential",
  "identity"
]), Toe = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function wt(e) {
  return Toe.has(e);
}
function Wn(e) {
  return Moe.has(e);
}
function $i(e) {
  return y6.has(e);
}
function Qu(e) {
  return b6.has(e);
}
const Ooe = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  minSize: 9,
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4,
  zero: !0
};
function Noe(e) {
  return !Y(e) && !!e.name;
}
function x6(e) {
  return e == null ? void 0 : e.param;
}
function Doe(e) {
  return e == null ? void 0 : e.unionWith;
}
function Roe(e) {
  return K(e) && "field" in e;
}
const Loe = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  domainRaw: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  reverse: 1,
  round: 1,
  clamp: 1,
  nice: 1,
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
}, { type: Jpe, domain: Qpe, range: Zpe, rangeMax: ege, rangeMin: tge, scheme: nge, ...Ioe } = Loe, Poe = B(Ioe);
function Rv(e, t) {
  switch (t) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return !0;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(e);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(e);
    case "round":
      return $i(e) || e === "band" || e === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return $i(e) || ["point", "band"].includes(e);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(e);
    case "paddingInner":
      return e === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "domainRaw":
    case "clamp":
      return $i(e);
    case "nice":
      return $i(e) || e === "quantize" || e === "threshold";
    case "exponent":
      return e === "pow";
    case "base":
      return e === "log";
    case "constant":
      return e === "symlog";
    case "zero":
      return Wn(e) && !me([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
      ], e);
  }
}
function w6(e, t) {
  switch (t) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      return wu(e) ? void 0 : Dre(t);
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "domainRaw":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return;
  }
}
function zoe(e, t) {
  return me([ME, TE], t) ? e === void 0 || wt(e) : t === Ju ? me([xn.TIME, xn.UTC, void 0], e) : t === xs ? v6(e) || Qu(e) || e === void 0 : !0;
}
function Boe(e, t, n = !1) {
  if (!mo(e))
    return !1;
  switch (e) {
    case Ge:
    case bt:
    case ga:
    case Sl:
    case si:
    case ji:
      return $i(t) || t === "band" ? !0 : t === "point" ? !n : !1;
    case po:
    case va:
    case go:
    case ma:
    case ya:
    case Ls:
      return $i(t) || Qu(t) || me(["band", "point", "ordinal"], t);
    case $n:
    case Fr:
    case Mr:
      return t !== "band";
    case ba:
    case kn:
      return t === "ordinal" || Qu(t);
  }
}
const ln = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
}, E6 = ln.arc, Lm = ln.area, Im = ln.bar, joe = ln.image, Pm = ln.line, zm = ln.point, Uoe = ln.rect, Yp = ln.rule, _6 = ln.text, OE = ln.tick, qoe = ln.trail, NE = ln.circle, DE = ln.square, S6 = ln.geoshape;
function Ea(e) {
  return ["line", "area", "trail"].includes(e);
}
function RE(e) {
  return ["rect", "bar", "image", "arc"].includes(e);
}
const Woe = new Set(B(ln));
function br(e) {
  return e.type;
}
const Goe = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
], Hoe = ["fill", "fillOpacity"], Yoe = [...Goe, ...Hoe], Xoe = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
}, Pk = B(Xoe), Voe = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
}, Koe = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
}, Joe = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
}, A6 = B(Joe);
function ws(e) {
  return e && e.band != null;
}
const Qoe = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
}, $6 = 5, Zoe = {
  binSpacing: 1,
  continuousBandSize: $6,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, eae = {
  binSpacing: 0,
  continuousBandSize: $6,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, tae = {
  thickness: 1
};
function nae(e) {
  return br(e) ? e.type : e;
}
function LE(e) {
  const { channel: t, channelDef: n, markDef: i, scale: r, config: o } = e, a = PE(e);
  return q(n) && !jR(n.aggregate) && r && $i(r.get("type")) ? iae({
    fieldDef: n,
    channel: t,
    markDef: i,
    ref: a,
    config: o
  }) : a;
}
function iae({ fieldDef: e, channel: t, markDef: n, ref: i, config: r }) {
  return Ea(n.type) ? i : Me("invalid", n, r) === null ? [rae(e, t), i] : i;
}
function rae(e, t) {
  const n = IE(e, !0), r = Is(t) === "y" ? { field: { group: "height" } } : { value: 0 };
  return { test: n, ...r };
}
function IE(e, t = !0) {
  return FE(Y(e) ? e : H(e, { expr: "datum" }), !t);
}
function oae(e) {
  const { datum: t } = e;
  return zs(t) ? bs(t) : `${Pe(t)}`;
}
function ts(e, t, n, i) {
  const r = {};
  if (t && (r.scale = t), Nr(e)) {
    const { datum: o } = e;
    zs(o) ? r.signal = bs(o) : Z(o) ? r.signal = o.signal : rd(o) ? r.signal = o.expr : r.value = o;
  } else
    r.field = H(e, n);
  if (i) {
    const { offset: o, band: a } = i;
    o && (r.offset = o), a && (r.band = a);
  }
  return r;
}
function Xp({ scaleName: e, fieldOrDatumDef: t, fieldOrDatumDef2: n, offset: i, startSuffix: r, bandPosition: o = 0.5 }) {
  const a = 0 < o && o < 1 ? "datum" : void 0, s = H(t, { expr: a, suffix: r }), u = n !== void 0 ? H(n, { expr: a }) : H(t, { suffix: "end", expr: a }), l = {};
  if (o === 0 || o === 1) {
    l.scale = e;
    const c = o === 0 ? s : u;
    l.field = c;
  } else {
    const c = Z(o) ? `${o.signal} * ${s} + (1-${o.signal}) * ${u}` : `${o} * ${s} + ${1 - o} * ${u}`;
    l.signal = `scale("${e}", ${c})`;
  }
  return i && (l.offset = i), l;
}
function aae({ scaleName: e, fieldDef: t }) {
  const n = H(t, { expr: "datum" }), i = H(t, { expr: "datum", suffix: "end" });
  return `abs(scale("${e}", ${i}) - scale("${e}", ${n}))`;
}
function PE({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: o, scale: a, stack: s, offset: u, defaultRef: l, bandPosition: c }) {
  var f;
  if (t) {
    if (se(t)) {
      const d = a == null ? void 0 : a.get("type");
      if (sn(t)) {
        c != null || (c = D6({
          fieldDef: t,
          fieldDef2: n,
          markDef: i,
          config: r
        }));
        const { bin: h, timeUnit: p, type: g } = t;
        if (ze(h) || c && p && g === Ju)
          return s != null && s.impute ? ts(t, o, { binSuffix: "mid" }, { offset: u }) : c && !wt(d) ? Xp({ scaleName: o, fieldOrDatumDef: t, bandPosition: c, offset: u }) : ts(t, o, ld(t, e) ? { binSuffix: "range" } : {}, {
            offset: u
          });
        if (_t(h)) {
          if (q(n))
            return Xp({
              scaleName: o,
              fieldOrDatumDef: t,
              fieldOrDatumDef2: n,
              bandPosition: c,
              offset: u
            });
          U(n6(e === Ge ? Bi : Cr));
        }
      }
      return ts(
        t,
        o,
        wt(d) ? { binSuffix: "range" } : {},
        {
          offset: u,
          band: d === "band" ? (f = c != null ? c : t.bandPosition) != null ? f : 0.5 : void 0
        }
      );
    } else if (Ri(t)) {
      const d = t.value, h = u ? { offset: u } : {};
      return { ...Uc(e, d), ...h };
    }
  }
  return fe(l) && (l = l()), l && {
    ...l,
    ...u ? { offset: u } : {}
  };
}
function Uc(e, t) {
  return me(["x", "x2"], e) && t === "width" ? { field: { group: "width" } } : me(["y", "y2"], e) && t === "height" ? { field: { group: "height" } } : je(t);
}
function Es(e) {
  return e && e !== "number" && e !== "time";
}
function k6(e, t, n) {
  return `${e}(${t}${n ? `, ${Pe(n)}` : ""})`;
}
const sae = " \u2013 ";
function zE({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: o }) {
  var u, l;
  if (Es(n))
    return ki({
      fieldOrDatumDef: e,
      format: t,
      formatType: n,
      expr: i,
      config: o
    });
  const a = C6(e, i, r), s = Zu(e);
  if (t === void 0 && n === void 0 && o.customFormatTypes) {
    if (s === "quantitative") {
      if (r && o.normalizedNumberFormatType)
        return ki({
          fieldOrDatumDef: e,
          format: o.normalizedNumberFormat,
          formatType: o.normalizedNumberFormatType,
          expr: i,
          config: o
        });
      if (o.numberFormatType)
        return ki({
          fieldOrDatumDef: e,
          format: o.numberFormat,
          formatType: o.numberFormatType,
          expr: i,
          config: o
        });
    }
    if (s === "temporal" && o.timeFormatType && q(e) && e.timeUnit === void 0)
      return ki({
        fieldOrDatumDef: e,
        format: o.timeFormat,
        formatType: o.timeFormatType,
        expr: i,
        config: o
      });
  }
  if (tl(e)) {
    const c = lae({
      field: a,
      timeUnit: q(e) ? (u = vt(e.timeUnit)) == null ? void 0 : u.unit : void 0,
      format: t,
      formatType: o.timeFormatType,
      rawTimeFormat: o.timeFormat,
      isUTCScale: js(e) && ((l = e.scale) == null ? void 0 : l.type) === xn.UTC
    });
    return c ? { signal: c } : void 0;
  }
  if (t = Lv({ type: s, specifiedFormat: t, config: o, normalizeStack: r }), q(e) && ze(e.bin)) {
    const c = H(e, { expr: i, binSuffix: "end" });
    return {
      signal: ad(a, c, t, n, o)
    };
  } else
    return t || Zu(e) === "quantitative" ? {
      signal: `${T6(a, t)}`
    } : { signal: `isValid(${a}) ? ${a} : ""+${a}` };
}
function C6(e, t, n) {
  return q(e) ? n ? `${H(e, { expr: t, suffix: "end" })}-${H(e, {
    expr: t,
    suffix: "start"
  })}` : H(e, { expr: t }) : oae(e);
}
function ki({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: o, field: a }) {
  if (a != null || (a = C6(e, i, r)), a !== "datum.value" && q(e) && ze(e.bin)) {
    const s = H(e, { expr: i, binSuffix: "end" });
    return {
      signal: ad(a, s, t, n, o)
    };
  }
  return { signal: k6(n, a, t) };
}
function F6(e, t, n, i, r, o) {
  var a;
  if (!(Y(i) && Es(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && Zu(e) === "quantitative" && (r.normalizedNumberFormatType && el(e) && e.stack === "normalize" || r.numberFormatType))) {
    if (el(e) && e.stack === "normalize" && r.normalizedNumberFormat)
      return Lv({
        type: "quantitative",
        config: r,
        normalizeStack: !0
      });
    if (tl(e)) {
      const s = q(e) ? (a = vt(e.timeUnit)) == null ? void 0 : a.unit : void 0;
      return s === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : uae({ specifiedFormat: n, timeUnit: s, config: r, omitTimeFormatConfig: o });
    }
    return Lv({ type: t, specifiedFormat: n, config: r });
  }
}
function M6(e, t, n) {
  var i;
  if (e && (Z(e) || e === "number" || e === "time"))
    return e;
  if (tl(t) && n !== "time" && n !== "utc")
    return q(t) && ((i = vt(t == null ? void 0 : t.timeUnit)) == null ? void 0 : i.utc) ? "utc" : "time";
}
function Lv({ type: e, specifiedFormat: t, config: n, normalizeStack: i }) {
  if (Y(t))
    return t;
  if (e === xs)
    return i ? n.normalizedNumberFormat : n.numberFormat;
}
function uae({ specifiedFormat: e, timeUnit: t, config: n, omitTimeFormatConfig: i }) {
  return e || (t ? {
    signal: c6(t)
  } : i ? void 0 : n.timeFormat);
}
function T6(e, t) {
  return `format(${e}, "${t || ""}")`;
}
function zk(e, t, n, i) {
  var r;
  return Es(n) ? k6(n, e, t) : T6(e, (r = Y(t) ? t : void 0) != null ? r : i.numberFormat);
}
function ad(e, t, n, i, r) {
  if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType)
    return ad(e, t, r.numberFormat, r.numberFormatType, r);
  const o = zk(e, n, i, r), a = zk(t, n, i, r);
  return `${FE(e, !1)} ? "null" : ${o} + "${sae}" + ${a}`;
}
function lae({ field: e, timeUnit: t, format: n, formatType: i, rawTimeFormat: r, isUTCScale: o }) {
  return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = Y(n) ? n : r, `${o ? "utc" : "time"}Format(${e}, '${n}')`) : voe(t, e, o);
}
const Bm = "min", cae = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function Bk(e) {
  return e in cae;
}
function O6(e) {
  return !!(e != null && e.encoding);
}
function cr(e) {
  return e && (e.op === "count" || !!e.field);
}
function N6(e) {
  return e && P(e);
}
function sd(e) {
  return "row" in e || "column" in e;
}
function BE(e) {
  return !!e && "header" in e;
}
function jm(e) {
  return "facet" in e;
}
function fae(e) {
  return e.param;
}
function dae(e) {
  return e && !Y(e) && "repeat" in e;
}
function jk(e) {
  const { field: t, timeUnit: n, bin: i, aggregate: r } = e;
  return {
    ...n ? { timeUnit: n } : {},
    ...i ? { bin: i } : {},
    ...r ? { aggregate: r } : {},
    field: t
  };
}
function jE(e) {
  return "sort" in e;
}
function D6({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) {
  if (se(e) && e.bandPosition !== void 0)
    return e.bandPosition;
  if (q(e)) {
    const { timeUnit: r, bin: o } = e;
    if (r && !t)
      return RE(n.type) ? 0 : so("timeUnitBandPosition", n, i);
    if (ze(o))
      return 0.5;
  }
}
function R6({ channel: e, fieldDef: t, fieldDef2: n, markDef: i, config: r, scaleType: o, useVlSizeChannel: a }) {
  var l, c, f;
  const s = Cn(e), u = Me(a ? "size" : s, i, r, {
    vgChannel: s
  });
  if (u !== void 0)
    return u;
  if (q(t)) {
    const { timeUnit: d, bin: h } = t;
    if (d && !n)
      return { band: so("timeUnitBandSize", i, r) };
    if (ze(h) && !wt(o))
      return { band: 1 };
  }
  if (RE(i.type))
    return o ? wt(o) ? ((l = r[i.type]) == null ? void 0 : l.discreteBandSize) || { band: 1 } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize;
}
function L6(e, t, n, i) {
  return ze(e.bin) || e.timeUnit && sn(e) && e.type === "temporal" ? D6({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) !== void 0 : !1;
}
function I6(e) {
  return e && !!e.sort && !e.field;
}
function Um(e) {
  return e && "condition" in e;
}
function qm(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !P(t) && q(t);
}
function ud(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !P(t) && se(t);
}
function hae(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && (P(t) || Ri(t));
}
function q(e) {
  return e && (!!e.field || e.aggregate === "count");
}
function Zu(e) {
  return e == null ? void 0 : e.type;
}
function Nr(e) {
  return e && "datum" in e;
}
function Po(e) {
  return sn(e) && !Kp(e) || Vp(e);
}
function Uk(e) {
  return sn(e) && e.type === "quantitative" && !e.bin || Vp(e);
}
function Vp(e) {
  return Nr(e) && Oe(e.datum);
}
function se(e) {
  return q(e) || Nr(e);
}
function sn(e) {
  return e && ("field" in e || e.aggregate === "count") && "type" in e;
}
function Ri(e) {
  return e && "value" in e && "value" in e;
}
function js(e) {
  return e && ("scale" in e || "sort" in e);
}
function el(e) {
  return e && ("axis" in e || "stack" in e || "impute" in e);
}
function P6(e) {
  return e && "legend" in e;
}
function z6(e) {
  return e && ("format" in e || "formatType" in e);
}
function pae(e) {
  return bn(e, ["legend", "axis", "header", "scale"]);
}
function gae(e) {
  return "op" in e;
}
function H(e, t = {}) {
  var a, s, u;
  let n = e.field;
  const i = t.prefix;
  let r = t.suffix, o = "";
  if (yae(e))
    n = $R("count");
  else {
    let l;
    if (!t.nofn)
      if (gae(e))
        l = e.op;
      else {
        const { bin: c, aggregate: f, timeUnit: d } = e;
        ze(c) ? (l = UR(c), r = ((a = t.binSuffix) != null ? a : "") + ((s = t.suffix) != null ? s : "")) : f ? xa(f) ? (o = `["${n}"]`, n = `argmax_${f.argmax}`) : ao(f) ? (o = `["${n}"]`, n = `argmin_${f.argmin}`) : l = String(f) : d && !Bs(d) && (l = boe(d), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + ((u = t.suffix) != null ? u : ""));
      }
    l && (n = n ? `${l}_${n}` : l);
  }
  return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? uE(n) : t.expr ? _R(n, t.expr) + o : ri(n) + o;
}
function Kp(e) {
  switch (e.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return !0;
    case "quantitative":
      return q(e) && !!e.bin;
    case "temporal":
      return !1;
  }
  throw new Error(QR(e.type));
}
function mae(e) {
  var t;
  return js(e) && Qu((t = e.scale) == null ? void 0 : t.type);
}
function yae(e) {
  return e.aggregate === "count";
}
function vae(e, t) {
  var a;
  const { field: n, bin: i, timeUnit: r, aggregate: o } = e;
  if (o === "count")
    return t.countTitle;
  if (ze(i))
    return `${n} (binned)`;
  if (r && !Bs(r)) {
    const s = (a = vt(r)) == null ? void 0 : a.unit;
    if (s)
      return `${n} (${Rm(s).join("-")})`;
  } else if (o)
    return xa(o) ? `${n} for max ${o.argmax}` : ao(o) ? `${n} for min ${o.argmin}` : `${td(o)} of ${n}`;
  return n;
}
function bae(e) {
  const { aggregate: t, bin: n, timeUnit: i, field: r } = e;
  if (xa(t))
    return `${r} for argmax(${t.argmax})`;
  if (ao(t))
    return `${r} for argmin(${t.argmin})`;
  const o = i && !Bs(i) ? vt(i) : void 0, a = t || (o == null ? void 0 : o.unit) || (o == null ? void 0 : o.maxbins) && "timeunit" || ze(n) && "bin";
  return a ? `${a.toUpperCase()}(${r})` : r;
}
const B6 = (e, t) => {
  switch (t.fieldTitle) {
    case "plain":
      return e.field;
    case "functional":
      return bae(e);
    default:
      return vae(e, t);
  }
};
let j6 = B6;
function U6(e) {
  j6 = e;
}
function xae() {
  U6(B6);
}
function Eu(e, t, { allowDisabling: n, includeDefault: i = !0 }) {
  var s, u;
  const r = (s = UE(e)) == null ? void 0 : s.title;
  if (!q(e))
    return r != null ? r : e.title;
  const o = e, a = i ? qE(o, t) : void 0;
  return n ? tt(r, o.title, a) : (u = r != null ? r : o.title) != null ? u : a;
}
function UE(e) {
  if (el(e) && e.axis)
    return e.axis;
  if (P6(e) && e.legend)
    return e.legend;
  if (BE(e) && e.header)
    return e.header;
}
function qE(e, t) {
  return j6(e, t);
}
function Jp(e) {
  var t;
  if (z6(e)) {
    const { format: n, formatType: i } = e;
    return { format: n, formatType: i };
  } else {
    const n = (t = UE(e)) != null ? t : {}, { format: i, formatType: r } = n;
    return { format: i, formatType: r };
  }
}
function wae(e, t) {
  var o;
  switch (t) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (jE(e) && P(e.sort))
    return "ordinal";
  const { aggregate: n, bin: i, timeUnit: r } = e;
  if (r)
    return "temporal";
  if (i || n && !xa(n) && !ao(n))
    return "quantitative";
  if (js(e) && ((o = e.scale) == null ? void 0 : o.type))
    switch (Dv[e.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  return "nominal";
}
function xr(e) {
  if (q(e))
    return e;
  if (qm(e))
    return e.condition;
}
function st(e) {
  if (se(e))
    return e;
  if (ud(e))
    return e.condition;
}
function q6(e, t, n, i = {}) {
  if (Y(e) || Oe(e) || ua(e)) {
    const r = Y(e) ? "string" : Oe(e) ? "number" : "boolean";
    return U(wre(t, r, e)), { value: e };
  }
  return se(e) ? Qp(e, t, n, i) : ud(e) ? {
    ...e,
    condition: Qp(e.condition, t, n, i)
  } : e;
}
function Qp(e, t, n, i) {
  if (z6(e)) {
    const { format: r, formatType: o, ...a } = e;
    if (Es(o) && !n.customFormatTypes)
      return U(Dk(t)), Qp(a, t, n, i);
  } else {
    const r = el(e) ? "axis" : P6(e) ? "legend" : BE(e) ? "header" : null;
    if (r && e[r]) {
      const { format: o, formatType: a, ...s } = e[r];
      if (Es(a) && !n.customFormatTypes)
        return U(Dk(t)), Qp({ ...e, [r]: s }, t, n, i);
    }
  }
  return q(e) ? WE(e, t, i) : Eae(e);
}
function Eae(e) {
  let t = e.type;
  if (t)
    return e;
  const { datum: n } = e;
  return t = Oe(n) ? "quantitative" : Y(n) ? "nominal" : zs(n) ? "temporal" : void 0, { ...e, type: t };
}
function WE(e, t, { compositeMark: n = !1 } = {}) {
  const { aggregate: i, timeUnit: r, bin: o, field: a } = e, s = { ...e };
  if (!n && i && !mE(i) && !xa(i) && !ao(i) && (U(_re(i)), delete s.aggregate), r && (s.timeUnit = vt(r)), a && (s.field = `${a}`), ze(o) && (s.bin = Wm(o, t)), _t(o) && !xt(t) && U(noe(t)), sn(s)) {
    const { type: u } = s, l = koe(u);
    u !== l && (s.type = l), u !== "quantitative" && jR(i) && (U(Ere(u, i)), s.type = "quantitative");
  } else if (!DR(t)) {
    const u = wae(s, t);
    s.type = u;
  }
  if (sn(s)) {
    const { compatible: u, warning: l } = _ae(s, t) || {};
    u === !1 && U(l);
  }
  if (jE(s) && Y(s.sort)) {
    const { sort: u } = s;
    if (Bk(u))
      return {
        ...s,
        sort: { encoding: u }
      };
    const l = u.substr(1);
    if (u.charAt(0) === "-" && Bk(l))
      return {
        ...s,
        sort: { encoding: l, order: "descending" }
      };
  }
  if (BE(s)) {
    const { header: u } = s;
    if (u) {
      const { orient: l, ...c } = u;
      if (l)
        return {
          ...s,
          header: {
            ...c,
            labelOrient: u.labelOrient || l,
            titleOrient: u.titleOrient || l
          }
        };
    }
  }
  return s;
}
function Wm(e, t) {
  return ua(e) ? { maxbins: Ak(t) } : e === "binned" ? {
    binned: !0
  } : !e.maxbins && !e.step ? { ...e, maxbins: Ak(t) } : e;
}
const tu = { compatible: !0 };
function _ae(e, t) {
  const n = e.type;
  if (n === "geojson" && t !== "shape")
    return {
      compatible: !1,
      warning: `Channel ${t} should not be used with a geojson data.`
    };
  switch (t) {
    case Zr:
    case eo:
    case $m:
      return Kp(e) ? tu : {
        compatible: !1,
        warning: Cre(t)
      };
    case Ge:
    case bt:
    case ga:
    case Sl:
    case $n:
    case Fr:
    case Mr:
    case nd:
    case id:
    case km:
    case vs:
    case Cm:
    case Fm:
    case Ls:
    case si:
    case ji:
    case Mm:
      return tu;
    case qi:
    case oi:
    case Ui:
    case Wi:
      return n !== xs ? {
        compatible: !1,
        warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
      } : tu;
    case go:
    case ma:
    case ya:
    case va:
    case po:
    case ho:
    case fo:
    case Bi:
    case Cr:
      return n === "nominal" && !e.sort ? {
        compatible: !1,
        warning: `Channel ${t} should not be used with an unsorted discrete field.`
      } : tu;
    case kn:
    case ba:
      return !Kp(e) && !mae(e) ? {
        compatible: !1,
        warning: Fre(t)
      } : tu;
    case Vu:
      return e.type === "nominal" && !("sort" in e) ? {
        compatible: !1,
        warning: "Channel order is inappropriate for nominal field, which has no inherent order."
      } : tu;
  }
}
function tl(e) {
  const { formatType: t } = Jp(e);
  return t === "time" || !t && Sae(e);
}
function Sae(e) {
  return e && (e.type === "temporal" || q(e) && !!e.timeUnit);
}
function Gm(e, { timeUnit: t, type: n, wrapTime: i, undefinedIfExprNotRequired: r }) {
  var u;
  const o = t && ((u = vt(t)) == null ? void 0 : u.unit);
  let a = o || n === "temporal", s;
  return rd(e) ? s = e.expr : Z(e) ? s = e.signal : zs(e) ? (a = !0, s = bs(e)) : (Y(e) || Oe(e)) && a && (s = `datetime(${Pe(e)})`, poe(o) && (Oe(e) && e < 1e4 || Y(e) && isNaN(Date.parse(e))) && (s = bs({ [o]: e }))), s ? i && a ? `time(${s})` : s : r ? void 0 : Pe(e);
}
function W6(e, t) {
  const { type: n } = e;
  return t.map((i) => {
    const r = q(e) && !Bs(e.timeUnit) ? e.timeUnit : void 0, o = Gm(i, {
      timeUnit: r,
      type: n,
      undefinedIfExprNotRequired: !0
    });
    return o !== void 0 ? { signal: o } : i;
  });
}
function ld(e, t) {
  return ze(e.bin) ? mo(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
}
const qk = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function cd(e) {
  return e == null ? void 0 : e.condition;
}
const G6 = ["domain", "grid", "labels", "ticks", "title"], Aae = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
}, H6 = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
}, $ae = {
  ...H6,
  style: 1,
  labelExpr: 1,
  encoding: 1
};
function Wk(e) {
  return !!$ae[e];
}
const kae = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
}, Y6 = B(kae);
function yo(e) {
  return "mark" in e;
}
class Hm {
  constructor(t, n) {
    this.name = t, this.run = n;
  }
  hasMatchingType(t) {
    return yo(t) ? nae(t.mark) === this.name : !1;
  }
}
function ns(e, t) {
  const n = e && e[t];
  return n ? P(n) ? ms(n, (i) => !!i.field) : q(n) || qm(n) : !1;
}
function X6(e, t) {
  const n = e && e[t];
  return n ? P(n) ? ms(n, (i) => !!i.field) : q(n) || Nr(n) || ud(n) : !1;
}
function Iv(e, t) {
  if (xt(t)) {
    const n = e[t];
    if ((q(n) || Nr(n)) && (g6(n.type) || q(n) && n.timeUnit)) {
      const i = dE(t);
      return X6(e, i);
    }
  }
  return !1;
}
function GE(e) {
  return ms(Cie, (t) => {
    if (ns(e, t)) {
      const n = e[t];
      if (P(n))
        return ms(n, (i) => !!i.aggregate);
      {
        const i = xr(n);
        return i && !!i.aggregate;
      }
    }
    return !1;
  });
}
function V6(e, t) {
  const n = [], i = [], r = [], o = [], a = {};
  return HE(e, (s, u) => {
    if (q(s)) {
      const { field: l, aggregate: c, bin: f, timeUnit: d, ...h } = s;
      if (c || d || f) {
        const p = UE(s), g = p == null ? void 0 : p.title;
        let m = H(s, { forAs: !0 });
        const y = {
          ...g ? [] : { title: Eu(s, t, { allowDisabling: !0 }) },
          ...h,
          field: m
        };
        if (c) {
          let v;
          if (xa(c) ? (v = "argmax", m = H({ op: "argmax", field: c.argmax }, { forAs: !0 }), y.field = `${m}.${l}`) : ao(c) ? (v = "argmin", m = H({ op: "argmin", field: c.argmin }, { forAs: !0 }), y.field = `${m}.${l}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (v = c), v) {
            const b = {
              op: v,
              as: m
            };
            l && (b.field = l), o.push(b);
          }
        } else if (n.push(m), sn(s) && ze(f)) {
          if (i.push({ bin: f, field: l, as: m }), n.push(H(s, { binSuffix: "end" })), ld(s, u) && n.push(H(s, { binSuffix: "range" })), xt(u)) {
            const v = {
              field: `${m}_end`
            };
            a[`${u}2`] = v;
          }
          y.bin = "binned", DR(u) || (y.type = xs);
        } else if (d && !Bs(d)) {
          r.push({
            timeUnit: d,
            field: l,
            as: m
          });
          const v = sn(s) && s.type !== Ju && "time";
          v && (u === nd || u === vs ? y.formatType = v : Iie(u) ? y.legend = {
            formatType: v,
            ...y.legend
          } : xt(u) && (y.axis = {
            formatType: v,
            ...y.axis
          }));
        }
        a[u] = y;
      } else
        n.push(l), a[u] = e[u];
    } else
      a[u] = e[u];
  }), {
    bins: i,
    timeUnits: r,
    aggregate: o,
    groupby: n,
    encoding: a
  };
}
function Cae(e, t, n) {
  const i = zie(t, n);
  if (i) {
    if (i === "binned") {
      const r = e[t === Bi ? Ge : bt];
      return !!(q(r) && q(e[t]) && _t(r.bin));
    }
  } else
    return !1;
  return !0;
}
function Fae(e, t, n, i) {
  const r = {};
  for (const o of B(e))
    NR(o) || U(kre(o));
  for (let o of Nie) {
    if (!e[o])
      continue;
    const a = e[o];
    if (Al(o)) {
      const s = LR(o), u = r[s];
      if (q(u)) {
        if ($oe(u.type) && q(a) && !u.timeUnit) {
          U(bre(s));
          continue;
        }
      } else
        o = s, U(xre(s));
    }
    if (o === "angle" && t === "arc" && !e.theta && (U(vre), o = si), !Cae(e, o, t)) {
      U(Dm(o, t));
      continue;
    }
    if (o === po && t === "line") {
      const s = xr(e[o]);
      if (s != null && s.aggregate) {
        U(Are);
        continue;
      }
    }
    if (o === $n && (n ? "fill" in e : "stroke" in e)) {
      U(ZR("encoding", { fill: "fill" in e, stroke: "stroke" in e }));
      continue;
    }
    if (o === id || o === Vu && !P(a) && !Ri(a) || o === vs && P(a)) {
      if (a) {
        if (o === Vu) {
          const s = e[o];
          if (I6(s)) {
            r[o] = s;
            continue;
          }
        }
        r[o] = X(a).reduce((s, u) => (q(u) ? s.push(WE(u, o)) : U(Nv(u, o)), s), []);
      }
    } else {
      if (o === vs && a === null)
        r[o] = null;
      else if (!q(a) && !Nr(a) && !Ri(a) && !Um(a) && !Z(a)) {
        U(Nv(a, o));
        continue;
      }
      r[o] = q6(a, o, i);
    }
  }
  return r;
}
function Ym(e, t) {
  const n = {};
  for (const i of B(e)) {
    const r = q6(e[i], i, t, { compositeMark: !0 });
    n[i] = r;
  }
  return n;
}
function Mae(e) {
  const t = [];
  for (const n of B(e))
    if (ns(e, n)) {
      const i = e[n], r = X(i);
      for (const o of r)
        q(o) ? t.push(o) : qm(o) && t.push(o.condition);
    }
  return t;
}
function HE(e, t, n) {
  if (!!e)
    for (const i of B(e)) {
      const r = e[i];
      if (P(r))
        for (const o of r)
          t.call(n, o, i);
      else
        t.call(n, r, i);
    }
}
function Tae(e, t, n, i) {
  return e ? B(e).reduce((r, o) => {
    const a = e[o];
    return P(a) ? a.reduce((s, u) => t.call(i, s, u, o), r) : t.call(i, r, a, o);
  }, n) : n;
}
function K6(e, t) {
  return B(t).reduce((n, i) => {
    switch (i) {
      case Ge:
      case bt:
      case Cm:
      case Mm:
      case Fm:
      case Bi:
      case Cr:
      case ga:
      case Sl:
      case si:
      case ho:
      case ji:
      case fo:
      case Ui:
      case qi:
      case Wi:
      case oi:
      case nd:
      case kn:
      case Ls:
      case vs:
        return n;
      case Vu:
        if (e === "line" || e === "trail")
          return n;
      case id:
      case km: {
        const r = t[i];
        if (P(r) || q(r))
          for (const o of X(r))
            o.aggregate || n.push(H(o, {}));
        return n;
      }
      case po:
        if (e === "trail")
          return n;
      case $n:
      case Fr:
      case Mr:
      case go:
      case ma:
      case ya:
      case ba:
      case va: {
        const r = xr(t[i]);
        return r && !r.aggregate && n.push(H(r, {})), n;
      }
    }
  }, []);
}
function Oae(e) {
  const { tooltip: t, ...n } = e;
  if (!t)
    return { filteredEncoding: n };
  let i, r;
  if (P(t)) {
    for (const o of t)
      o.aggregate ? (i || (i = []), i.push(o)) : (r || (r = []), r.push(o));
    i && (n.tooltip = i);
  } else
    t.aggregate ? n.tooltip = t : r = t;
  return P(r) && r.length === 1 && (r = r[0]), { customTooltipWithoutAggregatedField: r, filteredEncoding: n };
}
function Pv(e, t, n, i = !0) {
  if ("tooltip" in n)
    return { tooltip: n.tooltip };
  const r = e.map(({ fieldPrefix: a, titlePrefix: s }) => {
    const u = i ? ` of ${YE(t)}` : "";
    return {
      field: a + t.field,
      type: t.type,
      title: Z(s) ? { signal: `${s}"${escape(u)}"` } : s + u
    };
  }), o = Mae(n).map(pae);
  return {
    tooltip: [
      ...r,
      ...or(o, ge)
    ]
  };
}
function YE(e) {
  const { title: t, field: n } = e;
  return tt(t, n);
}
function XE(e, t, n, i, r) {
  const { scale: o, axis: a } = n;
  return ({ partName: s, mark: u, positionPrefix: l, endPositionPrefix: c = void 0, extraEncoding: f = {} }) => {
    const d = YE(n);
    return J6(e, s, r, {
      mark: u,
      encoding: {
        [t]: {
          field: `${l}_${n.field}`,
          type: n.type,
          ...d !== void 0 ? { title: d } : {},
          ...o !== void 0 ? { scale: o } : {},
          ...a !== void 0 ? { axis: a } : {}
        },
        ...Y(c) ? {
          [`${t}2`]: {
            field: `${c}_${n.field}`
          }
        } : {},
        ...i,
        ...f
      }
    });
  };
}
function J6(e, t, n, i) {
  const { clip: r, color: o, opacity: a } = e, s = e.type;
  return e[t] || e[t] === void 0 && n[t] ? [
    {
      ...i,
      mark: {
        ...n[t],
        ...r ? { clip: r } : {},
        ...o ? { color: o } : {},
        ...a ? { opacity: a } : {},
        ...br(i.mark) ? i.mark : { type: i.mark },
        style: `${s}-${String(t)}`,
        ...ua(e[t]) ? {} : e[t]
      }
    }
  ] : [];
}
function Q6(e, t, n) {
  const { encoding: i } = e, r = t === "vertical" ? "y" : "x", o = i[r], a = i[`${r}2`], s = i[`${r}Error`], u = i[`${r}Error2`];
  return {
    continuousAxisChannelDef: qd(o, n),
    continuousAxisChannelDef2: qd(a, n),
    continuousAxisChannelDefError: qd(s, n),
    continuousAxisChannelDefError2: qd(u, n),
    continuousAxis: r
  };
}
function qd(e, t) {
  if (e != null && e.aggregate) {
    const { aggregate: n, ...i } = e;
    return n !== t && U(toe(n, t)), i;
  } else
    return e;
}
function Z6(e, t) {
  const { mark: n, encoding: i } = e, { x: r, y: o } = i;
  if (br(n) && n.orient)
    return n.orient;
  if (Po(r)) {
    if (Po(o)) {
      const a = q(r) && r.aggregate, s = q(o) && o.aggregate;
      if (!a && s === t)
        return "vertical";
      if (!s && a === t)
        return "horizontal";
      if (a === t && s === t)
        throw new Error("Both x and y cannot have aggregate");
      return tl(o) && !tl(r) ? "horizontal" : "vertical";
    }
    return "horizontal";
  } else {
    if (Po(o))
      return "vertical";
    throw new Error(`Need a valid continuous axis for ${t}s`);
  }
}
const Zp = "boxplot", Nae = ["box", "median", "outliers", "rule", "ticks"], Dae = new Hm(Zp, tL);
function eL(e) {
  return Oe(e) ? "tukey" : e;
}
function tL(e, { config: t }) {
  var Xe, Tn;
  e = {
    ...e,
    encoding: Ym(e.encoding, t)
  };
  const { mark: n, encoding: i, params: r, projection: o, ...a } = e, s = br(n) ? n : { type: n };
  r && U(JR("boxplot"));
  const u = (Xe = s.extent) != null ? Xe : t.boxplot.extent, l = Me(
    "size",
    s,
    t
  ), c = s.invalid, f = eL(u), { bins: d, timeUnits: h, transform: p, continuousAxisChannelDef: g, continuousAxis: m, groupby: y, aggregate: v, encodingWithoutContinuousAxis: b, ticksOrient: x, boxOrient: E, customTooltipWithoutAggregatedField: _ } = Rae(e, u, t), { color: w, size: S, ...C } = b, $ = (Hi) => XE(s, m, g, Hi, t.boxplot), A = $(C), M = $(b), F = $({ ...C, ...S ? { size: S } : {} }), O = Pv([
    { fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: f === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], g, b), k = { type: "tick", color: "black", opacity: 1, orient: x, invalid: c, aria: !1 }, T = f === "min-max" ? O : Pv([
    { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
    { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
  ], g, b), N = [
    ...A({
      partName: "rule",
      mark: { type: "rule", invalid: c, aria: !1 },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: T
    }),
    ...A({
      partName: "rule",
      mark: { type: "rule", invalid: c, aria: !1 },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: T
    }),
    ...A({
      partName: "ticks",
      mark: k,
      positionPrefix: "lower_whisker",
      extraEncoding: T
    }),
    ...A({
      partName: "ticks",
      mark: k,
      positionPrefix: "upper_whisker",
      extraEncoding: T
    })
  ], L = [
    ...f !== "tukey" ? N : [],
    ...M({
      partName: "box",
      mark: {
        type: "bar",
        ...l ? { size: l } : {},
        orient: E,
        invalid: c,
        ariaRoleDescription: "box"
      },
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: O
    }),
    ...F({
      partName: "median",
      mark: {
        type: "tick",
        invalid: c,
        ...K(t.boxplot.median) && t.boxplot.median.color ? { color: t.boxplot.median.color } : {},
        ...l ? { size: l } : {},
        orient: x,
        aria: !1
      },
      positionPrefix: "mid_box",
      extraEncoding: O
    })
  ];
  if (f === "min-max")
    return {
      ...a,
      transform: ((Tn = a.transform) != null ? Tn : []).concat(p),
      layer: L
    };
  const z = `datum["lower_box_${g.field}"]`, J = `datum["upper_box_${g.field}"]`, le = `(${J} - ${z})`, Ee = `${z} - ${u} * ${le}`, _e = `${J} + ${u} * ${le}`, Ue = `datum["${g.field}"]`, ye = {
    joinaggregate: nL(g.field),
    groupby: y
  }, Mt = {
    transform: [
      {
        filter: `(${Ee} <= ${Ue}) && (${Ue} <= ${_e})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: g.field,
            as: `lower_whisker_${g.field}`
          },
          {
            op: "max",
            field: g.field,
            as: `upper_whisker_${g.field}`
          },
          {
            op: "min",
            field: `lower_box_${g.field}`,
            as: `lower_box_${g.field}`
          },
          {
            op: "max",
            field: `upper_box_${g.field}`,
            as: `upper_box_${g.field}`
          },
          ...v
        ],
        groupby: y
      }
    ],
    layer: N
  }, { tooltip: Gi, ...Ht } = C, { scale: V, axis: ue } = g, de = YE(g), j = bn(ue, ["title"]), He = J6(s, "outliers", t.boxplot, {
    transform: [{ filter: `(${Ue} < ${Ee}) || (${Ue} > ${_e})` }],
    mark: "point",
    encoding: {
      [m]: {
        field: g.field,
        type: g.type,
        ...de !== void 0 ? { title: de } : {},
        ...V !== void 0 ? { scale: V } : {},
        ...De(j) ? {} : { axis: j }
      },
      ...Ht,
      ...w ? { color: w } : {},
      ..._ ? { tooltip: _ } : {}
    }
  })[0];
  let ve;
  const rt = [...d, ...h, ye];
  return He ? ve = {
    transform: rt,
    layer: [He, Mt]
  } : (ve = Mt, ve.transform.unshift(...rt)), {
    ...a,
    layer: [
      ve,
      {
        transform: p,
        layer: L
      }
    ]
  };
}
function nL(e) {
  return [
    {
      op: "q1",
      field: e,
      as: `lower_box_${e}`
    },
    {
      op: "q3",
      field: e,
      as: `upper_box_${e}`
    }
  ];
}
function Rae(e, t, n) {
  const i = Z6(e, Zp), { continuousAxisChannelDef: r, continuousAxis: o } = Q6(e, i, Zp), a = r.field, s = eL(t), u = [
    ...nL(a),
    {
      op: "median",
      field: a,
      as: `mid_box_${a}`
    },
    {
      op: "min",
      field: a,
      as: (s === "min-max" ? "lower_whisker_" : "min_") + a
    },
    {
      op: "max",
      field: a,
      as: (s === "min-max" ? "upper_whisker_" : "max_") + a
    }
  ], l = s === "min-max" || s === "tukey" ? [] : [
    {
      calculate: `datum["upper_box_${a}"] - datum["lower_box_${a}"]`,
      as: `iqr_${a}`
    },
    {
      calculate: `min(datum["upper_box_${a}"] + datum["iqr_${a}"] * ${t}, datum["max_${a}"])`,
      as: `upper_whisker_${a}`
    },
    {
      calculate: `max(datum["lower_box_${a}"] - datum["iqr_${a}"] * ${t}, datum["min_${a}"])`,
      as: `lower_whisker_${a}`
    }
  ], { [o]: c, ...f } = e.encoding, { customTooltipWithoutAggregatedField: d, filteredEncoding: h } = Oae(f), { bins: p, timeUnits: g, aggregate: m, groupby: y, encoding: v } = V6(h, n), b = i === "vertical" ? "horizontal" : "vertical", x = i, E = [
    ...p,
    ...g,
    {
      aggregate: [...m, ...u],
      groupby: y
    },
    ...l
  ];
  return {
    bins: p,
    timeUnits: g,
    transform: E,
    groupby: y,
    aggregate: m,
    continuousAxisChannelDef: r,
    continuousAxis: o,
    encodingWithoutContinuousAxis: v,
    ticksOrient: b,
    boxOrient: x,
    customTooltipWithoutAggregatedField: d
  };
}
const VE = "errorbar", Lae = ["ticks", "rule"], Iae = new Hm(VE, iL);
function iL(e, { config: t }) {
  e = {
    ...e,
    encoding: Ym(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: o, ticksOrient: a, markDef: s, outerSpec: u, tooltipEncoding: l } = rL(e, VE, t);
  delete o.size;
  const c = XE(s, r, i, o, t.errorbar), f = s.thickness, d = s.size, h = {
    type: "tick",
    orient: a,
    aria: !1,
    ...f !== void 0 ? { thickness: f } : {},
    ...d !== void 0 ? { size: d } : {}
  }, p = [
    ...c({
      partName: "ticks",
      mark: h,
      positionPrefix: "lower",
      extraEncoding: l
    }),
    ...c({
      partName: "ticks",
      mark: h,
      positionPrefix: "upper",
      extraEncoding: l
    }),
    ...c({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar",
        ...f !== void 0 ? { size: f } : {}
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: l
    })
  ];
  return {
    ...u,
    transform: n,
    ...p.length > 1 ? { layer: p } : { ...p[0] }
  };
}
function Pae(e, t) {
  const { encoding: n } = e;
  if (zae(n))
    return {
      orient: Z6(e, t),
      inputType: "raw"
    };
  const i = Bae(n), r = jae(n), o = n.x, a = n.y;
  if (i) {
    if (r)
      throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
    const s = n.x2, u = n.y2;
    if (se(s) && se(u))
      throw new Error(`${t} cannot have both x2 and y2`);
    if (se(s)) {
      if (Po(o))
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      throw new Error(`Both x and x2 have to be quantitative in ${t}`);
    } else if (se(u)) {
      if (Po(a))
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      throw new Error(`Both y and y2 have to be quantitative in ${t}`);
    }
    throw new Error("No ranged axis");
  } else {
    const s = n.xError, u = n.xError2, l = n.yError, c = n.yError2;
    if (se(u) && !se(s))
      throw new Error(`${t} cannot have xError2 without xError`);
    if (se(c) && !se(l))
      throw new Error(`${t} cannot have yError2 without yError`);
    if (se(s) && se(l))
      throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
    if (se(s)) {
      if (Po(o))
        return { orient: "horizontal", inputType: "aggregated-error" };
      throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
    } else if (se(l)) {
      if (Po(a))
        return { orient: "vertical", inputType: "aggregated-error" };
      throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
    }
    throw new Error("No ranged axis");
  }
}
function zae(e) {
  return (se(e.x) || se(e.y)) && !se(e.x2) && !se(e.y2) && !se(e.xError) && !se(e.xError2) && !se(e.yError) && !se(e.yError2);
}
function Bae(e) {
  return se(e.x2) || se(e.y2);
}
function jae(e) {
  return se(e.xError) || se(e.xError2) || se(e.yError) || se(e.yError2);
}
function rL(e, t, n) {
  var N;
  const { mark: i, encoding: r, params: o, projection: a, ...s } = e, u = br(i) ? i : { type: i };
  o && U(JR(t));
  const { orient: l, inputType: c } = Pae(e, t), { continuousAxisChannelDef: f, continuousAxisChannelDef2: d, continuousAxisChannelDefError: h, continuousAxisChannelDefError2: p, continuousAxis: g } = Q6(e, l, t), { errorBarSpecificAggregate: m, postAggregateCalculates: y, tooltipSummary: v, tooltipTitleWithFieldName: b } = Uae(u, f, d, h, p, c, t, n), { [g]: x, [g === "x" ? "x2" : "y2"]: E, [g === "x" ? "xError" : "yError"]: _, [g === "x" ? "xError2" : "yError2"]: w, ...S } = r, { bins: C, timeUnits: $, aggregate: A, groupby: M, encoding: F } = V6(S, n), O = [...A, ...m], k = c !== "raw" ? [] : M, T = Pv(v, f, F, b);
  return {
    transform: [
      ...(N = s.transform) != null ? N : [],
      ...C,
      ...$,
      ...O.length === 0 ? [] : [{ aggregate: O, groupby: k }],
      ...y
    ],
    groupby: k,
    continuousAxisChannelDef: f,
    continuousAxis: g,
    encodingWithoutContinuousAxis: F,
    ticksOrient: l === "vertical" ? "horizontal" : "vertical",
    markDef: u,
    outerSpec: s,
    tooltipEncoding: T
  };
}
function Uae(e, t, n, i, r, o, a, s) {
  let u = [], l = [];
  const c = t.field;
  let f, d = !1;
  if (o === "raw") {
    const h = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : s.errorbar.center, p = e.extent ? e.extent : h === "mean" ? "stderr" : "iqr";
    if (h === "median" != (p === "iqr") && U(eoe(h, p, a)), p === "stderr" || p === "stdev")
      u = [
        { op: p, field: c, as: `extent_${c}` },
        { op: h, field: c, as: `center_${c}` }
      ], l = [
        {
          calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
          as: `upper_${c}`
        },
        {
          calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
          as: `lower_${c}`
        }
      ], f = [
        { fieldPrefix: "center_", titlePrefix: td(h) },
        { fieldPrefix: "upper_", titlePrefix: Gk(h, p, "+") },
        { fieldPrefix: "lower_", titlePrefix: Gk(h, p, "-") }
      ], d = !0;
    else {
      let g, m, y;
      p === "ci" ? (g = "mean", m = "ci0", y = "ci1") : (g = "median", m = "q1", y = "q3"), u = [
        { op: m, field: c, as: `lower_${c}` },
        { op: y, field: c, as: `upper_${c}` },
        { op: g, field: c, as: `center_${c}` }
      ], f = [
        {
          fieldPrefix: "upper_",
          titlePrefix: Eu({ field: c, aggregate: y, type: "quantitative" }, s, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: Eu({ field: c, aggregate: m, type: "quantitative" }, s, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: Eu({ field: c, aggregate: g, type: "quantitative" }, s, {
            allowDisabling: !1
          })
        }
      ];
    }
  } else {
    (e.center || e.extent) && U(Zre(e.center, e.extent)), o === "aggregated-upper-lower" ? (f = [], l = [
      { calculate: `datum["${n.field}"]`, as: `upper_${c}` },
      { calculate: `datum["${c}"]`, as: `lower_${c}` }
    ]) : o === "aggregated-error" && (f = [{ fieldPrefix: "", titlePrefix: c }], l = [
      {
        calculate: `datum["${c}"] + datum["${i.field}"]`,
        as: `upper_${c}`
      }
    ], r ? l.push({
      calculate: `datum["${c}"] + datum["${r.field}"]`,
      as: `lower_${c}`
    }) : l.push({
      calculate: `datum["${c}"] - datum["${i.field}"]`,
      as: `lower_${c}`
    }));
    for (const h of l)
      f.push({
        fieldPrefix: h.as.substring(0, 6),
        titlePrefix: ys(ys(h.calculate, 'datum["', ""), '"]', "")
      });
  }
  return { postAggregateCalculates: l, errorBarSpecificAggregate: u, tooltipSummary: f, tooltipTitleWithFieldName: d };
}
function Gk(e, t, n) {
  return `${td(e)} ${n} ${t}`;
}
const KE = "errorband", qae = ["band", "borders"], Wae = new Hm(KE, oL);
function oL(e, { config: t }) {
  e = {
    ...e,
    encoding: Ym(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: o, markDef: a, outerSpec: s, tooltipEncoding: u } = rL(e, KE, t), l = a, c = XE(l, r, i, o, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
  let d = { type: f ? "area" : "rect" }, h = { type: f ? "line" : "rule" };
  const p = {
    ...l.interpolate ? { interpolate: l.interpolate } : {},
    ...l.tension && l.interpolate ? { tension: l.tension } : {}
  };
  return f ? (d = {
    ...d,
    ...p,
    ariaRoleDescription: "errorband"
  }, h = {
    ...h,
    ...p,
    aria: !1
  }) : l.interpolate ? U(Lk("interpolate")) : l.tension && U(Lk("tension")), {
    ...s,
    transform: n,
    layer: [
      ...c({
        partName: "band",
        mark: d,
        positionPrefix: "lower",
        endPositionPrefix: "upper",
        extraEncoding: u
      }),
      ...c({
        partName: "borders",
        mark: h,
        positionPrefix: "lower",
        extraEncoding: u
      }),
      ...c({
        partName: "borders",
        mark: h,
        positionPrefix: "upper",
        extraEncoding: u
      })
    ]
  };
}
const aL = {};
function JE(e, t, n) {
  const i = new Hm(e, t);
  aL[e] = { normalizer: i, parts: n };
}
function Gae() {
  return B(aL);
}
JE(Zp, tL, Nae);
JE(VE, iL, Lae);
JE(KE, oL, qae);
const Hae = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
], sL = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
}, uL = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
}, Yae = B(sL), Xae = B(uL), Vae = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
}, lL = B(Vae), cL = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
], Kae = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
}, Jae = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
}, Li = "_vgsid_", Qae = {
  point: {
    on: "click",
    fields: [Li],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[mousedown, window:mouseup] > window:mousemove!",
    encodings: ["x", "y"],
    translate: "[mousedown, window:mouseup] > window:mousemove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function QE(e) {
  return e === "legend" || !!(e != null && e.legend);
}
function A1(e) {
  return QE(e) && K(e);
}
function ZE(e) {
  return !!(e != null && e.select);
}
function fL(e) {
  const t = [];
  for (const n of e || []) {
    if (ZE(n))
      continue;
    const { expr: i, bind: r, ...o } = n;
    if (r && i) {
      const a = {
        ...o,
        bind: r,
        init: i
      };
      t.push(a);
    } else {
      const a = {
        ...o,
        ...i ? { update: i } : {},
        ...r ? { bind: r } : {}
      };
      t.push(a);
    }
  }
  return t;
}
function Zae(e) {
  return Xm(e) || t_(e) || e_(e);
}
function e_(e) {
  return "concat" in e;
}
function Xm(e) {
  return "vconcat" in e;
}
function t_(e) {
  return "hconcat" in e;
}
function dL({ step: e, offsetIsDiscrete: t }) {
  var n;
  return t ? (n = e.for) != null ? n : "offset" : "position";
}
function wr(e) {
  return K(e) && e.step !== void 0;
}
function Hk(e) {
  return e.view || e.width || e.height;
}
const Yk = 20, ese = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
}, tse = B(ese);
function nse(e, t, n) {
  var s, u;
  const i = n[t], r = {}, { spacing: o, columns: a } = i;
  o !== void 0 && (r.spacing = o), a !== void 0 && (jm(e) && !sd(e.facet) || e_(e)) && (r.columns = a), Xm(e) && (r.columns = 1);
  for (const l of tse)
    if (e[l] !== void 0)
      if (l === "spacing") {
        const c = e[l];
        r[l] = Oe(c) ? c : {
          row: (s = c.row) != null ? s : o,
          column: (u = c.column) != null ? u : o
        };
      } else
        r[l] = e[l];
  return r;
}
function zv(e, t) {
  var n;
  return (n = e[t]) != null ? n : e[t === "width" ? "continuousWidth" : "continuousHeight"];
}
function eg(e, t) {
  const n = tg(e, t);
  return wr(n) ? n.step : hL;
}
function tg(e, t) {
  var i;
  const n = (i = e[t]) != null ? i : e[t === "width" ? "discreteWidth" : "discreteHeight"];
  return tt(n, { step: e.step });
}
const hL = 20, ise = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: hL
}, rse = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: ise,
  mark: Koe,
  arc: {},
  area: {},
  bar: Zoe,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: eae,
  rule: { color: "black" },
  square: {},
  text: { color: "black" },
  tick: tae,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: !0,
    ticks: !1
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: !1
  },
  scale: Ooe,
  projection: {},
  legend: Kae,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: Qae,
  style: {},
  title: {},
  facet: { spacing: Yk },
  concat: { spacing: Yk },
  normalizedNumberFormat: ".0%"
}, Ir = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
], Xk = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
}, Vk = {
  blue: Ir[0],
  orange: Ir[1],
  red: Ir[2],
  teal: Ir[3],
  green: Ir[4],
  yellow: Ir[5],
  purple: Ir[6],
  pink: Ir[7],
  brown: Ir[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function ose(e = {}) {
  return {
    signals: [
      {
        name: "color",
        value: K(e) ? { ...Vk, ...e } : Vk
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function ase(e) {
  return {
    signals: [
      {
        name: "fontSize",
        value: K(e) ? { ...Xk, ...e } : Xk
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function sse(e) {
  return {
    text: { font: e },
    style: {
      "guide-label": { font: e },
      "guide-title": { font: e },
      "group-title": { font: e },
      "group-subtitle": { font: e }
    }
  };
}
function pL(e) {
  const t = B(e || {}), n = {};
  for (const i of t) {
    const r = e[i];
    n[i] = cd(r) ? WR(r) : Ln(r);
  }
  return n;
}
function use(e) {
  const t = B(e), n = {};
  for (const i of t)
    n[i] = pL(e[i]);
  return n;
}
const lse = [
  ...A6,
  ...Y6,
  ...lL,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function gL(e = {}) {
  const { color: t, font: n, fontSize: i, selection: r, ...o } = e, a = ll({}, ae(rse), n ? sse(n) : {}, t ? ose(t) : {}, i ? ase(i) : {}, o || {});
  r && cl(a, "selection", r, !0);
  const s = bn(a, lse);
  for (const u of ["background", "lineBreak", "padding"])
    a[u] && (s[u] = Ln(a[u]));
  for (const u of A6)
    a[u] && (s[u] = pn(a[u]));
  for (const u of Y6)
    a[u] && (s[u] = pL(a[u]));
  for (const u of lL)
    a[u] && (s[u] = pn(a[u]));
  return a.legend && (s.legend = pn(a.legend)), a.scale && (s.scale = pn(a.scale)), a.style && (s.style = use(a.style)), a.title && (s.title = pn(a.title)), a.view && (s.view = pn(a.view)), s;
}
const cse = /* @__PURE__ */ new Set(["view", ...Woe]), fse = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
], dse = {
  view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
  ...Voe
};
function hse(e) {
  e = ae(e);
  for (const t of fse)
    delete e[t];
  if (e.axis)
    for (const t in e.axis)
      cd(e.axis[t]) && delete e.axis[t];
  if (e.legend)
    for (const t of Hae)
      delete e.legend[t];
  if (e.mark) {
    for (const t of Pk)
      delete e.mark[t];
    e.mark.tooltip && K(e.mark.tooltip) && delete e.mark.tooltip;
  }
  e.params && (e.signals = (e.signals || []).concat(fL(e.params)), delete e.params);
  for (const t of cse) {
    for (const i of Pk)
      delete e[t][i];
    const n = dse[t];
    if (n)
      for (const i of n)
        delete e[t][i];
    gse(e, t);
  }
  for (const t of Gae())
    delete e[t];
  pse(e);
  for (const t in e)
    K(e[t]) && De(e[t]) && delete e[t];
  return De(e) ? void 0 : e;
}
function pse(e) {
  const { titleMarkConfig: t, subtitleMarkConfig: n, subtitle: i } = qR(e.title);
  De(t) || (e.style["group-title"] = {
    ...e.style["group-title"],
    ...t
  }), De(n) || (e.style["group-subtitle"] = {
    ...e.style["group-subtitle"],
    ...n
  }), De(i) ? delete e.title : e.title = i;
}
function gse(e, t, n, i) {
  const r = i ? e[t][i] : e[t];
  t === "view" && (n = "cell");
  const o = {
    ...r,
    ...e.style[n != null ? n : t]
  };
  De(o) || (e.style[n != null ? n : t] = o), i || delete e[t];
}
function Vm(e) {
  return "layer" in e;
}
function mse(e) {
  return "repeat" in e;
}
function yse(e) {
  return !P(e.repeat) && e.repeat.layer;
}
class n_ {
  map(t, n) {
    return jm(t) ? this.mapFacet(t, n) : mse(t) ? this.mapRepeat(t, n) : t_(t) ? this.mapHConcat(t, n) : Xm(t) ? this.mapVConcat(t, n) : e_(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (Vm(t))
      return this.mapLayer(t, n);
    if (yo(t))
      return this.mapUnit(t, n);
    throw new Error(yE(t));
  }
  mapLayer(t, n) {
    return {
      ...t,
      layer: t.layer.map((i) => this.mapLayerOrUnit(i, n))
    };
  }
  mapHConcat(t, n) {
    return {
      ...t,
      hconcat: t.hconcat.map((i) => this.map(i, n))
    };
  }
  mapVConcat(t, n) {
    return {
      ...t,
      vconcat: t.vconcat.map((i) => this.map(i, n))
    };
  }
  mapConcat(t, n) {
    const { concat: i, ...r } = t;
    return {
      ...r,
      concat: i.map((o) => this.map(o, n))
    };
  }
  mapFacet(t, n) {
    return {
      ...t,
      spec: this.map(t.spec, n)
    };
  }
  mapRepeat(t, n) {
    return {
      ...t,
      spec: this.map(t.spec, n)
    };
  }
}
const vse = {
  zero: 1,
  center: 1,
  normalize: 1
};
function bse(e) {
  return e in vse;
}
const xse = /* @__PURE__ */ new Set([E6, Im, Lm, Yp, zm, NE, DE, Pm, _6, OE]), wse = /* @__PURE__ */ new Set([Im, Lm, E6]);
function nu(e) {
  return q(e) && Zu(e) === "quantitative" && !e.bin;
}
function Kk(e, t, { orient: n, type: i }) {
  const r = t === "x" ? "y" : "radius", o = t === "x", a = e[t], s = e[r];
  if (q(a) && q(s))
    if (nu(a) && nu(s)) {
      if (a.stack)
        return t;
      if (s.stack)
        return r;
      const u = q(a) && !!a.aggregate, l = q(s) && !!s.aggregate;
      if (u !== l)
        return u ? t : r;
      if (o && ["bar", "area"].includes(i)) {
        if (n === "vertical")
          return r;
        if (n === "horizontal")
          return t;
      }
    } else {
      if (nu(a))
        return t;
      if (nu(s))
        return r;
    }
  else {
    if (nu(a))
      return t;
    if (nu(s))
      return r;
  }
}
function Ese(e) {
  switch (e) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function mL(e, t) {
  var d, h;
  const n = br(e) ? e : { type: e }, i = n.type;
  if (!xse.has(i))
    return null;
  const r = Kk(t, "x", n) || Kk(t, "theta", n);
  if (!r)
    return null;
  const o = t[r], a = q(o) ? H(o, {}) : void 0, s = Ese(r), u = [], l = /* @__PURE__ */ new Set();
  if (t[s]) {
    const p = t[s], g = q(p) ? H(p, {}) : void 0;
    g && g !== a && (u.push(s), l.add(g));
    const m = s === "x" ? "xOffset" : "yOffset", y = t[m], v = q(y) ? H(y, {}) : void 0;
    v && v !== a && (u.push(m), l.add(v));
  }
  const c = Die.reduce((p, g) => {
    if (g !== "tooltip" && ns(t, g)) {
      const m = t[g];
      for (const y of X(m)) {
        const v = xr(y);
        if (v.aggregate)
          continue;
        const b = H(v, {});
        (!b || !l.has(b)) && p.push({ channel: g, fieldDef: v });
      }
    }
    return p;
  }, []);
  let f;
  return o.stack !== void 0 ? ua(o.stack) ? f = o.stack ? "zero" : null : f = o.stack : wse.has(i) && (f = "zero"), !f || !bse(f) || GE(t) && c.length === 0 ? null : ((d = o == null ? void 0 : o.scale) == null ? void 0 : d.type) && ((h = o == null ? void 0 : o.scale) == null ? void 0 : h.type) !== xn.LINEAR ? (o != null && o.stack && U(Kre(o.scale.type)), null) : se(t[Tr(r)]) ? (o.stack !== void 0 && U(Vre(r)), null) : (q(o) && o.aggregate && !Hie.has(o.aggregate) && U(Jre(o.aggregate)), {
    groupbyChannels: u,
    groupbyFields: l,
    fieldChannel: r,
    impute: o.impute === null ? !1 : Ea(i),
    stackBy: c,
    offset: f
  });
}
function yL(e, t, n) {
  const i = pn(e), r = Me("orient", i, n);
  if (i.orient = $se(i.type, t, r), r !== void 0 && r !== i.orient && U(Nre(i.orient, r)), i.type === "bar" && i.orient) {
    const s = Me("cornerRadiusEnd", i, n);
    if (s !== void 0) {
      const u = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Qoe[i.orient];
      for (const l of u)
        i[l] = s;
      i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd;
    }
  }
  return Me("opacity", i, n) === void 0 && (i.opacity = Sse(i.type, t)), Me("cursor", i, n) === void 0 && (i.cursor = _se(i, t, n)), i;
}
function _se(e, t, n) {
  return t.href || e.href || Me("href", e, n) ? "pointer" : e.cursor;
}
function Sse(e, t) {
  if (me([zm, OE, NE, DE], e) && !GE(t))
    return 0.7;
}
function Ase(e, t, { graticule: n }) {
  if (n)
    return !1;
  const i = so("filled", e, t), r = e.type;
  return tt(i, r !== zm && r !== Pm && r !== Yp);
}
function $se(e, t, n) {
  switch (e) {
    case zm:
    case NE:
    case DE:
    case _6:
    case Uoe:
    case joe:
      return;
  }
  const { x: i, y: r, x2: o, y2: a } = t;
  switch (e) {
    case Im:
      if (q(i) && (_t(i.bin) || q(r) && r.aggregate && !i.aggregate))
        return "vertical";
      if (q(r) && (_t(r.bin) || q(i) && i.aggregate && !r.aggregate))
        return "horizontal";
      if (a || o) {
        if (n)
          return n;
        if (!o)
          return (q(i) && i.type === xs && !ze(i.bin) || Vp(i)) && q(r) && _t(r.bin) ? "horizontal" : "vertical";
        if (!a)
          return (q(r) && r.type === xs && !ze(r.bin) || Vp(r)) && q(i) && _t(i.bin) ? "vertical" : "horizontal";
      }
    case Yp:
      if (o && !(q(i) && _t(i.bin)) && a && !(q(r) && _t(r.bin)))
        return;
    case Lm:
      if (a)
        return q(r) && _t(r.bin) ? "horizontal" : "vertical";
      if (o)
        return q(i) && _t(i.bin) ? "vertical" : "horizontal";
      if (e === Yp) {
        if (i && !r)
          return "vertical";
        if (r && !i)
          return "horizontal";
      }
    case Pm:
    case OE: {
      const s = Uk(i), u = Uk(r);
      if (n)
        return n;
      if (s && !u)
        return e !== "tick" ? "horizontal" : "vertical";
      if (!s && u)
        return e !== "tick" ? "vertical" : "horizontal";
      if (s && u)
        return "vertical";
      {
        const l = sn(i) && i.type === Ju, c = sn(r) && r.type === Ju;
        if (l && !c)
          return "vertical";
        if (!l && c)
          return "horizontal";
      }
      return;
    }
  }
  return "vertical";
}
function kse(e) {
  const { point: t, line: n, ...i } = e;
  return B(i).length > 1 ? i : i.type;
}
function Cse(e) {
  for (const t of ["line", "area", "rule", "trail"])
    e[t] && (e = {
      ...e,
      [t]: bn(e[t], ["point", "line"])
    });
  return e;
}
function $1(e, t = {}, n) {
  return e.point === "transparent" ? { opacity: 0 } : e.point ? K(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? K(t.point) ? t.point : {} : void 0;
}
function Jk(e, t = {}) {
  return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0;
}
class Fse {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(t, n) {
    if (yo(t)) {
      const { mark: i, encoding: r } = t, o = br(i) ? i : { type: i };
      switch (o.type) {
        case "line":
        case "rule":
        case "trail":
          return !!$1(o, n[o.type], r);
        case "area":
          return !!$1(o, n[o.type], r) || !!Jk(o, n[o.type]);
      }
    }
    return !1;
  }
  run(t, n, i) {
    const { config: r } = n, { params: o, projection: a, mark: s, name: u, encoding: l, ...c } = t, f = Ym(l, r), d = br(s) ? s : { type: s }, h = $1(d, r[d.type], f), p = d.type === "area" && Jk(d, r[d.type]), g = [
      {
        name: u,
        ...o ? { params: o } : {},
        mark: kse({
          ...d.type === "area" && d.opacity === void 0 && d.fillOpacity === void 0 ? { opacity: 0.7 } : {},
          ...d
        }),
        encoding: bn(f, ["shape"])
      }
    ], m = mL(yL(d, f, r), f);
    let y = f;
    if (m) {
      const { fieldChannel: v, offset: b } = m;
      y = {
        ...f,
        [v]: {
          ...f[v],
          ...b ? { stack: b } : {}
        }
      };
    }
    return y = bn(y, ["y2", "x2"]), p && g.push({
      ...a ? { projection: a } : {},
      mark: {
        type: "line",
        ...Yu(d, ["clip", "interpolate", "tension", "tooltip"]),
        ...p
      },
      encoding: y
    }), h && g.push({
      ...a ? { projection: a } : {},
      mark: {
        type: "point",
        opacity: 1,
        filled: !0,
        ...Yu(d, ["clip", "tooltip"]),
        ...h
      },
      encoding: y
    }), i({
      ...c,
      layer: g
    }, {
      ...n,
      config: Cse(r)
    });
  }
}
function Mse(e, t) {
  return t ? sd(e) ? bL(e, t) : vL(e, t) : e;
}
function k1(e, t) {
  return t ? bL(e, t) : e;
}
function Bv(e, t, n) {
  const i = t[e];
  if (dae(i)) {
    if (i.repeat in n)
      return { ...t, [e]: n[i.repeat] };
    U(fre(i.repeat));
    return;
  }
  return t;
}
function vL(e, t) {
  if (e = Bv("field", e, t), e !== void 0) {
    if (e === null)
      return null;
    if (jE(e) && cr(e.sort)) {
      const n = Bv("field", e.sort, t);
      e = {
        ...e,
        ...n ? { sort: n } : {}
      };
    }
    return e;
  }
}
function Qk(e, t) {
  if (q(e))
    return vL(e, t);
  {
    const n = Bv("datum", e, t);
    return n !== e && !n.type && (n.type = "nominal"), n;
  }
}
function Zk(e, t) {
  if (se(e)) {
    const n = Qk(e, t);
    if (n)
      return n;
    if (Um(e))
      return { condition: e.condition };
  } else {
    if (ud(e)) {
      const n = Qk(e.condition, t);
      if (n)
        return {
          ...e,
          condition: n
        };
      {
        const { condition: i, ...r } = e;
        return r;
      }
    }
    return e;
  }
}
function bL(e, t) {
  const n = {};
  for (const i in e)
    if (ie(e, i)) {
      const r = e[i];
      if (P(r))
        n[i] = r.map((o) => Zk(o, t)).filter((o) => o);
      else {
        const o = Zk(r, t);
        o !== void 0 && (n[i] = o);
      }
    }
  return n;
}
class Tse {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(t) {
    if (yo(t)) {
      const { encoding: n, mark: i } = t;
      if (i === "line" || br(i) && i.type === "line")
        for (const r of Oie) {
          const o = Is(r), a = n[o];
          if (n[r] && (q(a) && !_t(a.bin) || Nr(a)))
            return !0;
        }
    }
    return !1;
  }
  run(t, n, i) {
    const { encoding: r, mark: o } = t;
    return U(Ore(!!r.x2, !!r.y2)), i({
      ...t,
      mark: K(o) ? { ...o, type: "rule" } : "rule"
    }, n);
  }
}
class Ose extends n_ {
  constructor() {
    super(...arguments), this.nonFacetUnitNormalizers = [
      Dae,
      Iae,
      Wae,
      new Fse(),
      new Tse()
    ];
  }
  map(t, n) {
    if (yo(t)) {
      const i = ns(t.encoding, Zr), r = ns(t.encoding, eo), o = ns(t.encoding, $m);
      if (i || r || o)
        return this.mapFacetedUnit(t, n);
    }
    return super.map(t, n);
  }
  mapUnit(t, n) {
    const { parentEncoding: i, parentProjection: r } = n, o = k1(t.encoding, n.repeater), a = {
      ...t,
      ...t.name ? { name: [n.repeaterPrefix, t.name].filter((u) => u).join("_") } : {},
      ...o ? { encoding: o } : {}
    };
    if (i || r)
      return this.mapUnitWithParentEncodingOrProjection(a, n);
    const s = this.mapLayerOrUnit.bind(this);
    for (const u of this.nonFacetUnitNormalizers)
      if (u.hasMatchingType(a, n.config))
        return u.run(a, n, s);
    return a;
  }
  mapRepeat(t, n) {
    return yse(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n);
  }
  mapLayerRepeat(t, n) {
    const { repeat: i, spec: r, ...o } = t, { row: a, column: s, layer: u } = i, { repeater: l = {}, repeaterPrefix: c = "" } = n;
    return a || s ? this.mapRepeat({
      ...t,
      repeat: {
        ...a ? { row: a } : {},
        ...s ? { column: s } : {}
      },
      spec: {
        repeat: { layer: u },
        spec: r
      }
    }, n) : {
      ...o,
      layer: u.map((f) => {
        const d = {
          ...l,
          layer: f
        }, h = `${(r.name ? `${r.name}_` : "") + c}child__layer_${We(f)}`, p = this.mapLayerOrUnit(r, { ...n, repeater: d, repeaterPrefix: h });
        return p.name = h, p;
      })
    };
  }
  mapNonLayerRepeat(t, n) {
    var p;
    const { repeat: i, spec: r, data: o, ...a } = t;
    !P(i) && t.columns && (t = bn(t, ["columns"]), U(Ok("repeat")));
    const s = [], { repeater: u = {}, repeaterPrefix: l = "" } = n, c = !P(i) && i.row || [u ? u.row : null], f = !P(i) && i.column || [u ? u.column : null], d = P(i) && i || [u ? u.repeat : null];
    for (const g of d)
      for (const m of c)
        for (const y of f) {
          const v = {
            repeat: g,
            row: m,
            column: y,
            layer: u.layer
          }, b = (r.name ? `${r.name}_` : "") + l + "child__" + (P(i) ? `${We(g)}` : (i.row ? `row_${We(m)}` : "") + (i.column ? `column_${We(y)}` : "")), x = this.map(r, { ...n, repeater: v, repeaterPrefix: b });
          x.name = b, s.push(bn(x, ["data"]));
        }
    const h = P(i) ? t.columns : i.column ? i.column.length : 1;
    return {
      data: (p = r.data) != null ? p : o,
      align: "all",
      ...a,
      columns: h,
      concat: s
    };
  }
  mapFacet(t, n) {
    const { facet: i } = t;
    return sd(i) && t.columns && (t = bn(t, ["columns"]), U(Ok("facet"))), super.mapFacet(t, n);
  }
  mapUnitWithParentEncodingOrProjection(t, n) {
    const { encoding: i, projection: r } = t, { parentEncoding: o, parentProjection: a, config: s } = n, u = tC({ parentProjection: a, projection: r }), l = eC({
      parentEncoding: o,
      encoding: k1(i, n.repeater)
    });
    return this.mapUnit({
      ...t,
      ...u ? { projection: u } : {},
      ...l ? { encoding: l } : {}
    }, { config: s });
  }
  mapFacetedUnit(t, n) {
    const { row: i, column: r, facet: o, ...a } = t.encoding, { mark: s, width: u, projection: l, height: c, view: f, params: d, encoding: h, ...p } = t, { facetMapping: g, layout: m } = this.getFacetMappingAndLayout({ row: i, column: r, facet: o }, n), y = k1(a, n.repeater);
    return this.mapFacet({
      ...p,
      ...m,
      facet: g,
      spec: {
        ...u ? { width: u } : {},
        ...c ? { height: c } : {},
        ...f ? { view: f } : {},
        ...l ? { projection: l } : {},
        mark: s,
        encoding: y,
        ...d ? { params: d } : {}
      }
    }, n);
  }
  getFacetMappingAndLayout(t, n) {
    var a;
    const { row: i, column: r, facet: o } = t;
    if (i || r) {
      o && U(Mre([...i ? [Zr] : [], ...r ? [eo] : []]));
      const s = {}, u = {};
      for (const l of [Zr, eo]) {
        const c = t[l];
        if (c) {
          const { align: f, center: d, spacing: h, columns: p, ...g } = c;
          s[l] = g;
          for (const m of ["align", "center", "spacing"])
            c[m] !== void 0 && ((a = u[m]) != null || (u[m] = {}), u[m][l] = c[m]);
        }
      }
      return { facetMapping: s, layout: u };
    } else {
      const { align: s, center: u, spacing: l, columns: c, ...f } = o;
      return {
        facetMapping: Mse(f, n.repeater),
        layout: {
          ...s ? { align: s } : {},
          ...u ? { center: u } : {},
          ...l ? { spacing: l } : {},
          ...c ? { columns: c } : {}
        }
      };
    }
  }
  mapLayer(t, { parentEncoding: n, parentProjection: i, ...r }) {
    const { encoding: o, projection: a, ...s } = t, u = {
      ...r,
      parentEncoding: eC({ parentEncoding: n, encoding: o, layer: !0 }),
      parentProjection: tC({ parentProjection: i, projection: a })
    };
    return super.mapLayer({
      ...s,
      ...t.name ? { name: [u.repeaterPrefix, t.name].filter((l) => l).join("_") } : {}
    }, u);
  }
}
function eC({ parentEncoding: e, encoding: t = {}, layer: n }) {
  let i = {};
  if (e) {
    const r = /* @__PURE__ */ new Set([...B(e), ...B(t)]);
    for (const o of r) {
      const a = t[o], s = e[o];
      if (se(a)) {
        const u = {
          ...s,
          ...a
        };
        i[o] = u;
      } else
        ud(a) ? i[o] = {
          ...a,
          condition: {
            ...s,
            ...a.condition
          }
        } : a || a === null ? i[o] = a : (n || Ri(s) || Z(s) || se(s) || P(s)) && (i[o] = s);
    }
  } else
    i = t;
  return !i || De(i) ? void 0 : i;
}
function tC(e) {
  const { parentProjection: t, projection: n } = e;
  return t && n && U(yre({ parentProjection: t, projection: n })), n != null ? n : t;
}
function i_(e) {
  return "filter" in e;
}
function Nse(e) {
  return (e == null ? void 0 : e.stop) !== void 0;
}
function xL(e) {
  return "lookup" in e;
}
function Dse(e) {
  return "data" in e;
}
function Rse(e) {
  return "param" in e;
}
function Lse(e) {
  return "pivot" in e;
}
function Ise(e) {
  return "density" in e;
}
function Pse(e) {
  return "quantile" in e;
}
function zse(e) {
  return "regression" in e;
}
function Bse(e) {
  return "loess" in e;
}
function jse(e) {
  return "sample" in e;
}
function Use(e) {
  return "window" in e;
}
function qse(e) {
  return "joinaggregate" in e;
}
function Wse(e) {
  return "flatten" in e;
}
function Gse(e) {
  return "calculate" in e;
}
function wL(e) {
  return "bin" in e;
}
function Hse(e) {
  return "impute" in e;
}
function Yse(e) {
  return "timeUnit" in e;
}
function Xse(e) {
  return "aggregate" in e;
}
function Vse(e) {
  return "stack" in e;
}
function Kse(e) {
  return "fold" in e;
}
function Jse(e) {
  return "extent" in e && !("density" in e);
}
function Qse(e) {
  return e.map((t) => i_(t) ? {
    filter: xu(t.filter, Aoe)
  } : t);
}
class Zse extends n_ {
  map(t, n) {
    var i, r;
    return (i = n.emptySelections) != null || (n.emptySelections = {}), (r = n.selectionPredicates) != null || (n.selectionPredicates = {}), t = nC(t, n), super.map(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (t = nC(t, n), t.encoding) {
      const i = {};
      for (const [r, o] of na(t.encoding))
        i[r] = EL(o, n);
      t = { ...t, encoding: i };
    }
    return super.mapLayerOrUnit(t, n);
  }
  mapUnit(t, n) {
    const { selection: i, ...r } = t;
    return i ? {
      ...r,
      params: na(i).map(([o, a]) => {
        var f;
        const { init: s, bind: u, empty: l, ...c } = a;
        c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[o] = l !== "none";
        for (const d of kt((f = n.selectionPredicates[o]) != null ? f : {}))
          d.empty = l !== "none";
        return { name: o, value: s, select: c, bind: u };
      })
    } : t;
  }
}
function nC(e, t) {
  const { transform: n, ...i } = e;
  if (n) {
    const r = n.map((o) => {
      if (i_(o))
        return { filter: jv(o, t) };
      if (wL(o) && Ps(o.bin))
        return {
          ...o,
          bin: _L(o.bin)
        };
      if (xL(o)) {
        const { selection: a, ...s } = o.from;
        return a ? {
          ...o,
          from: { param: a, ...s }
        } : o;
      }
      return o;
    });
    return { ...i, transform: r };
  }
  return e;
}
function EL(e, t) {
  var i, r;
  const n = ae(e);
  if (q(n) && Ps(n.bin) && (n.bin = _L(n.bin)), js(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) == null ? void 0 : r.selection)) {
    const { selection: o, ...a } = n.scale.domain;
    n.scale.domain = { ...a, ...o ? { param: o } : {} };
  }
  if (Um(n))
    if (P(n.condition))
      n.condition = n.condition.map((o) => {
        const { selection: a, param: s, test: u, ...l } = o;
        return s ? o : { ...l, test: jv(o, t) };
      });
    else {
      const { selection: o, param: a, test: s, ...u } = EL(n.condition, t);
      n.condition = a ? n.condition : {
        ...u,
        test: jv(n.condition, t)
      };
    }
  return n;
}
function _L(e) {
  const t = e.extent;
  if (t != null && t.selection) {
    const { selection: n, ...i } = t;
    return { ...e, extent: { ...i, param: n } };
  }
  return e;
}
function jv(e, t) {
  const n = (i) => xu(i, (r) => {
    var u, l;
    var o;
    const a = (u = t.emptySelections[r]) != null ? u : !0, s = { param: r, empty: a };
    return (l = (o = t.selectionPredicates)[r]) != null || (o[r] = []), t.selectionPredicates[r].push(s), s;
  });
  return e.selection ? n(e.selection) : xu(e.test || e.filter, (i) => i.selection ? n(i.selection) : i);
}
class Uv extends n_ {
  map(t, n) {
    var r;
    const i = (r = n.selections) != null ? r : [];
    if (t.params && !yo(t)) {
      const o = [];
      for (const a of t.params)
        ZE(a) ? i.push(a) : o.push(a);
      t.params = o;
    }
    return n.selections = i, super.map(t, n);
  }
  mapUnit(t, n) {
    var a;
    const i = n.selections;
    if (!i || !i.length)
      return t;
    const r = ((a = n.path) != null ? a : []).concat(t.name), o = [];
    for (const s of i)
      if (!s.views || !s.views.length)
        o.push(s);
      else
        for (const u of s.views)
          (Y(u) && (u === t.name || r.includes(u)) || P(u) && u.map((l) => r.indexOf(l)).every((l, c, f) => l !== -1 && (c === 0 || l > f[c - 1]))) && o.push(s);
    return o.length && (t.params = o), t;
  }
}
for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const t = Uv.prototype[e];
  Uv.prototype[e] = function(n, i) {
    return t.call(this, n, eue(n, i));
  };
}
function eue(e, t) {
  var n;
  return e.name ? {
    ...t,
    path: ((n = t.path) != null ? n : []).concat(e.name)
  } : t;
}
function SL(e, t) {
  t === void 0 && (t = gL(e.config));
  const n = rue(e, t), { width: i, height: r } = e, o = oue(n, { width: i, height: r, autosize: e.autosize }, t);
  return {
    ...n,
    ...o ? { autosize: o } : {}
  };
}
const tue = new Ose(), nue = new Zse(), iue = new Uv();
function rue(e, t = {}) {
  const n = { config: t };
  return iue.map(tue.map(nue.map(e, n), n), n);
}
function iC(e) {
  return Y(e) ? { type: e } : e != null ? e : {};
}
function oue(e, t, n) {
  let { width: i, height: r } = t;
  const o = yo(e) || Vm(e), a = {};
  o ? i == "container" && r == "container" ? (a.type = "fit", a.contains = "padding") : i == "container" ? (a.type = "fit-x", a.contains = "padding") : r == "container" && (a.type = "fit-y", a.contains = "padding") : (i == "container" && (U(Ck("width")), i = void 0), r == "container" && (U(Ck("height")), r = void 0));
  const s = {
    type: "pad",
    ...a,
    ...n ? iC(n.autosize) : {},
    ...iC(e.autosize)
  };
  if (s.type === "fit" && !o && (U(tre), s.type = "pad"), i == "container" && !(s.type == "fit" || s.type == "fit-x") && U(Fk("width")), r == "container" && !(s.type == "fit" || s.type == "fit-y") && U(Fk("height")), !rr(s, { type: "pad" }))
    return s;
}
function aue(e) {
  return e === "fit" || e === "fit-x" || e === "fit-y";
}
function sue(e) {
  return e ? `fit-${Tm(e)}` : "fit";
}
const uue = [
  "background",
  "padding"
];
function rC(e, t) {
  const n = {};
  for (const i of uue)
    e && e[i] !== void 0 && (n[i] = Ln(e[i]));
  return t && (n.params = e.params), n;
}
class vo {
  constructor(t = {}, n = {}) {
    this.explicit = t, this.implicit = n;
  }
  clone() {
    return new vo(ae(this.explicit), ae(this.implicit));
  }
  combine() {
    return {
      ...this.explicit,
      ...this.implicit
    };
  }
  get(t) {
    return tt(this.explicit[t], this.implicit[t]);
  }
  getWithExplicit(t) {
    return this.explicit[t] !== void 0 ? { explicit: !0, value: this.explicit[t] } : this.implicit[t] !== void 0 ? { explicit: !1, value: this.implicit[t] } : { explicit: !1, value: void 0 };
  }
  setWithExplicit(t, { value: n, explicit: i }) {
    n !== void 0 && this.set(t, n, i);
  }
  set(t, n, i) {
    return delete this[i ? "implicit" : "explicit"][t], this[i ? "explicit" : "implicit"][t] = n, this;
  }
  copyKeyFromSplit(t, { explicit: n, implicit: i }) {
    n[t] !== void 0 ? this.set(t, n[t], !0) : i[t] !== void 0 && this.set(t, i[t], !1);
  }
  copyKeyFromObject(t, n) {
    n[t] !== void 0 && this.set(t, n[t], !0);
  }
  copyAll(t) {
    for (const n of B(t.combine())) {
      const i = t.getWithExplicit(n);
      this.setWithExplicit(n, i);
    }
  }
}
function Qi(e) {
  return {
    explicit: !0,
    value: e
  };
}
function Nn(e) {
  return {
    explicit: !1,
    value: e
  };
}
function AL(e) {
  return (t, n, i, r) => {
    const o = e(t.value, n.value);
    return o > 0 ? t : o < 0 ? n : Km(t, n, i, r);
  };
}
function Km(e, t, n, i) {
  return e.explicit && t.explicit && U(Ure(n, i, e.value, t.value)), e;
}
function ra(e, t, n, i, r = Km) {
  return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : rr(e.value, t.value) ? e : r(e, t, n, i);
}
class lue extends vo {
  constructor(t = {}, n = {}, i = !1) {
    super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = i;
  }
  clone() {
    const t = super.clone();
    return t.parseNothing = this.parseNothing, t;
  }
}
function nl(e) {
  return "url" in e;
}
function vf(e) {
  return "values" in e;
}
function $L(e) {
  return "name" in e && !nl(e) && !vf(e) && !Wo(e);
}
function Wo(e) {
  return e && (kL(e) || CL(e) || r_(e));
}
function kL(e) {
  return "sequence" in e;
}
function CL(e) {
  return "sphere" in e;
}
function r_(e) {
  return "graticule" in e;
}
var Ie;
(function(e) {
  e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup";
})(Ie || (Ie = {}));
function FL(e) {
  const { signals: t, hasLegend: n, index: i, ...r } = e;
  return r.field = ri(r.field), r;
}
function _s(e, t = !0, n = Wt) {
  if (P(e)) {
    const i = e.map((r) => _s(r, t, n));
    return t ? `[${i.join(", ")}]` : i;
  } else if (zs(e))
    return n(t ? bs(e) : hoe(e));
  return t ? n(Pe(e)) : e;
}
function cue(e, t) {
  var n;
  for (const i of kt((n = e.component.selection) != null ? n : {})) {
    const r = i.name;
    let o = `${r}${aa}, ${i.resolve === "global" ? "true" : `{unit: ${is(e)}}`}`;
    for (const a of Qm)
      !a.defined(i) || (a.signals && (t = a.signals(e, i, t)), a.modifyExpr && (o = a.modifyExpr(e, i, o)));
    t.push({
      name: r + Uue,
      on: [
        {
          events: { signal: i.name + aa },
          update: `modify(${W(i.name + Ss)}, ${o})`
        }
      ]
    });
  }
  return o_(t);
}
function fue(e, t) {
  if (e.component.selection && B(e.component.selection).length) {
    const n = W(e.getName("cell"));
    t.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: pa("mousemove", "scope"),
          update: `isTuple(facet) ? facet : group(${n}).datum`
        }
      ]
    });
  }
  return o_(t);
}
function due(e, t) {
  var i;
  let n = !1;
  for (const r of kt((i = e.component.selection) != null ? i : {})) {
    const o = r.name, a = W(o + Ss);
    if (t.filter((u) => u.name === o).length === 0) {
      const u = r.resolve === "global" ? "union" : r.resolve, l = r.type === "point" ? ", true, true)" : ")";
      t.push({
        name: r.name,
        update: `${HL}(${a}, ${W(u)}${l}`
      });
    }
    n = !0;
    for (const u of Qm)
      u.defined(r) && u.topLevelSignals && (t = u.topLevelSignals(e, r, t));
  }
  return n && t.filter((o) => o.name === "unit").length === 0 && t.unshift({
    name: "unit",
    value: {},
    on: [{ events: "mousemove", update: "isTuple(group()) ? group() : unit" }]
  }), o_(t);
}
function hue(e, t) {
  var r;
  const n = [...t], i = is(e, { escape: !1 });
  for (const o of kt((r = e.component.selection) != null ? r : {})) {
    const a = { name: o.name + Ss };
    if (o.project.hasSelectionId && (a.transform = [{ type: "collect", sort: { field: Li } }]), o.init) {
      const u = o.project.items.map(FL);
      a.values = o.project.hasSelectionId ? o.init.map((l) => ({ unit: i, [Li]: _s(l, !1)[0] })) : o.init.map((l) => ({ unit: i, fields: u, values: _s(l, !1) }));
    }
    n.filter((u) => u.name === o.name + Ss).length || n.push(a);
  }
  return n;
}
function ML(e, t) {
  var n;
  for (const i of kt((n = e.component.selection) != null ? n : {}))
    for (const r of Qm)
      r.defined(i) && r.marks && (t = r.marks(e, i, t));
  return t;
}
function pue(e, t) {
  for (const n of e.children)
    Je(n) && (t = ML(n, t));
  return t;
}
function gue(e, t, n, i) {
  const r = JL(e, t.param, t);
  return {
    signal: Wn(n.get("type")) && P(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
  };
}
function o_(e) {
  return e.map((t) => (t.on && !t.on.length && delete t.on, t));
}
class Ne {
  constructor(t, n) {
    this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t);
  }
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t, t && t.addChild(this);
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(t, n) {
    if (this._children.includes(t)) {
      U(pre);
      return;
    }
    n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t);
  }
  removeChild(t) {
    const n = this._children.indexOf(t);
    return this._children.splice(n, 1), n;
  }
  remove() {
    let t = this._parent.removeChild(this);
    for (const n of this._children)
      n._parent = this._parent, this._parent.addChild(n, t++);
  }
  insertAsParentOf(t) {
    const n = t.parent;
    n.removeChild(this), this.parent = n, t.parent = this;
  }
  swapWithParent() {
    const t = this._parent, n = t.parent;
    for (const r of this._children)
      r.parent = t;
    this._children = [], t.removeChild(this);
    const i = t.parent.removeChild(t);
    this._parent = n, n.addChild(this, i), t.parent = this;
  }
}
class rn extends Ne {
  clone() {
    const t = new this.constructor();
    return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
  }
  constructor(t, n, i, r) {
    super(t, n), this.type = i, this.refCounts = r, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return this._hash === void 0 && (this._hash = `Output ${AR()}`), this._hash;
  }
  getSource() {
    return this.refCounts[this._name]++, this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(t) {
    this._source = t;
  }
}
function C1(e) {
  return e.as !== void 0;
}
function oC(e) {
  return `${e}_end`;
}
class fr extends Ne {
  clone() {
    return new fr(null, ae(this.formula));
  }
  constructor(t, n) {
    super(t), this.formula = n;
  }
  static makeFromEncoding(t, n) {
    const i = n.reduceFieldDef((r, o) => {
      const { field: a, timeUnit: s } = o;
      if (s) {
        let u;
        if (Bs(s)) {
          if (Je(n)) {
            const { mark: l } = n;
            (RE(l) || !!o.bandPosition) && (u = {
              timeUnit: vt(s),
              field: a
            });
          }
        } else
          u = {
            as: H(o, { forAs: !0 }),
            field: a,
            timeUnit: s
          };
        u && (r[ge(u)] = u);
      }
      return r;
    }, {});
    return De(i) ? null : new fr(t, i);
  }
  static makeFromTransform(t, n) {
    const { timeUnit: i, ...r } = { ...n }, o = vt(i), a = {
      ...r,
      timeUnit: o
    };
    return new fr(t, {
      [ge(a)]: a
    });
  }
  merge(t) {
    this.formula = { ...this.formula };
    for (const n in t.formula)
      this.formula[n] || (this.formula[n] = t.formula[n]);
    for (const n of t.children)
      t.removeChild(n), n.parent = this;
    t.remove();
  }
  removeFormulas(t) {
    const n = {};
    for (const [i, r] of na(this.formula)) {
      const o = C1(r) ? r.as : `${r.field}_end`;
      t.has(o) || (n[i] = r);
    }
    this.formula = n;
  }
  producedFields() {
    return new Set(kt(this.formula).map((t) => C1(t) ? t.as : oC(t.field)));
  }
  dependentFields() {
    return new Set(kt(this.formula).map((t) => t.field));
  }
  hash() {
    return `TimeUnit ${ge(this.formula)}`;
  }
  assemble() {
    const t = [];
    for (const n of kt(this.formula))
      if (C1(n)) {
        const { field: i, as: r, timeUnit: o } = n, { unit: a, utc: s, ...u } = vt(o);
        t.push({
          field: ri(i),
          type: "timeunit",
          ...a ? { units: Rm(a) } : {},
          ...s ? { timezone: "utc" } : {},
          ...u,
          as: [r, `${r}_end`]
        });
      } else if (n) {
        const { field: i, timeUnit: r } = n, o = u6(r == null ? void 0 : r.unit), { part: a, step: s } = d6(o, r.step);
        t.push({
          type: "formula",
          expr: `timeOffset('${a}', datum['${i}'], ${s})`,
          as: oC(i)
        });
      }
    return t;
  }
}
const fd = "_tuple_fields";
class mue {
  constructor(...t) {
    this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;
  }
}
const yue = {
  defined: () => !0,
  parse: (e, t, n) => {
    var p;
    const i = t.name, r = (p = t.project) != null ? p : t.project = new mue(), o = {}, a = {}, s = /* @__PURE__ */ new Set(), u = (g, m) => {
      const y = m === "visual" ? g.channel : g.field;
      let v = We(`${i}_${y}`);
      for (let b = 1; s.has(v); b++)
        v = We(`${i}_${y}_${b}`);
      return s.add(v), { [m]: v };
    }, l = t.type, c = e.config.selection[l], f = n.value !== void 0 ? X(n.value) : null;
    let { fields: d, encodings: h } = K(n.select) ? n.select : {};
    if (!d && !h && f) {
      for (const g of f)
        if (!!K(g))
          for (const m of B(g))
            Tie(m) ? (h || (h = [])).push(m) : l === "interval" ? (U(cre), h = c.encodings) : (d != null ? d : d = []).push(m);
    }
    !d && !h && (h = c.encodings, "fields" in c && (d = c.fields));
    for (const g of h != null ? h : []) {
      const m = e.fieldDef(g);
      if (m) {
        let y = m.field;
        if (m.aggregate) {
          U(nre(g, m.aggregate));
          continue;
        } else if (!y) {
          U(Tk(g));
          continue;
        }
        if (m.timeUnit && !Bs(m.timeUnit)) {
          y = e.vgField(g);
          const v = {
            timeUnit: m.timeUnit,
            as: y,
            field: m.field
          };
          a[ge(v)] = v;
        }
        if (!o[y]) {
          const v = l === "interval" && mo(g) && Wn(e.getScaleComponent(g).get("type")) ? "R" : m.bin ? "R-RE" : "E", b = { field: y, channel: g, type: v, index: r.items.length };
          b.signals = { ...u(b, "data"), ...u(b, "visual") }, r.items.push(o[y] = b), r.hasField[y] = o[y], r.hasSelectionId = r.hasSelectionId || y === Li, TR(g) ? (b.geoChannel = g, b.channel = MR(g), r.hasChannel[b.channel] = o[y]) : r.hasChannel[g] = o[y];
        }
      } else
        U(Tk(g));
    }
    for (const g of d != null ? d : []) {
      if (r.hasField[g])
        continue;
      const m = { type: "E", field: g, index: r.items.length };
      m.signals = { ...u(m, "data") }, r.items.push(m), r.hasField[g] = m, r.hasSelectionId = r.hasSelectionId || g === Li;
    }
    f && (t.init = f.map((g) => r.items.map((m) => K(g) ? g[m.geoChannel || m.channel] !== void 0 ? g[m.geoChannel || m.channel] : g[m.field] : g))), De(a) || (r.timeUnit = new fr(null, a));
  },
  signals: (e, t, n) => {
    const i = t.name + fd;
    return n.filter((o) => o.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
      name: i,
      value: t.project.items.map(FL)
    });
  }
}, to = {
  defined: (e) => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
  parse: (e, t) => {
    const n = t.scales = [];
    for (const i of t.project.items) {
      const r = i.channel;
      if (!mo(r))
        continue;
      const o = e.getScaleComponent(r), a = o ? o.get("type") : void 0;
      if (!o || !Wn(a)) {
        U(ore);
        continue;
      }
      o.set("selectionExtent", { param: t.name, field: i.field }, !0), n.push(i);
    }
  },
  topLevelSignals: (e, t, n) => {
    const i = t.scales.filter((a) => n.filter((s) => s.name === a.signals.data).length === 0);
    if (!e.parent || aC(e) || i.length === 0)
      return n;
    const r = n.filter((a) => a.name === t.name)[0];
    let o = r.update;
    if (o.indexOf(HL) >= 0)
      r.update = `{${i.map((a) => `${W(ri(a.field))}: ${a.signals.data}`).join(", ")}}`;
    else {
      for (const a of i) {
        const s = `${W(ri(a.field))}: ${a.signals.data}`;
        o.includes(s) || (o = `${o.substring(0, o.length - 1)}, ${s}}`);
      }
      r.update = o;
    }
    return n.concat(i.map((a) => ({ name: a.signals.data })));
  },
  signals: (e, t, n) => {
    if (e.parent && !aC(e))
      for (const i of t.scales) {
        const r = n.filter((o) => o.name === i.signals.data)[0];
        r.push = "outer", delete r.value, delete r.update;
      }
    return n;
  }
};
function qv(e, t) {
  return `domain(${W(e.scaleName(t))})`;
}
function aC(e) {
  return e.parent && Tl(e.parent) && !e.parent.parent;
}
const _u = "_brush", TL = "_scale_trigger", tc = "geo_interval_init_tick", OL = "_init", vue = "_center", bue = {
  defined: (e) => e.type === "interval",
  parse: (e, t, n) => {
    var r;
    var i;
    if (e.hasProjection) {
      const o = { ...K(n.select) ? n.select : {} };
      o.fields = [Li], o.encodings || (o.encodings = n.value ? B(n.value) : [qi, Ui]), n.select = { type: "interval", ...o };
    }
    if (t.translate && !to.defined(t)) {
      const o = `!event.item || event.item.mark.name !== ${W(t.name + _u)}`;
      for (const a of t.events) {
        if (!a.between) {
          U(`${a} is not an ordered event stream for interval selections.`);
          continue;
        }
        const s = X((r = (i = a.between[0]).filter) != null ? r : i.filter = []);
        s.indexOf(o) < 0 && s.push(o);
      }
    }
  },
  signals: (e, t, n) => {
    const i = t.name, r = i + aa, o = kt(t.project.hasChannel).filter((s) => s.channel === Ge || s.channel === bt), a = t.init ? t.init[0] : null;
    if (n.push(...o.reduce((s, u) => s.concat(xue(e, t, u, a && a[u.index])), [])), e.hasProjection) {
      const s = W(e.projectionName()), u = e.projectionName() + vue, { x: l, y: c } = t.project.hasChannel, f = l && l.signals.visual, d = c && c.signals.visual, h = l ? a && a[l.index] : `${u}[0]`, p = c ? a && a[c.index] : `${u}[1]`, g = (E) => e.getSizeSignalRef(E).signal, m = `[[${f ? f + "[0]" : "0"}, ${d ? d + "[0]" : "0"}],[${f ? f + "[1]" : g("width")}, ${d ? d + "[1]" : g("height")}]]`;
      a && (n.unshift({
        name: i + OL,
        init: `[scale(${s}, [${l ? h[0] : h}, ${c ? p[0] : p}]), scale(${s}, [${l ? h[1] : h}, ${c ? p[1] : p}])]`
      }), (!l || !c) && (n.find((_) => _.name === u) || n.unshift({
        name: u,
        update: `invert(${s}, [${g("width")}/2, ${g("height")}/2])`
      })));
      const y = `intersect(${m}, {markname: ${W(e.getName("marks"))}}, unit.mark)`, v = `{unit: ${is(e)}}`, b = `vlSelectionTuples(${y}, ${v})`, x = o.map((E) => E.signals.visual);
      return n.concat({
        name: r,
        on: [
          {
            events: [
              ...x.length ? [{ signal: x.join(" || ") }] : [],
              ...a ? [{ signal: tc }] : []
            ],
            update: b
          }
        ]
      });
    } else {
      if (!to.defined(t)) {
        const l = i + TL, c = o.map((f) => {
          const d = f.channel, { data: h, visual: p } = f.signals, g = W(e.scaleName(d)), m = e.getScaleComponent(d).get("type"), y = Wn(m) ? "+" : "";
          return `(!isArray(${h}) || (${y}invert(${g}, ${p})[0] === ${y}${h}[0] && ${y}invert(${g}, ${p})[1] === ${y}${h}[1]))`;
        });
        c.length && n.push({
          name: l,
          value: {},
          on: [
            {
              events: o.map((f) => ({ scale: e.scaleName(f.channel) })),
              update: c.join(" && ") + ` ? ${l} : {}`
            }
          ]
        });
      }
      const s = o.map((l) => l.signals.data), u = `unit: ${is(e)}, fields: ${i + fd}, values`;
      return n.concat({
        name: r,
        ...a ? { init: `{${u}: ${_s(a)}}` } : {},
        ...s.length ? {
          on: [
            {
              events: [{ signal: s.join(" || ") }],
              update: `${s.join(" && ")} ? {${u}: [${s}]} : null`
            }
          ]
        } : {}
      });
    }
  },
  topLevelSignals: (e, t, n) => (Je(e) && e.hasProjection && t.init && (n.filter((r) => r.name === tc).length || n.unshift({
    name: tc,
    value: null,
    on: [
      {
        events: "timer{1}",
        update: `${tc} === null ? {} : ${tc}`
      }
    ]
  })), n),
  marks: (e, t, n) => {
    const i = t.name, { x: r, y: o } = t.project.hasChannel, a = r == null ? void 0 : r.signals.visual, s = o == null ? void 0 : o.signals.visual, u = `data(${W(t.name + Ss)})`;
    if (to.defined(t) || !r && !o)
      return n;
    const l = {
      x: r !== void 0 ? { signal: `${a}[0]` } : { value: 0 },
      y: o !== void 0 ? { signal: `${s}[0]` } : { value: 0 },
      x2: r !== void 0 ? { signal: `${a}[1]` } : { field: { group: "width" } },
      y2: o !== void 0 ? { signal: `${s}[1]` } : { field: { group: "height" } }
    };
    if (t.resolve === "global")
      for (const g of B(l))
        l[g] = [
          {
            test: `${u}.length && ${u}[0].unit === ${is(e)}`,
            ...l[g]
          },
          { value: 0 }
        ];
    const { fill: c, fillOpacity: f, cursor: d, ...h } = t.mark, p = B(h).reduce((g, m) => (g[m] = [
      {
        test: [r !== void 0 && `${a}[0] !== ${a}[1]`, o !== void 0 && `${s}[0] !== ${s}[1]`].filter((y) => y).join(" && "),
        value: h[m]
      },
      { value: null }
    ], g), {});
    return [
      {
        name: `${i + _u}_bg`,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            fill: { value: c },
            fillOpacity: { value: f }
          },
          update: l
        }
      },
      ...n,
      {
        name: i + _u,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            ...d ? { cursor: { value: d } } : {},
            fill: { value: "transparent" }
          },
          update: { ...l, ...p }
        }
      }
    ];
  }
};
function xue(e, t, n, i) {
  const r = !e.hasProjection, o = n.channel, a = n.signals.visual, s = W(r ? e.scaleName(o) : e.projectionName()), u = (d) => `scale(${s}, ${d})`, l = e.getSizeSignalRef(o === Ge ? "width" : "height").signal, c = `${o}(unit)`, f = t.events.reduce((d, h) => [
    ...d,
    { events: h.between[0], update: `[${c}, ${c}]` },
    { events: h, update: `[${a}[0], clamp(${c}, 0, ${l})]` }
  ], []);
  if (r) {
    const d = n.signals.data, h = to.defined(t), p = e.getScaleComponent(o), g = p ? p.get("type") : void 0, m = i ? { init: _s(i, !0, u) } : { value: [] };
    return f.push({
      events: { signal: t.name + TL },
      update: Wn(g) ? `[${u(`${d}[0]`)}, ${u(`${d}[1]`)}]` : "[0, 0]"
    }), h ? [{ name: d, on: [] }] : [
      { name: a, ...m, on: f },
      {
        name: d,
        ...i ? { init: _s(i) } : {},
        on: [
          {
            events: { signal: a },
            update: `${a}[0] === ${a}[1] ? null : invert(${s}, ${a})`
          }
        ]
      }
    ];
  } else {
    const d = o === Ge ? 0 : 1, h = t.name + OL, p = i ? { init: `[${h}[0][${d}], ${h}[1][${d}]]` } : { value: [] };
    return [{ name: a, ...p, on: f }];
  }
}
const wue = {
  defined: (e) => e.type === "point",
  signals: (e, t, n) => {
    var f;
    const i = t.name, r = i + fd, o = t.project, a = "(item().isVoronoi ? datum.datum : datum)", s = kt((f = e.component.selection) != null ? f : {}).reduce((d, h) => h.type === "interval" ? d.concat(h.name + _u) : d, []).map((d) => `indexof(item().mark.name, '${d}') < 0`).join(" && "), u = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${s ? ` && ${s}` : ""}`;
    let l = `unit: ${is(e)}, `;
    if (t.project.hasSelectionId)
      l += `${Li}: ${a}[${W(Li)}]`;
    else {
      const d = o.items.map((h) => {
        const p = e.fieldDef(h.channel);
        return p != null && p.bin ? `[${a}[${W(e.vgField(h.channel, {}))}], ${a}[${W(e.vgField(h.channel, { binSuffix: "end" }))}]]` : `${a}[${W(h.field)}]`;
      }).join(", ");
      l += `fields: ${r}, values: [${d}]`;
    }
    const c = t.events;
    return n.concat([
      {
        name: i + aa,
        on: c ? [
          {
            events: c,
            update: `${u} ? {${l}} : null`,
            force: !0
          }
        ] : []
      }
    ]);
  }
};
function kl(e, t, n, i) {
  const r = Um(t) && t.condition, o = i(t);
  if (r) {
    const s = X(r).map((u) => {
      const l = i(u);
      if (fae(u)) {
        const { param: c, empty: f } = u;
        return { test: KL(e, { param: c, empty: f }), ...l };
      } else
        return { test: rg(e, u.test), ...l };
    });
    return {
      [n]: [...s, ...o !== void 0 ? [o] : []]
    };
  } else
    return o !== void 0 ? { [n]: o } : {};
}
function a_(e, t = "text") {
  const n = e.encoding[t];
  return kl(e, n, t, (i) => Jm(i, e.config));
}
function Jm(e, t, n = "datum") {
  if (e) {
    if (Ri(e))
      return je(e.value);
    if (se(e)) {
      const { format: i, formatType: r } = Jp(e);
      return zE({ fieldOrDatumDef: e, format: i, formatType: r, expr: n, config: t });
    }
  }
}
function NL(e, t = {}) {
  const { encoding: n, markDef: i, config: r, stack: o } = e, a = n.tooltip;
  if (P(a))
    return { tooltip: sC({ tooltip: a }, o, r, t) };
  {
    const s = t.reactiveGeom ? "datum.datum" : "datum";
    return kl(e, a, "tooltip", (u) => {
      const l = Jm(u, r, s);
      if (l)
        return l;
      if (u === null)
        return;
      let c = Me("tooltip", i, r);
      if (c === !0 && (c = { content: "encoding" }), Y(c))
        return { value: c };
      if (K(c))
        return Z(c) ? c : c.content === "encoding" ? sC(n, o, r, t) : { signal: s };
    });
  }
}
function DL(e, t, n, { reactiveGeom: i } = {}) {
  const r = { ...n, ...n.tooltipFormat }, o = {}, a = i ? "datum.datum" : "datum", s = [];
  function u(c, f) {
    const d = Is(f), h = sn(c) ? c : {
      ...c,
      type: e[d].type
    }, p = h.title || qE(h, r), g = X(p).join(", ").replaceAll(/"/g, '\\"');
    let m;
    if (xt(f)) {
      const y = f === "x" ? "x2" : "y2", v = xr(e[y]);
      if (_t(h.bin) && v) {
        const b = H(h, { expr: a }), x = H(v, { expr: a }), { format: E, formatType: _ } = Jp(h);
        m = ad(b, x, E, _, r), o[y] = !0;
      }
    }
    if ((xt(f) || f === si || f === ji) && t && t.fieldChannel === f && t.offset === "normalize") {
      const { format: y, formatType: v } = Jp(h);
      m = zE({
        fieldOrDatumDef: h,
        format: y,
        formatType: v,
        expr: a,
        config: r,
        normalizeStack: !0
      }).signal;
    }
    m != null || (m = Jm(h, r, a).signal), s.push({ channel: f, key: g, value: m });
  }
  HE(e, (c, f) => {
    q(c) ? u(c, f) : qm(c) && u(c.condition, f);
  });
  const l = {};
  for (const { channel: c, key: f, value: d } of s)
    !o[c] && !l[f] && (l[f] = d);
  return l;
}
function sC(e, t, n, { reactiveGeom: i } = {}) {
  const r = DL(e, t, n, { reactiveGeom: i }), o = na(r).map(([a, s]) => `"${a}": ${s}`);
  return o.length > 0 ? { signal: `{${o.join(", ")}}` } : void 0;
}
function Eue(e) {
  const { markDef: t, config: n } = e, i = Me("aria", t, n);
  return i === !1 ? {} : {
    ...i ? { aria: i } : {},
    ..._ue(e),
    ...Sue(e)
  };
}
function _ue(e) {
  const { mark: t, markDef: n, config: i } = e;
  if (i.aria === !1)
    return {};
  const r = Me("ariaRoleDescription", n, i);
  return r != null ? { ariaRoleDescription: { value: r } } : t in Qie ? {} : { ariaRoleDescription: { value: t } };
}
function Sue(e) {
  const { encoding: t, markDef: n, config: i, stack: r } = e, o = t.description;
  if (o)
    return kl(e, o, "description", (u) => Jm(u, e.config));
  const a = Me("description", n, i);
  if (a != null)
    return {
      description: je(a)
    };
  if (i.aria === !1)
    return {};
  const s = DL(t, r, i);
  if (!De(s))
    return {
      description: {
        signal: na(s).map(([u, l], c) => `"${c > 0 ? "; " : ""}${u}: " + (${l})`).join(" + ")
      }
    };
}
function dt(e, t, n = {}) {
  const { markDef: i, encoding: r, config: o } = t, { vgChannel: a } = n;
  let { defaultRef: s, defaultValue: u } = n;
  s === void 0 && (u != null || (u = Me(e, i, o, { vgChannel: a, ignoreVgConfig: !0 })), u !== void 0 && (s = je(u)));
  const l = r[e];
  return kl(t, l, a != null ? a : e, (c) => PE({
    channel: e,
    channelDef: c,
    markDef: i,
    config: o,
    scaleName: t.scaleName(e),
    scale: t.getScaleComponent(e),
    stack: null,
    defaultRef: s
  }));
}
function RL(e, t = { filled: void 0 }) {
  var d, h, p, g;
  const { markDef: n, encoding: i, config: r } = e, { type: o } = n, a = (d = t.filled) != null ? d : Me("filled", n, r), s = me(["bar", "point", "circle", "square", "geoshape"], o) ? "transparent" : void 0, u = (p = (h = Me(a === !0 ? "color" : void 0, n, r, { vgChannel: "fill" })) != null ? h : r.mark[a === !0 && "color"]) != null ? p : s, l = (g = Me(a === !1 ? "color" : void 0, n, r, { vgChannel: "stroke" })) != null ? g : r.mark[a === !1 && "color"], c = a ? "fill" : "stroke", f = {
    ...u ? { fill: je(u) } : {},
    ...l ? { stroke: je(l) } : {}
  };
  return n.color && (a ? n.fill : n.stroke) && U(ZR("property", { fill: "fill" in n, stroke: "stroke" in n })), {
    ...f,
    ...dt("color", e, {
      vgChannel: c,
      defaultValue: a ? u : l
    }),
    ...dt("fill", e, {
      defaultValue: i.fill ? u : void 0
    }),
    ...dt("stroke", e, {
      defaultValue: i.stroke ? l : void 0
    })
  };
}
function Aue(e) {
  const { encoding: t, mark: n } = e, i = t.order;
  return !Ea(n) && Ri(i) ? kl(e, i, "zindex", (r) => je(r.value)) : {};
}
function il({ channel: e, markDef: t, encoding: n = {}, model: i, bandPosition: r }) {
  const o = `${e}Offset`, a = t[o], s = n[o];
  if ((o === "xOffset" || o === "yOffset") && s)
    return { offsetType: "encoding", offset: PE({
      channel: o,
      channelDef: s,
      markDef: t,
      config: i == null ? void 0 : i.config,
      scaleName: i.scaleName(o),
      scale: i.getScaleComponent(o),
      stack: null,
      defaultRef: je(a),
      bandPosition: r
    }) };
  const u = t[o];
  return u ? { offsetType: "visual", offset: u } : {};
}
function Pt(e, t, { defaultPos: n, vgChannel: i }) {
  const { encoding: r, markDef: o, config: a, stack: s } = t, u = r[e], l = r[Tr(e)], c = t.scaleName(e), f = t.getScaleComponent(e), { offset: d, offsetType: h } = il({
    channel: e,
    markDef: o,
    encoding: r,
    model: t,
    bandPosition: 0.5
  }), p = s_({
    model: t,
    defaultPos: n,
    channel: e,
    scaleName: c,
    scale: f
  }), g = !u && xt(e) && (r.latitude || r.longitude) ? { field: t.getName(e) } : $ue({
    channel: e,
    channelDef: u,
    channel2Def: l,
    markDef: o,
    config: a,
    scaleName: c,
    scale: f,
    stack: s,
    offset: d,
    defaultRef: p,
    bandPosition: h === "encoding" ? 0 : void 0
  });
  return g ? { [i || e]: g } : void 0;
}
function $ue(e) {
  const { channel: t, channelDef: n, scaleName: i, stack: r, offset: o, markDef: a } = e;
  if (se(n) && r && t === r.fieldChannel) {
    if (q(n)) {
      let s = n.bandPosition;
      if (s === void 0 && a.type === "text" && (t === "radius" || t === "theta") && (s = 0.5), s !== void 0)
        return Xp({
          scaleName: i,
          fieldOrDatumDef: n,
          startSuffix: "start",
          bandPosition: s,
          offset: o
        });
    }
    return ts(n, i, { suffix: "end" }, { offset: o });
  }
  return LE(e);
}
function s_({ model: e, defaultPos: t, channel: n, scaleName: i, scale: r }) {
  const { markDef: o, config: a } = e;
  return () => {
    const s = Is(n), u = ia(n), l = Me(n, o, a, { vgChannel: u });
    if (l !== void 0)
      return Uc(n, l);
    switch (t) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (i) {
          const c = r.get("type");
          if (!me([xn.LOG, xn.TIME, xn.UTC], c)) {
            if (r.domainDefinitelyIncludesZero())
              return {
                scale: i,
                value: 0
              };
          }
        }
        if (t === "zeroOrMin")
          return s === "y" ? { field: { group: "height" } } : { value: 0 };
        switch (s) {
          case "radius":
            return {
              signal: `min(${e.width.signal},${e.height.signal})/2`
            };
          case "theta":
            return { signal: "2*PI" };
          case "x":
            return { field: { group: "width" } };
          case "y":
            return { value: 0 };
        }
        break;
      case "mid":
        return { ...e[Cn(n)], mult: 0.5 };
    }
  };
}
const kue = {
  left: "x",
  center: "xc",
  right: "x2"
}, Cue = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function LL(e, t, n, i = "middle") {
  if (e === "radius" || e === "theta")
    return ia(e);
  const r = e === "x" ? "align" : "baseline", o = Me(r, t, n);
  let a;
  return Z(o) ? (U(Tre(r)), a = void 0) : a = o, e === "x" ? kue[a || (i === "top" ? "left" : "center")] : Cue[a || i];
}
function ng(e, t, { defaultPos: n, defaultPos2: i, range: r }) {
  return r ? IL(e, t, { defaultPos: n, defaultPos2: i }) : Pt(e, t, { defaultPos: n });
}
function IL(e, t, { defaultPos: n, defaultPos2: i }) {
  const { markDef: r, config: o } = t, a = Tr(e), s = Cn(e), u = Fue(t, i, a), l = u[s] ? LL(e, r, o) : ia(e);
  return {
    ...Pt(e, t, { defaultPos: n, vgChannel: l }),
    ...u
  };
}
function Fue(e, t, n) {
  const { encoding: i, mark: r, markDef: o, stack: a, config: s } = e, u = Is(n), l = Cn(n), c = ia(n), f = i[u], d = e.scaleName(u), h = e.getScaleComponent(u), { offset: p } = n in i || n in o ? il({ channel: n, markDef: o, encoding: i, model: e }) : il({ channel: u, markDef: o, encoding: i, model: e });
  if (!f && (n === "x2" || n === "y2") && (i.latitude || i.longitude)) {
    const m = Cn(n), y = e.markDef[m];
    return y != null ? {
      [m]: { value: y }
    } : {
      [c]: { field: e.getName(n) }
    };
  }
  const g = Mue({
    channel: n,
    channelDef: f,
    channel2Def: i[n],
    markDef: o,
    config: s,
    scaleName: d,
    scale: h,
    stack: a,
    offset: p,
    defaultRef: void 0
  });
  return g !== void 0 ? { [c]: g } : Wd(n, o) || Wd(n, {
    [n]: Gp(n, o, s.style),
    [l]: Gp(l, o, s.style)
  }) || Wd(n, s[r]) || Wd(n, s.mark) || {
    [c]: s_({
      model: e,
      defaultPos: t,
      channel: n,
      scaleName: d,
      scale: h
    })()
  };
}
function Mue({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: o, scale: a, stack: s, offset: u, defaultRef: l }) {
  return se(t) && s && e.charAt(0) === s.fieldChannel.charAt(0) ? ts(t, o, { suffix: "start" }, { offset: u }) : LE({
    channel: e,
    channelDef: n,
    scaleName: o,
    scale: a,
    stack: s,
    markDef: i,
    config: r,
    offset: u,
    defaultRef: l
  });
}
function Wd(e, t) {
  const n = Cn(e), i = ia(e);
  if (t[i] !== void 0)
    return { [i]: Uc(e, t[i]) };
  if (t[e] !== void 0)
    return { [i]: Uc(e, t[e]) };
  if (t[n]) {
    const r = t[n];
    if (ws(r))
      U(Sre(n));
    else
      return { [n]: Uc(e, r) };
  }
}
function oa(e, t) {
  var m, y;
  const { config: n, encoding: i, markDef: r } = e, o = r.type, a = Tr(t), s = Cn(t), u = i[t], l = i[a], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, d = r.orient, h = (y = (m = i[s]) != null ? m : i.size) != null ? y : Me("size", r, n, { vgChannel: s }), p = RR(t), g = o === "bar" && (t === "x" ? d === "vertical" : d === "horizontal");
  return q(u) && (ze(u.bin) || _t(u.bin) || u.timeUnit && !l) && !(h && !ws(h)) && !i[p] && !wt(f) ? Nue({
    fieldDef: u,
    fieldDef2: l,
    channel: t,
    model: e
  }) : (se(u) && wt(f) || g) && !l ? Oue(u, t, e) : IL(t, e, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
}
function Tue(e, t, n, i, r, o, a) {
  if (ws(r))
    if (n) {
      const u = n.get("type");
      if (u === "band") {
        let l = `bandwidth('${t}')`;
        r.band !== 1 && (l = `${r.band} * ${l}`);
        const c = so("minBandSize", { type: a }, i);
        return { signal: c ? `max(${Ai(c)}, ${l})` : l };
      } else
        r.band !== 1 && (U(Rre(u)), r = void 0);
    } else
      return {
        mult: r.band,
        field: { group: e }
      };
  else {
    if (Z(r))
      return r;
    if (r)
      return { value: r };
  }
  if (n) {
    const u = n.get("range");
    if (wa(u) && Oe(u.step))
      return { value: u.step - 2 };
  }
  if (!o) {
    const { bandPaddingInner: u, barBandPaddingInner: l, rectBandPaddingInner: c } = i.scale, f = tt(u, a === "bar" ? l : c);
    if (Z(f))
      return { signal: `(1 - (${f.signal})) * ${e}` };
    if (Oe(f))
      return { signal: `${1 - f} * ${e}` };
  }
  return { value: eg(i.view, e) - 2 };
}
function Oue(e, t, n) {
  const { markDef: i, encoding: r, config: o, stack: a } = n, s = i.orient, u = n.scaleName(t), l = n.getScaleComponent(t), c = Cn(t), f = Tr(t), d = RR(t), h = n.scaleName(d), p = n.getScaleComponent(dE(t)), g = s === "horizontal" && t === "y" || s === "vertical" && t === "x";
  let m;
  (r.size || i.size) && (g ? m = dt("size", n, {
    vgChannel: c,
    defaultRef: je(i.size)
  }) : U(zre(i.type)));
  const y = !!m, v = R6({ channel: t, fieldDef: e, markDef: i, config: o, scaleType: l == null ? void 0 : l.get("type"), useVlSizeChannel: g });
  m = m || {
    [c]: Tue(c, h || u, p || l, o, v, !!e, i.type)
  };
  const b = (l == null ? void 0 : l.get("type")) === "band" && ws(v) && !y ? "top" : "middle", x = LL(t, i, o, b), E = x === "xc" || x === "yc", { offset: _, offsetType: w } = il({ channel: t, markDef: i, encoding: r, model: n, bandPosition: E ? 0.5 : 0 }), S = LE({
    channel: t,
    channelDef: e,
    markDef: i,
    config: o,
    scaleName: u,
    scale: l,
    stack: a,
    offset: _,
    defaultRef: s_({ model: n, defaultPos: "mid", channel: t, scaleName: u, scale: l }),
    bandPosition: E ? w === "encoding" ? 0 : 0.5 : Z(v) ? { signal: `(1-${v})/2` } : ws(v) ? (1 - v.band) / 2 : 0
  });
  if (c)
    return { [x]: S, ...m };
  {
    const C = ia(f), $ = m[c], A = _ ? { ...$, offset: _ } : $;
    return {
      [x]: S,
      [C]: P(S) ? [S[0], { ...S[1], offset: A }] : {
        ...S,
        offset: A
      }
    };
  }
}
function uC(e, t, n, i, r, o, a) {
  if (FR(e))
    return 0;
  const s = e === "x" || e === "y2", u = s ? -t / 2 : t / 2;
  if (Z(n) || Z(r) || Z(i) || o) {
    const l = Ai(n), c = Ai(r), f = Ai(i), d = Ai(o), p = o ? `(${a} < ${d} ? ${s ? "" : "-"}0.5 * (${d} - (${a})) : ${u})` : u, g = f ? `${f} + ` : "", m = l ? `(${l} ? -1 : 1) * ` : "", y = c ? `(${c} + ${p})` : p;
    return {
      signal: g + m + y
    };
  } else
    return r = r || 0, i + (n ? -r - u : +r + u);
}
function Nue({ fieldDef: e, fieldDef2: t, channel: n, model: i }) {
  var C, $, A;
  const { config: r, markDef: o, encoding: a } = i, s = i.getScaleComponent(n), u = i.scaleName(n), l = s ? s.get("type") : void 0, c = s.get("reverse"), f = R6({ channel: n, fieldDef: e, markDef: o, config: r, scaleType: l }), d = (C = i.component.axes[n]) == null ? void 0 : C[0], h = ($ = d == null ? void 0 : d.get("translate")) != null ? $ : 0.5, p = xt(n) && (A = Me("binSpacing", o, r)) != null ? A : 0, g = Tr(n), m = ia(n), y = ia(g), v = so("minBandSize", o, r), { offset: b } = il({ channel: n, markDef: o, encoding: a, model: i, bandPosition: 0 }), { offset: x } = il({ channel: g, markDef: o, encoding: a, model: i, bandPosition: 0 }), E = aae({ fieldDef: e, scaleName: u }), _ = uC(n, p, c, h, b, v, E), w = uC(g, p, c, h, x != null ? x : b, v, E), S = Z(f) ? { signal: `(1-${f.signal})/2` } : ws(f) ? (1 - f.band) / 2 : 0.5;
  if (ze(e.bin) || e.timeUnit)
    return {
      [y]: lC({
        fieldDef: e,
        scaleName: u,
        bandPosition: S,
        offset: w
      }),
      [m]: lC({
        fieldDef: e,
        scaleName: u,
        bandPosition: Z(S) ? { signal: `1-${S.signal}` } : 1 - S,
        offset: _
      })
    };
  if (_t(e.bin)) {
    const M = ts(e, u, {}, { offset: w });
    if (q(t))
      return {
        [y]: M,
        [m]: ts(t, u, {}, { offset: _ })
      };
    if (Ps(e.bin) && e.bin.step)
      return {
        [y]: M,
        [m]: {
          signal: `scale("${u}", ${H(e, { expr: "datum" })} + ${e.bin.step})`,
          offset: _
        }
      };
  }
  U(n6(g));
}
function lC({ fieldDef: e, scaleName: t, bandPosition: n, offset: i }) {
  return Xp({
    scaleName: t,
    fieldOrDatumDef: e,
    bandPosition: n,
    offset: i
  });
}
const Due = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function ui(e, t) {
  const { fill: n = void 0, stroke: i = void 0 } = t.color === "include" ? RL(e) : {};
  return {
    ...Rue(e.markDef, t),
    ...cC(e, "fill", n),
    ...cC(e, "stroke", i),
    ...dt("opacity", e),
    ...dt("fillOpacity", e),
    ...dt("strokeOpacity", e),
    ...dt("strokeWidth", e),
    ...dt("strokeDash", e),
    ...Aue(e),
    ...NL(e),
    ...a_(e, "href"),
    ...Eue(e)
  };
}
function cC(e, t, n) {
  const { config: i, mark: r, markDef: o } = e;
  if (Me("invalid", o, i) === "hide" && n && !Ea(r)) {
    const s = Lue(e, { invalid: !0, channels: Om });
    if (s)
      return {
        [t]: [
          { test: s, value: null },
          ...X(n)
        ]
      };
  }
  return n ? { [t]: n } : {};
}
function Rue(e, t) {
  return Jie.reduce((n, i) => (!Due.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = je(e[i])), n), {});
}
function Lue(e, { invalid: t = !1, channels: n }) {
  const i = n.reduce((o, a) => {
    const s = e.getScaleComponent(a);
    if (s) {
      const u = s.get("type"), l = e.vgField(a, { expr: "datum" });
      l && Wn(u) && (o[l] = !0);
    }
    return o;
  }, {}), r = B(i);
  if (r.length > 0) {
    const o = t ? "||" : "&&";
    return r.map((a) => IE(a, t)).join(` ${o} `);
  }
}
function u_(e) {
  const { config: t, markDef: n } = e;
  if (Me("invalid", n, t)) {
    const r = Iue(e, { channels: Or });
    if (r)
      return { defined: { signal: r } };
  }
  return {};
}
function Iue(e, { invalid: t = !1, channels: n }) {
  const i = n.reduce((o, a) => {
    var u;
    const s = e.getScaleComponent(a);
    if (s) {
      const l = s.get("type"), c = e.vgField(a, { expr: "datum", binSuffix: (u = e.stack) != null && u.impute ? "mid" : void 0 });
      c && Wn(l) && (o[c] = !0);
    }
    return o;
  }, {}), r = B(i);
  if (r.length > 0) {
    const o = t ? "||" : "&&";
    return r.map((a) => IE(a, t)).join(` ${o} `);
  }
}
function fC(e, t) {
  if (t !== void 0)
    return { [e]: je(t) };
}
const F1 = "voronoi", PL = {
  defined: (e) => e.type === "point" && e.nearest,
  parse: (e, t) => {
    if (t.events)
      for (const n of t.events)
        n.markname = e.getName(F1);
  },
  marks: (e, t, n) => {
    const { x: i, y: r } = t.project.hasChannel, o = e.mark;
    if (Ea(o))
      return U(ire(o)), n;
    const a = {
      name: e.getName(F1),
      type: "path",
      interactive: !0,
      from: { data: e.getName("marks") },
      encode: {
        update: {
          fill: { value: "transparent" },
          strokeWidth: { value: 0.35 },
          stroke: { value: "transparent" },
          isVoronoi: { value: !0 },
          ...NL(e, { reactiveGeom: !0 })
        }
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: i || !r ? "datum.datum.x || 0" : "0" },
          y: { expr: r || !i ? "datum.datum.y || 0" : "0" },
          size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
        }
      ]
    };
    let s = 0, u = !1;
    return n.forEach((l, c) => {
      var d;
      const f = (d = l.name) != null ? d : "";
      f === e.component.mark[0].name ? s = c : f.indexOf(F1) >= 0 && (u = !0);
    }), u || n.splice(s + 1, 0, a), n;
  }
}, zL = {
  defined: (e) => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !QE(e.bind),
  parse: (e, t, n) => YL(t, n),
  topLevelSignals: (e, t, n) => {
    const i = t.name, r = t.project, o = t.bind, a = t.init && t.init[0], s = PL.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    return r.items.forEach((u, l) => {
      var d, h;
      const c = We(`${i}_${u.field}`);
      n.filter((p) => p.name === c).length || n.unshift({
        name: c,
        ...a ? { init: _s(a[l]) } : { value: null },
        on: t.events ? [
          {
            events: t.events,
            update: `datum && item().mark.marktype !== 'group' ? ${s}[${W(u.field)}] : null`
          }
        ] : [],
        bind: (h = (d = o[u.field]) != null ? d : o[u.channel]) != null ? h : o
      });
    }), n;
  },
  signals: (e, t, n) => {
    const i = t.name, r = t.project, o = n.filter((l) => l.name === i + aa)[0], a = i + fd, s = r.items.map((l) => We(`${i}_${l.field}`)), u = s.map((l) => `${l} !== null`).join(" && ");
    return s.length && (o.update = `${u} ? {fields: ${a}, values: [${s.join(", ")}]} : null`), delete o.value, delete o.on, n;
  }
}, ig = "_toggle", BL = {
  defined: (e) => e.type === "point" && !!e.toggle,
  signals: (e, t, n) => n.concat({
    name: t.name + ig,
    value: !1,
    on: [{ events: t.events, update: t.toggle }]
  }),
  modifyExpr: (e, t) => {
    const n = t.name + aa, i = t.name + ig;
    return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${is(e)}}, `) + `${i} ? ${n} : null`;
  }
}, Pue = {
  defined: (e) => e.clear !== void 0 && e.clear !== !1,
  parse: (e, t) => {
    t.clear && (t.clear = Y(t.clear) ? pa(t.clear, "view") : t.clear);
  },
  topLevelSignals: (e, t, n) => {
    if (zL.defined(t))
      for (const i of t.project.items) {
        const r = n.findIndex((o) => o.name === We(`${t.name}_${i.field}`));
        r !== -1 && n[r].on.push({ events: t.clear, update: "null" });
      }
    return n;
  },
  signals: (e, t, n) => {
    function i(r, o) {
      r !== -1 && n[r].on && n[r].on.push({ events: t.clear, update: o });
    }
    if (t.type === "interval")
      for (const r of t.project.items) {
        const o = n.findIndex((a) => a.name === r.signals.visual);
        if (i(o, "[0, 0]"), o === -1) {
          const a = n.findIndex((s) => s.name === r.signals.data);
          i(a, "null");
        }
      }
    else {
      let r = n.findIndex((o) => o.name === t.name + aa);
      i(r, "null"), BL.defined(t) && (r = n.findIndex((o) => o.name === t.name + ig), i(r, "false"));
    }
    return n;
  }
}, jL = {
  defined: (e) => {
    const t = e.resolve === "global" && e.bind && QE(e.bind), n = e.project.items.length === 1 && e.project.items[0].field !== Li;
    return t && !n && U(are), t && n;
  },
  parse: (e, t, n) => {
    var a;
    const i = ae(n);
    if (i.select = Y(i.select) ? { type: i.select, toggle: t.toggle } : { ...i.select, toggle: t.toggle }, YL(t, i), K(n.select) && (n.select.on || n.select.clear)) {
      const s = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const u of t.events)
        u.filter = X((a = u.filter) != null ? a : []), u.filter.includes(s) || u.filter.push(s);
    }
    const r = A1(t.bind) ? t.bind.legend : "click", o = Y(r) ? pa(r, "view") : X(r);
    t.bind = { legend: { merge: o } };
  },
  topLevelSignals: (e, t, n) => {
    const i = t.name, r = A1(t.bind) && t.bind.legend, o = (a) => (s) => {
      const u = ae(s);
      return u.markname = a, u;
    };
    for (const a of t.project.items) {
      if (!a.hasLegend)
        continue;
      const s = `${We(a.field)}_legend`, u = `${i}_${s}`;
      if (n.filter((c) => c.name === u).length === 0) {
        const c = r.merge.map(o(`${s}_symbols`)).concat(r.merge.map(o(`${s}_labels`))).concat(r.merge.map(o(`${s}_entries`)));
        n.unshift({
          name: u,
          ...t.init ? {} : { value: null },
          on: [
            {
              events: c,
              update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
              force: !0
            },
            { events: r.merge, update: `!event.item || !datum ? null : ${u}`, force: !0 }
          ]
        });
      }
    }
    return n;
  },
  signals: (e, t, n) => {
    const i = t.name, r = t.project, o = n.find((d) => d.name === i + aa), a = i + fd, s = r.items.filter((d) => d.hasLegend).map((d) => We(`${i}_${We(d.field)}_legend`)), l = `${s.map((d) => `${d} !== null`).join(" && ")} ? {fields: ${a}, values: [${s.join(", ")}]} : null`;
    t.events && s.length > 0 ? o.on.push({
      events: s.map((d) => ({ signal: d })),
      update: l
    }) : s.length > 0 && (o.update = l, delete o.value, delete o.on);
    const c = n.find((d) => d.name === i + ig), f = A1(t.bind) && t.bind.legend;
    return c && (t.events ? c.on.push({ ...c.on[0], events: f }) : c.on[0].events = f), n;
  }
};
function zue(e, t, n) {
  var r, o, a, s;
  const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
  for (const u of kt((o = e.component.selection) != null ? o : {})) {
    const l = (a = u.project.hasField[i]) != null ? a : u.project.hasChannel[t];
    if (l && jL.defined(u)) {
      const c = (s = n.get("selections")) != null ? s : [];
      c.push(u.name), n.set("selections", c, !1), l.hasLegend = !0;
    }
  }
}
const UL = "_translate_anchor", qL = "_translate_delta", Bue = {
  defined: (e) => e.type === "interval" && e.translate,
  signals: (e, t, n) => {
    const i = t.name, r = to.defined(t), o = i + UL, { x: a, y: s } = t.project.hasChannel;
    let u = pa(t.translate, "scope");
    return r || (u = u.map((l) => (l.between[0].markname = i + _u, l))), n.push({
      name: o,
      value: {},
      on: [
        {
          events: u.map((l) => l.between[0]),
          update: "{x: x(unit), y: y(unit)" + (a !== void 0 ? `, extent_x: ${r ? qv(e, Ge) : `slice(${a.signals.visual})`}` : "") + (s !== void 0 ? `, extent_y: ${r ? qv(e, bt) : `slice(${s.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: i + qL,
      value: {},
      on: [
        {
          events: u,
          update: `{x: ${o}.x - x(unit), y: ${o}.y - y(unit)}`
        }
      ]
    }), a !== void 0 && dC(e, t, a, "width", n), s !== void 0 && dC(e, t, s, "height", n), n;
  }
};
function dC(e, t, n, i, r) {
  var E, _;
  const o = t.name, a = o + UL, s = o + qL, u = n.channel, l = to.defined(t), c = r.filter((w) => w.name === n.signals[l ? "data" : "visual"])[0], f = e.getSizeSignalRef(i).signal, d = e.getScaleComponent(u), h = d && d.get("type"), p = d && d.get("reverse"), g = l ? u === Ge ? p ? "" : "-" : p ? "-" : "" : "", m = `${a}.extent_${u}`, y = `${g}${s}.${u} / ${l ? `${f}` : `span(${m})`}`, v = !l || !d ? "panLinear" : h === "log" ? "panLog" : h === "symlog" ? "panSymlog" : h === "pow" ? "panPow" : "panLinear", b = l ? h === "pow" ? `, ${(E = d.get("exponent")) != null ? E : 1}` : h === "symlog" ? `, ${(_ = d.get("constant")) != null ? _ : 1}` : "" : "", x = `${v}(${m}, ${y}${b})`;
  c.on.push({
    events: { signal: s },
    update: l ? x : `clampRange(${x}, 0, ${f})`
  });
}
const WL = "_zoom_anchor", GL = "_zoom_delta", jue = {
  defined: (e) => e.type === "interval" && e.zoom,
  signals: (e, t, n) => {
    const i = t.name, r = to.defined(t), o = i + GL, { x: a, y: s } = t.project.hasChannel, u = W(e.scaleName(Ge)), l = W(e.scaleName(bt));
    let c = pa(t.zoom, "scope");
    return r || (c = c.map((f) => (f.markname = i + _u, f))), n.push({
      name: i + WL,
      on: [
        {
          events: c,
          update: r ? "{" + [u ? `x: invert(${u}, x(unit))` : "", l ? `y: invert(${l}, y(unit))` : ""].filter((f) => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
        }
      ]
    }, {
      name: o,
      on: [
        {
          events: c,
          force: !0,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    }), a !== void 0 && hC(e, t, a, "width", n), s !== void 0 && hC(e, t, s, "height", n), n;
  }
};
function hC(e, t, n, i, r) {
  var v, b;
  const o = t.name, a = n.channel, s = to.defined(t), u = r.filter((x) => x.name === n.signals[s ? "data" : "visual"])[0], l = e.getSizeSignalRef(i).signal, c = e.getScaleComponent(a), f = c && c.get("type"), d = s ? qv(e, a) : u.name, h = o + GL, p = `${o}${WL}.${a}`, g = !s || !c ? "zoomLinear" : f === "log" ? "zoomLog" : f === "symlog" ? "zoomSymlog" : f === "pow" ? "zoomPow" : "zoomLinear", m = s ? f === "pow" ? `, ${(v = c.get("exponent")) != null ? v : 1}` : f === "symlog" ? `, ${(b = c.get("constant")) != null ? b : 1}` : "" : "", y = `${g}(${d}, ${p}, ${h}${m})`;
  u.on.push({
    events: { signal: h },
    update: s ? y : `clampRange(${y}, 0, ${l})`
  });
}
const Ss = "_store", aa = "_tuple", Uue = "_modify", HL = "vlSelectionResolve", Qm = [
  wue,
  bue,
  yue,
  BL,
  zL,
  to,
  jL,
  Pue,
  Bue,
  jue,
  PL
];
function que(e) {
  let t = e.parent;
  for (; t && !Ti(t); )
    t = t.parent;
  return t;
}
function is(e, { escape: t } = { escape: !0 }) {
  let n = t ? W(e.name) : e.name;
  const i = que(e);
  if (i) {
    const { facet: r } = i;
    for (const o of Jn)
      r[o] && (n += ` + '__facet_${o}_' + (facet[${W(i.vgField(o))}])`);
  }
  return n;
}
function l_(e) {
  var t;
  return kt((t = e.component.selection) != null ? t : {}).reduce((n, i) => n || i.project.hasSelectionId, !1);
}
function YL(e, t) {
  (Y(t.select) || !t.select.on) && delete e.events, (Y(t.select) || !t.select.clear) && delete e.clear, (Y(t.select) || !t.select.toggle) && delete e.toggle;
}
function Wv(e) {
  const t = [];
  return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...Wv(e.object)), t.push(...Wv(e.property))), t);
}
function XL(e) {
  return e.object.type === "MemberExpression" ? XL(e.object) : e.object.name === "datum";
}
function VL(e) {
  const t = $w(e), n = /* @__PURE__ */ new Set();
  return t.visit((i) => {
    i.type === "MemberExpression" && XL(i) && n.add(Wv(i).slice(1).join("."));
  }), n;
}
class Cl extends Ne {
  clone() {
    return new Cl(null, this.model, ae(this.filter));
  }
  constructor(t, n, i) {
    super(t), this.model = n, this.filter = i, this.expr = rg(this.model, this.filter, this), this._dependentFields = VL(this.expr);
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
}
function Wue(e, t) {
  var r;
  const n = {}, i = e.config.selection;
  if (!t || !t.length)
    return n;
  for (const o of t) {
    const a = We(o.name), s = o.select, u = Y(s) ? s : s.type, l = K(s) ? ae(s) : { type: u }, c = i[u];
    for (const h in c)
      h === "fields" || h === "encodings" || (h === "mark" && (l[h] = { ...c[h], ...l[h] }), (l[h] === void 0 || l[h] === !0) && (l[h] = ae((r = c[h]) != null ? r : l[h])));
    const f = n[a] = {
      ...l,
      name: a,
      type: u,
      init: o.value,
      bind: o.bind,
      events: Y(l.on) ? pa(l.on, "scope") : X(ae(l.on))
    }, d = ae(o);
    for (const h of Qm)
      h.defined(f) && h.parse && h.parse(e, f, d);
  }
  return n;
}
function KL(e, t, n, i = "datum") {
  const r = Y(t) ? t : t.param, o = We(r), a = W(o + Ss);
  let s;
  try {
    s = e.getSelectionComponent(o, r);
  } catch {
    return `!!${o}`;
  }
  if (s.project.timeUnit) {
    const d = n != null ? n : e.component.data.raw, h = s.project.timeUnit.clone();
    d.parent ? h.insertAsParentOf(d) : d.parent = h;
  }
  const u = s.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(", l = s.resolve === "global" ? ")" : `, ${W(s.resolve)})`, c = `${u}${a}, ${i}${l}`, f = `length(data(${a}))`;
  return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`;
}
function JL(e, t, n) {
  const i = We(t), r = n.encoding;
  let o = n.field, a;
  try {
    a = e.getSelectionComponent(i, t);
  } catch {
    return i;
  }
  if (!r && !o)
    o = a.project.items[0].field, a.project.items.length > 1 && U(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${W(o)}.`);
  else if (r && !o) {
    const s = a.project.items.filter((u) => u.channel === r);
    !s.length || s.length > 1 ? (o = a.project.items[0].field, U((s.length ? "Multiple " : "No ") + `matching ${W(r)} encoding found for selection ${W(n.param)}. Using "field": ${W(o)}.`)) : o = s[0].field;
  }
  return `${a.name}[${W(ri(o))}]`;
}
function Gue(e, t) {
  var n;
  for (const [i, r] of na((n = e.component.selection) != null ? n : {})) {
    const o = e.getName(`lookup_${i}`);
    e.component.data.outputNodes[o] = r.materialized = new rn(new Cl(t, e, { param: i }), o, Ie.Lookup, e.component.data.outputNodeRefCounts);
  }
}
function rg(e, t, n) {
  return jc(t, (i) => Y(i) ? i : Eoe(i) ? KL(e, i, n) : p6(i));
}
function Hue(e, t) {
  if (!!e)
    return P(e) && !ko(e) ? e.map((n) => qE(n, t)).join(", ") : e;
}
function M1(e, t, n, i) {
  var a, s, u;
  var r, o;
  (a = e.encode) != null || (e.encode = {}), (s = (r = e.encode)[t]) != null || (r[t] = {}), (u = (o = e.encode[t]).update) != null || (o.update = {}), e.encode[t].update[n] = i;
}
function kc(e, t, n, i = { header: !1 }) {
  var f, d;
  const { disable: r, orient: o, scale: a, labelExpr: s, title: u, zindex: l, ...c } = e.combine();
  if (!r) {
    for (const h in c) {
      const p = Aae[h], g = c[h];
      if (p && p !== t && p !== "both")
        delete c[h];
      else if (cd(g)) {
        const { condition: m, ...y } = g, v = X(m), b = qk[h];
        if (b) {
          const { vgProp: x, part: E } = b, _ = [
            ...v.map((w) => {
              const { test: S, ...C } = w;
              return {
                test: rg(null, S),
                ...C
              };
            }),
            y
          ];
          M1(c, E, x, _), delete c[h];
        } else if (b === null) {
          const x = {
            signal: v.map((E) => {
              const { test: _, ...w } = E;
              return `${rg(null, _)} ? ${kk(w)} : `;
            }).join("") + kk(y)
          };
          c[h] = x;
        }
      } else if (Z(g)) {
        const m = qk[h];
        if (m) {
          const { vgProp: y, part: v } = m;
          M1(c, v, y, g), delete c[h];
        }
      }
      me(["labelAlign", "labelBaseline"], h) && c[h] === null && delete c[h];
    }
    if (t === "grid") {
      if (!c.grid)
        return;
      if (c.encode) {
        const { grid: h } = c.encode;
        c.encode = {
          ...h ? { grid: h } : {}
        }, De(c.encode) && delete c.encode;
      }
      return {
        scale: a,
        orient: o,
        ...c,
        domain: !1,
        labels: !1,
        aria: !1,
        maxExtent: 0,
        minExtent: 0,
        ticks: !1,
        zindex: tt(l, 0)
      };
    } else {
      if (!i.header && e.mainExtracted)
        return;
      if (s !== void 0) {
        let p = s;
        ((d = (f = c.encode) == null ? void 0 : f.labels) == null ? void 0 : d.update) && Z(c.encode.labels.update.text) && (p = ys(s, "datum.label", c.encode.labels.update.text.signal)), M1(c, "labels", "text", { signal: p });
      }
      if (c.labelAlign === null && delete c.labelAlign, c.encode) {
        for (const p of G6)
          e.hasAxisPart(p) || delete c.encode[p];
        De(c.encode) && delete c.encode;
      }
      const h = Hue(u, n);
      return {
        scale: a,
        orient: o,
        grid: !1,
        ...h ? { title: h } : {},
        ...c,
        ...n.aria === !1 ? { aria: !1 } : {},
        zindex: tt(l, 0)
      };
    }
  }
}
function QL(e) {
  const { axes: t } = e.component, n = [];
  for (const i of Or)
    if (t[i]) {
      for (const r of t[i])
        if (!r.get("disable") && !r.get("gridScale")) {
          const o = i === "x" ? "height" : "width", a = e.getSizeSignalRef(o).signal;
          o !== a && n.push({
            name: o,
            update: a
          });
        }
    }
  return n;
}
function Yue(e, t) {
  const { x: n = [], y: i = [] } = e;
  return [
    ...n.map((r) => kc(r, "grid", t)),
    ...i.map((r) => kc(r, "grid", t)),
    ...n.map((r) => kc(r, "main", t)),
    ...i.map((r) => kc(r, "main", t))
  ].filter((r) => r);
}
function pC(e, t, n, i) {
  return Object.assign.apply(null, [
    {},
    ...e.map((r) => {
      if (r === "axisOrient") {
        const o = n === "x" ? "bottom" : "left", a = t[n === "x" ? "axisBottom" : "axisLeft"] || {}, s = t[n === "x" ? "axisTop" : "axisRight"] || {}, u = /* @__PURE__ */ new Set([...B(a), ...B(s)]), l = {};
        for (const c of u.values())
          l[c] = {
            signal: `${i.signal} === "${o}" ? ${Ai(a[c])} : ${Ai(s[c])}`
          };
        return l;
      }
      return t[r];
    })
  ]);
}
function Xue(e, t, n, i) {
  const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : v6(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [], o = e === "x" ? "axisX" : "axisY", a = Z(n) ? "axisOrient" : `axis${td(n)}`, s = [
    ...r,
    ...r.map((l) => o + l.substr(4))
  ], u = ["axis", a, o];
  return {
    vlOnlyAxisConfig: pC(s, i, e, n),
    vgAxisConfig: pC(u, i, e, n),
    axisConfigStyle: Vue([...u, ...s], i)
  };
}
function Vue(e, t) {
  var i;
  const n = [{}];
  for (const r of e) {
    let o = (i = t[r]) == null ? void 0 : i.style;
    if (o) {
      o = X(o);
      for (const a of o)
        n.push(t.style[a]);
    }
  }
  return Object.assign.apply(null, n);
}
function Gv(e, t, n, i = {}) {
  var o;
  const r = HR(e, n, t);
  if (r !== void 0)
    return {
      configFrom: "style",
      configValue: r
    };
  for (const a of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
    if (((o = i[a]) == null ? void 0 : o[e]) !== void 0)
      return { configFrom: a, configValue: i[a][e] };
  return {};
}
const gC = {
  scale: ({ model: e, channel: t }) => e.scaleName(t),
  format: ({ format: e }) => e,
  formatType: ({ formatType: e }) => e,
  grid: ({ fieldOrDatumDef: e, axis: t, scaleType: n }) => {
    var i;
    return (i = t.grid) != null ? i : Kue(n, e);
  },
  gridScale: ({ model: e, channel: t }) => Jue(e, t),
  labelAlign: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelAlign || e4(t, n, i),
  labelAngle: ({ labelAngle: e }) => e,
  labelBaseline: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelBaseline || ZL(t, n, i),
  labelFlush: ({ axis: e, fieldOrDatumDef: t, channel: n }) => {
    var i;
    return (i = e.labelFlush) != null ? i : Zue(t.type, n);
  },
  labelOverlap: ({ axis: e, fieldOrDatumDef: t, scaleType: n }) => {
    var i;
    return (i = e.labelOverlap) != null ? i : ele(t.type, n, q(t) && !!t.timeUnit, q(t) ? t.sort : void 0);
  },
  orient: ({ orient: e }) => e,
  tickCount: ({ channel: e, model: t, axis: n, fieldOrDatumDef: i, scaleType: r }) => {
    var s;
    const o = e === "x" ? "width" : e === "y" ? "height" : void 0, a = o ? t.getSizeSignalRef(o) : void 0;
    return (s = n.tickCount) != null ? s : nle({ fieldOrDatumDef: i, scaleType: r, size: a, values: n.values });
  },
  tickMinStep: ile,
  title: ({ axis: e, model: t, channel: n }) => {
    if (e.title !== void 0)
      return e.title;
    const i = t4(t, n);
    if (i !== void 0)
      return i;
    const r = t.typedFieldDef(n), o = n === "x" ? "x2" : "y2", a = t.fieldDef(o);
    return XR(r ? [jk(r)] : [], q(a) ? [jk(a)] : []);
  },
  values: ({ axis: e, fieldOrDatumDef: t }) => rle(e, t),
  zindex: ({ axis: e, fieldOrDatumDef: t, mark: n }) => {
    var i;
    return (i = e.zindex) != null ? i : ole(n, t);
  }
};
function Kue(e, t) {
  return !wt(e) && q(t) && !ze(t == null ? void 0 : t.bin) && !_t(t == null ? void 0 : t.bin);
}
function Jue(e, t) {
  const n = t === "x" ? "y" : "x";
  if (e.getScaleComponent(n))
    return e.scaleName(n);
}
function Que(e, t, n, i, r) {
  const o = t == null ? void 0 : t.labelAngle;
  if (o !== void 0)
    return Z(o) ? o : yf(o);
  {
    const { configValue: a } = Gv("labelAngle", i, t == null ? void 0 : t.style, r);
    return a !== void 0 ? yf(a) : n === Ge && me([TE, ME], e.type) && !(q(e) && e.timeUnit) ? 270 : void 0;
  }
}
function Hv(e) {
  return `(((${e.signal} % 360) + 360) % 360)`;
}
function ZL(e, t, n, i) {
  if (e !== void 0)
    if (n === "x") {
      if (Z(e)) {
        const r = Hv(e), o = Z(t) ? `(${t.signal} === "top")` : t === "top";
        return {
          signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${o} ? "bottom" : "top"`
        };
      }
      if (45 < e && e < 135 || 225 < e && e < 315)
        return "middle";
      if (Z(t)) {
        const r = e <= 45 || 315 <= e ? "===" : "!==";
        return { signal: `${t.signal} ${r} "top" ? "bottom" : "top"` };
      }
      return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top";
    } else {
      if (Z(e)) {
        const r = Hv(e), o = Z(t) ? `(${t.signal} === "left")` : t === "left";
        return {
          signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i ? '"middle"' : "null"} : (45 <= ${r} && ${r} <= 135) === ${o} ? "top" : "bottom"`
        };
      }
      if (e <= 45 || 315 <= e || 135 <= e && e <= 225)
        return i ? "middle" : null;
      if (Z(t)) {
        const r = 45 <= e && e <= 135 ? "===" : "!==";
        return { signal: `${t.signal} ${r} "left" ? "top" : "bottom"` };
      }
      return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom";
    }
}
function e4(e, t, n) {
  if (e === void 0)
    return;
  const i = n === "x", r = i ? 0 : 90, o = i ? "bottom" : "left";
  if (Z(e)) {
    const a = Hv(e), s = Z(t) ? `(${t.signal} === "${o}")` : t === o;
    return {
      signal: `(${r ? `(${a} + 90)` : a} % 180 === 0) ? ${i ? null : '"center"'} :(${r} < ${a} && ${a} < ${180 + r}) === ${s} ? "left" : "right"`
    };
  }
  if ((e + r) % 180 === 0)
    return i ? null : "center";
  if (Z(t)) {
    const a = r < e && e < 180 + r ? "===" : "!==";
    return {
      signal: `${`${t.signal} ${a} "${o}"`} ? "left" : "right"`
    };
  }
  return (r < e && e < 180 + r) == (t === o) ? "left" : "right";
}
function Zue(e, t) {
  if (t === "x" && me(["quantitative", "temporal"], e))
    return !0;
}
function ele(e, t, n, i) {
  if (n && !K(i) || e !== "nominal" && e !== "ordinal")
    return t === "log" || t === "symlog" ? "greedy" : !0;
}
function tle(e) {
  return e === "x" ? "bottom" : "left";
}
function nle({ fieldOrDatumDef: e, scaleType: t, size: n, values: i }) {
  var r;
  if (!i && !wt(t) && t !== "log") {
    if (q(e)) {
      if (ze(e.bin))
        return { signal: `ceil(${n.signal}/10)` };
      if (e.timeUnit && me(["month", "hours", "day", "quarter"], (r = vt(e.timeUnit)) == null ? void 0 : r.unit))
        return;
    }
    return { signal: `ceil(${n.signal}/40)` };
  }
}
function ile({ format: e, fieldOrDatumDef: t }) {
  if (e === "d")
    return 1;
  if (q(t)) {
    const { timeUnit: n } = t;
    if (n) {
      const i = f6(n);
      if (i)
        return { signal: i };
    }
  }
}
function t4(e, t) {
  const n = t === "x" ? "x2" : "y2", i = e.fieldDef(t), r = e.fieldDef(n), o = i ? i.title : void 0, a = r ? r.title : void 0;
  if (o && a)
    return VR(o, a);
  if (o)
    return o;
  if (a)
    return a;
  if (o !== void 0)
    return o;
  if (a !== void 0)
    return a;
}
function rle(e, t) {
  const n = e.values;
  if (P(n))
    return W6(t, n);
  if (Z(n))
    return n;
}
function ole(e, t) {
  return e === "rect" && Kp(t) ? 1 : 0;
}
class rl extends Ne {
  clone() {
    return new rl(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this._dependentFields = VL(this.transform.calculate);
  }
  static parseAllForSortIndex(t, n) {
    return n.forEachFieldDef((i, r) => {
      if (!!js(i) && N6(i.sort)) {
        const { field: o, timeUnit: a } = i, s = i.sort, u = s.map((l, c) => `${p6({ field: o, timeUnit: a, equal: l })} ? ${c} : `).join("") + s.length;
        t = new rl(t, {
          calculate: u,
          as: ol(i, r, { forAs: !0 })
        });
      }
    }), t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${ge(this.transform)}`;
  }
}
function ol(e, t, n) {
  return H(e, { prefix: t, suffix: "sort_index", ...n != null ? n : {} });
}
function Zm(e, t) {
  return me(["top", "bottom"], t) ? "column" : me(["left", "right"], t) || e === "row" ? "row" : "column";
}
function al(e, t, n, i) {
  const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
  return tt((t || {})[e], r[e], n.header[e]);
}
function e0(e, t, n, i) {
  const r = {};
  for (const o of e) {
    const a = al(o, t || {}, n, i);
    a !== void 0 && (r[o] = a);
  }
  return r;
}
const c_ = ["row", "column"], f_ = ["header", "footer"];
function ale(e, t) {
  const n = e.component.layoutHeaders[t].title, i = e.config ? e.config : void 0, r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0, { titleAnchor: o, titleAngle: a, titleOrient: s } = e0(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t), u = Zm(t, s), l = yf(a);
  return {
    name: `${t}-title`,
    type: "group",
    role: `${u}-title`,
    title: {
      text: n,
      ...t === "row" ? { orient: "left" } : {},
      style: "guide-title",
      ...i4(l, u),
      ...n4(u, l, o),
      ...r4(i, r, t, Yae, sL)
    }
  };
}
function n4(e, t, n = "middle") {
  switch (n) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const i = e4(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
  return i ? { align: i } : {};
}
function i4(e, t) {
  const n = ZL(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
  return n ? { baseline: n } : {};
}
function sle(e, t) {
  const n = e.component.layoutHeaders[t], i = [];
  for (const r of f_)
    if (n[r])
      for (const o of n[r]) {
        const a = lle(e, t, r, n, o);
        a != null && i.push(a);
      }
  return i;
}
function ule(e, t) {
  var i;
  const { sort: n } = e;
  return cr(n) ? {
    field: H(n, { expr: "datum" }),
    order: (i = n.order) != null ? i : "ascending"
  } : P(n) ? {
    field: ol(e, t, { expr: "datum" }),
    order: "ascending"
  } : {
    field: H(e, { expr: "datum" }),
    order: n != null ? n : "ascending"
  };
}
function Yv(e, t, n) {
  const { format: i, formatType: r, labelAngle: o, labelAnchor: a, labelOrient: s, labelExpr: u } = e0(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), l = zE({
    fieldOrDatumDef: e,
    format: i,
    formatType: r,
    expr: "parent",
    config: n
  }).signal, c = Zm(t, s);
  return {
    text: {
      signal: u ? ys(ys(u, "datum.label", l), "datum.value", H(e, { expr: "parent" })) : l
    },
    ...t === "row" ? { orient: "left" } : {},
    style: "guide-label",
    frame: "group",
    ...i4(o, c),
    ...n4(c, o, a),
    ...r4(n, e, t, Xae, uL)
  };
}
function lle(e, t, n, i, r) {
  if (r) {
    let o = null;
    const { facetFieldDef: a } = i, s = e.config ? e.config : void 0;
    if (a && r.labels) {
      const { labelOrient: f } = e0(["labelOrient"], a.header, s, t);
      (t === "row" && !me(["top", "bottom"], f) || t === "column" && !me(["left", "right"], f)) && (o = Yv(a, t, s));
    }
    const u = Ti(e) && !sd(e.facet), l = r.axes, c = (l == null ? void 0 : l.length) > 0;
    if (o || c) {
      const f = t === "row" ? "height" : "width";
      return {
        name: e.getName(`${t}_${n}`),
        type: "group",
        role: `${t}-${n}`,
        ...i.facetFieldDef ? {
          from: { data: e.getName(`${t}_domain`) },
          sort: ule(a, t)
        } : {},
        ...c && u ? {
          from: { data: e.getName(`facet_domain_${t}`) }
        } : {},
        ...o ? { title: o } : {},
        ...r.sizeSignal ? {
          encode: {
            update: {
              [f]: r.sizeSignal
            }
          }
        } : {},
        ...c ? { axes: l } : {}
      };
    }
  }
  return null;
}
const cle = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function fle(e, t) {
  return cle[t][e];
}
function dle(e, t) {
  const n = {};
  for (const i of Jn) {
    const r = e[i];
    if (r != null && r.facetFieldDef) {
      const { titleAnchor: o, titleOrient: a } = e0(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), s = Zm(i, a), u = fle(o, s);
      u !== void 0 && (n[s] = u);
    }
  }
  return De(n) ? void 0 : n;
}
function r4(e, t, n, i, r) {
  const o = {};
  for (const a of i) {
    if (!r[a])
      continue;
    const s = al(a, t == null ? void 0 : t.header, e, n);
    s !== void 0 && (o[r[a]] = s);
  }
  return o;
}
function d_(e) {
  return [
    ...Gd(e, "width"),
    ...Gd(e, "height"),
    ...Gd(e, "childWidth"),
    ...Gd(e, "childHeight")
  ];
}
function Gd(e, t) {
  const n = t === "width" ? "x" : "y", i = e.component.layoutSize.get(t);
  if (!i || i === "merged")
    return [];
  const r = e.getSizeSignalRef(t).signal;
  if (i === "step") {
    const o = e.getScaleComponent(n);
    if (o) {
      const a = o.get("type"), s = o.get("range");
      if (wt(a) && wa(s)) {
        const u = e.scaleName(n);
        return Ti(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [mC(u, s)] : [
          mC(u, s),
          {
            name: r,
            update: o4(u, o, `domain('${u}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (i == "container") {
    const o = r.endsWith("width"), a = o ? "containerSize()[0]" : "containerSize()[1]", s = zv(e.config.view, o ? "width" : "height"), u = `isFinite(${a}) ? ${a} : ${s}`;
    return [{ name: r, init: u, on: [{ update: u, events: "window:resize" }] }];
  } else
    return [
      {
        name: r,
        value: i
      }
    ];
}
function mC(e, t) {
  const n = `${e}_step`;
  return Z(t.step) ? { name: n, update: t.step.signal } : { name: n, value: t.step };
}
function o4(e, t, n) {
  const i = t.get("type"), r = t.get("padding"), o = tt(t.get("paddingOuter"), r);
  let a = t.get("paddingInner");
  return a = i === "band" ? a !== void 0 ? a : r : 1, `bandspace(${n}, ${Ai(a)}, ${Ai(o)}) * ${e}_step`;
}
function a4(e) {
  return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e;
}
function s4(e, t) {
  return B(e).reduce((n, i) => {
    const r = e[i];
    return {
      ...n,
      ...kl(t, r, i, (o) => je(o.value))
    };
  }, {});
}
function u4(e, t) {
  if (Ti(t))
    return e === "theta" ? "independent" : "shared";
  if (Tl(t))
    return "shared";
  if (b_(t))
    return xt(e) || e === "theta" || e === "radius" ? "independent" : "shared";
  throw new Error("invalid model type for resolve");
}
function h_(e, t) {
  const n = e.scale[t], i = xt(t) ? "axis" : "legend";
  return n === "independent" ? (e[i][t] === "shared" && U(Wre(t)), "independent") : e[i][t] || "shared";
}
const hle = {
  ...Jae,
  disable: 1,
  labelExpr: 1,
  selections: 1,
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  encode: 1
}, l4 = B(hle);
class ple extends vo {
}
const yC = {
  symbols: gle,
  gradient: mle,
  labels: yle,
  entries: vle
};
function gle(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r, legendType: o }) {
  var m, y, v, b, x, E, _, w;
  if (o !== "symbol")
    return;
  const { markDef: a, encoding: s, config: u, mark: l } = n, c = a.filled && l !== "trail";
  let f = {
    ...ere({}, n, Yoe),
    ...RL(n, { filled: c })
  };
  const d = (m = r.get("symbolOpacity")) != null ? m : u.legend.symbolOpacity, h = (y = r.get("symbolFillColor")) != null ? y : u.legend.symbolFillColor, p = (v = r.get("symbolStrokeColor")) != null ? v : u.legend.symbolStrokeColor, g = d === void 0 ? (b = c4(s.opacity)) != null ? b : a.opacity : void 0;
  if (f.fill) {
    if (i === "fill" || c && i === $n)
      delete f.fill;
    else if (f.fill.field)
      h ? delete f.fill : (f.fill = je((x = u.legend.symbolBaseFillColor) != null ? x : "black"), f.fillOpacity = je(g != null ? g : 1));
    else if (P(f.fill)) {
      const S = (w = (_ = Xv((E = s.fill) != null ? E : s.color)) != null ? _ : a.fill) != null ? w : c && a.color;
      S && (f.fill = je(S));
    }
  }
  if (f.stroke) {
    if (i === "stroke" || !c && i === $n)
      delete f.stroke;
    else if (f.stroke.field || p)
      delete f.stroke;
    else if (P(f.stroke)) {
      const S = tt(Xv(s.stroke || s.color), a.stroke, c ? a.color : void 0);
      S && (f.stroke = { value: S });
    }
  }
  if (i !== go) {
    const S = q(t) && d4(n, r, t);
    S ? f.opacity = [
      { test: S, ...je(g != null ? g : 1) },
      je(u.legend.unselectedOpacity)
    ] : g && (f.opacity = je(g));
  }
  return f = { ...f, ...e }, De(f) ? void 0 : f;
}
function mle(e, { model: t, legendType: n, legendCmpt: i }) {
  var c;
  if (n !== "gradient")
    return;
  const { config: r, markDef: o, encoding: a } = t;
  let s = {};
  const l = ((c = i.get("gradientOpacity")) != null ? c : r.legend.gradientOpacity) === void 0 ? c4(a.opacity) || o.opacity : void 0;
  return l && (s.opacity = je(l)), s = { ...s, ...e }, De(s) ? void 0 : s;
}
function yle(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r }) {
  const o = n.legend(i) || {}, a = n.config, s = q(t) ? d4(n, r, t) : void 0, u = s ? [{ test: s, value: 1 }, { value: a.legend.unselectedOpacity }] : void 0, { format: l, formatType: c } = o;
  let f;
  Es(c) ? f = ki({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: l,
    formatType: c,
    config: a
  }) : l === void 0 && c === void 0 && a.customFormatTypes && (t.type === "quantitative" && a.numberFormatType ? f = ki({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: a.numberFormat,
    formatType: a.numberFormatType,
    config: a
  }) : t.type === "temporal" && a.timeFormatType && q(t) && t.timeUnit === void 0 && (f = ki({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: a.timeFormat,
    formatType: a.timeFormatType,
    config: a
  })));
  const d = {
    ...u ? { opacity: u } : {},
    ...f ? { text: f } : {},
    ...e
  };
  return De(d) ? void 0 : d;
}
function vle(e, { legendCmpt: t }) {
  const n = t.get("selections");
  return n != null && n.length ? { ...e, fill: { value: "transparent" } } : e;
}
function c4(e) {
  return f4(e, (t, n) => Math.max(t, n.value));
}
function Xv(e) {
  return f4(e, (t, n) => tt(t, n.value));
}
function f4(e, t) {
  if (hae(e))
    return X(e.condition).reduce(t, e.value);
  if (Ri(e))
    return e.value;
}
function d4(e, t, n) {
  const i = t.get("selections");
  if (!(i != null && i.length))
    return;
  const r = W(n.field);
  return i.map((o) => `(!length(data(${W(We(o) + Ss)})) || (${o}[${r}] && indexof(${o}[${r}], datum.value) >= 0))`).join(" || ");
}
const vC = {
  direction: ({ direction: e }) => e,
  format: ({ fieldOrDatumDef: e, legend: t, config: n }) => {
    const { format: i, formatType: r } = t;
    return F6(e, e.type, i, r, n, !1);
  },
  formatType: ({ legend: e, fieldOrDatumDef: t, scaleType: n }) => {
    const { formatType: i } = e;
    return M6(i, t, n);
  },
  gradientLength: (e) => {
    var i, r;
    const { legend: t, legendConfig: n } = e;
    return (r = (i = t.gradientLength) != null ? i : n.gradientLength) != null ? r : Ale(e);
  },
  labelOverlap: ({ legend: e, legendConfig: t, scaleType: n }) => {
    var i, r;
    return (r = (i = e.labelOverlap) != null ? i : t.labelOverlap) != null ? r : $le(n);
  },
  symbolType: ({ legend: e, markDef: t, channel: n, encoding: i }) => {
    var r;
    return (r = e.symbolType) != null ? r : xle(t.type, n, i.shape, t.shape);
  },
  title: ({ fieldOrDatumDef: e, config: t }) => Eu(e, t, { allowDisabling: !0 }),
  type: ({ legendType: e, scaleType: t, channel: n }) => {
    if (wu(n) && $i(t)) {
      if (e === "gradient")
        return;
    } else if (e === "symbol")
      return;
    return e;
  },
  values: ({ fieldOrDatumDef: e, legend: t }) => ble(t, e)
};
function ble(e, t) {
  const n = e.values;
  if (P(n))
    return W6(t, n);
  if (Z(n))
    return n;
}
function xle(e, t, n, i) {
  var r;
  if (t !== "shape") {
    const o = (r = Xv(n)) != null ? r : i;
    if (o)
      return o;
  }
  switch (e) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function wle(e) {
  const { legend: t } = e;
  return tt(t.type, Ele(e));
}
function Ele({ channel: e, timeUnit: t, scaleType: n }) {
  if (wu(e)) {
    if (me(["quarter", "month", "day"], t))
      return "symbol";
    if ($i(n))
      return "gradient";
  }
  return "symbol";
}
function _le({ legendConfig: e, legendType: t, orient: n, legend: i }) {
  var r, o;
  return (o = (r = i.direction) != null ? r : e[t ? "gradientDirection" : "symbolDirection"]) != null ? o : Sle(n, t);
}
function Sle(e, t) {
  switch (e) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return;
    default:
      return t === "gradient" ? "horizontal" : void 0;
  }
}
function Ale({ legendConfig: e, model: t, direction: n, orient: i, scaleType: r }) {
  const { gradientHorizontalMaxLength: o, gradientHorizontalMinLength: a, gradientVerticalMaxLength: s, gradientVerticalMinLength: u } = e;
  if ($i(r))
    return n === "horizontal" ? i === "top" || i === "bottom" ? bC(t, "width", a, o) : a : bC(t, "height", u, s);
}
function bC(e, t, n, i) {
  return { signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${i})` };
}
function $le(e) {
  if (me(["quantile", "threshold", "log", "symlog"], e))
    return "greedy";
}
function h4(e) {
  const t = Je(e) ? kle(e) : Tle(e);
  return e.component.legends = t, t;
}
function kle(e) {
  const { encoding: t } = e, n = {};
  for (const i of [$n, ...cL]) {
    const r = st(t[i]);
    !r || !e.getScaleComponent(i) || i === kn && q(r) && r.type === $l || (n[i] = Mle(e, i));
  }
  return n;
}
function Cle(e, t) {
  const n = e.scaleName(t);
  if (e.mark === "trail") {
    if (t === "color")
      return { stroke: n };
    if (t === "size")
      return { strokeWidth: n };
  }
  return t === "color" ? e.markDef.filled ? { fill: n } : { stroke: n } : { [t]: n };
}
function Fle(e, t, n, i) {
  switch (t) {
    case "disable":
      return n !== void 0;
    case "values":
      return !!(n != null && n.values);
    case "title":
      if (t === "title" && e === (i == null ? void 0 : i.title))
        return !0;
  }
  return e === (n || {})[t];
}
function Mle(e, t) {
  var x, E, _;
  let n = e.legend(t);
  const { markDef: i, encoding: r, config: o } = e, a = o.legend, s = new ple({}, Cle(e, t));
  zue(e, t, s);
  const u = n !== void 0 ? !n : a.disable;
  if (s.set("disable", u, n !== void 0), u)
    return s;
  n = n || {};
  const l = e.getScaleComponent(t).get("type"), c = st(r[t]), f = q(c) ? (x = vt(c.timeUnit)) == null ? void 0 : x.unit : void 0, d = n.orient || o.legend.orient || "right", h = wle({ legend: n, channel: t, timeUnit: f, scaleType: l }), p = _le({ legend: n, legendType: h, orient: d, legendConfig: a }), g = {
    legend: n,
    channel: t,
    model: e,
    markDef: i,
    encoding: r,
    fieldOrDatumDef: c,
    legendConfig: a,
    config: o,
    scaleType: l,
    orient: d,
    legendType: h,
    direction: p
  };
  for (const w of l4) {
    if (h === "gradient" && w.startsWith("symbol") || h === "symbol" && w.startsWith("gradient"))
      continue;
    const S = w in vC ? vC[w](g) : n[w];
    if (S !== void 0) {
      const C = Fle(S, w, n, e.fieldDef(t));
      (C || o.legend[w] === void 0) && s.set(w, S, C);
    }
  }
  const m = (E = n == null ? void 0 : n.encoding) != null ? E : {}, y = s.get("selections"), v = {}, b = { fieldOrDatumDef: c, model: e, channel: t, legendCmpt: s, legendType: h };
  for (const w of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const S = s4((_ = m[w]) != null ? _ : {}, e), C = w in yC ? yC[w](S, b) : S;
    C !== void 0 && !De(C) && (v[w] = {
      ...(y == null ? void 0 : y.length) && q(c) ? { name: `${We(c.field)}_legend_${w}` } : {},
      ...y != null && y.length ? { interactive: !!y } : {},
      update: C
    });
  }
  return De(v) || s.set("encode", v, !!(n != null && n.encoding)), s;
}
function Tle(e) {
  const { legends: t, resolve: n } = e.component;
  for (const i of e.children) {
    h4(i);
    for (const r of B(i.component.legends))
      n.legend[r] = h_(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = p4(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]));
  }
  for (const i of B(t))
    for (const r of e.children)
      !r.component.legends[i] || n.legend[i] === "shared" && delete r.component.legends[i];
  return t;
}
function p4(e, t) {
  var o, a, s, u;
  if (!e)
    return t.clone();
  const n = e.getWithExplicit("orient"), i = t.getWithExplicit("orient");
  if (n.explicit && i.explicit && n.value !== i.value)
    return;
  let r = !1;
  for (const l of l4) {
    const c = ra(
      e.getWithExplicit(l),
      t.getWithExplicit(l),
      l,
      "legend",
      (f, d) => {
        switch (l) {
          case "symbolType":
            return Ole(f, d);
          case "title":
            return KR(f, d);
          case "type":
            return r = !0, Nn("symbol");
        }
        return Km(f, d, l, "legend");
      }
    );
    e.setWithExplicit(l, c);
  }
  return r && ((a = (o = e.implicit) == null ? void 0 : o.encode) != null && a.gradient && Wp(e.implicit, ["encode", "gradient"]), (u = (s = e.explicit) == null ? void 0 : s.encode) != null && u.gradient && Wp(e.explicit, ["encode", "gradient"])), e;
}
function Ole(e, t) {
  return t.value === "circle" ? t : e;
}
function Nle(e, t, n, i) {
  var a, s, u;
  var r, o;
  (a = e.encode) != null || (e.encode = {}), (s = (r = e.encode)[t]) != null || (r[t] = {}), (u = (o = e.encode[t]).update) != null || (o.update = {}), e.encode[t].update[n] = i;
}
function g4(e) {
  const t = e.component.legends, n = {};
  for (const r of B(t)) {
    const o = e.getScaleComponent(r), a = Pe(o.get("domains"));
    if (n[a])
      for (const s of n[a])
        p4(s, t[r]) || n[a].push(t[r]);
    else
      n[a] = [t[r].clone()];
  }
  return kt(n).flat().map((r) => Dle(r, e.config)).filter((r) => r !== void 0);
}
function Dle(e, t) {
  var a, s, u;
  const { disable: n, labelExpr: i, selections: r, ...o } = e.combine();
  if (!n) {
    if (t.aria === !1 && o.aria == null && (o.aria = !1), (a = o.encode) != null && a.symbols) {
      const l = o.encode.symbols.update;
      l.fill && l.fill.value !== "transparent" && !l.stroke && !o.stroke && (l.stroke = { value: "transparent" });
      for (const c of cL)
        o[c] && delete l[c];
    }
    if (o.title || delete o.title, i !== void 0) {
      let l = i;
      ((u = (s = o.encode) == null ? void 0 : s.labels) == null ? void 0 : u.update) && Z(o.encode.labels.update.text) && (l = ys(i, "datum.label", o.encode.labels.update.text.signal)), Nle(o, "labels", "text", { signal: l });
    }
    return o;
  }
}
function Rle(e) {
  return Tl(e) || b_(e) ? Lle(e) : m4(e);
}
function Lle(e) {
  return e.children.reduce((t, n) => t.concat(n.assembleProjections()), m4(e));
}
function m4(e) {
  const t = e.component.projection;
  if (!t || t.merged)
    return [];
  const n = t.combine(), { name: i } = n;
  if (t.data) {
    const r = {
      signal: `[${t.size.map((a) => a.signal).join(", ")}]`
    }, o = t.data.reduce((a, s) => {
      const u = Z(s) ? s.signal : `data('${e.lookupDataSource(s)}')`;
      return me(a, u) || a.push(u), a;
    }, []);
    if (o.length <= 0)
      throw new Error("Projection's fit didn't find any data sources");
    return [
      {
        name: i,
        size: r,
        fit: {
          signal: o.length > 1 ? `[${o.join(", ")}]` : o[0]
        },
        ...n
      }
    ];
  } else
    return [
      {
        name: i,
        translate: { signal: "[width / 2, height / 2]" },
        ...n
      }
    ];
}
const Ile = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
class y4 extends vo {
  constructor(t, n, i, r) {
    super(
      { ...n },
      { name: t }
    ), this.specifiedProjection = n, this.size = i, this.data = r, this.merged = !1;
  }
  get isFit() {
    return !!this.data;
  }
}
function v4(e) {
  e.component.projection = Je(e) ? Ple(e) : jle(e);
}
function Ple(e) {
  var t;
  if (e.hasProjection) {
    const n = pn(e.specifiedProjection), i = !(n && (n.scale != null || n.translate != null)), r = i ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0, o = i ? zle(e) : void 0, a = new y4(e.projectionName(!0), {
      ...(t = pn(e.config.projection)) != null ? t : {},
      ...n != null ? n : {}
    }, r, o);
    return a.get("type") || a.set("type", "equalEarth", !1), a;
  }
}
function zle(e) {
  const t = [], { encoding: n } = e;
  for (const i of [
    [qi, Ui],
    [oi, Wi]
  ])
    (st(n[i[0]]) || st(n[i[1]])) && t.push({
      signal: e.getName(`geojson_${t.length}`)
    });
  return e.channelHasField(kn) && e.typedFieldDef(kn).type === $l && t.push({
    signal: e.getName(`geojson_${t.length}`)
  }), t.length === 0 && t.push(e.requestDataName(Ie.Main)), t;
}
function Ble(e, t) {
  const n = rE(Ile, (r) => !!(!ie(e.explicit, r) && !ie(t.explicit, r) || ie(e.explicit, r) && ie(t.explicit, r) && rr(e.get(r), t.get(r))));
  if (rr(e.size, t.size)) {
    if (n)
      return e;
    if (rr(e.explicit, {}))
      return t;
    if (rr(t.explicit, {}))
      return e;
  }
  return null;
}
function jle(e) {
  if (e.children.length === 0)
    return;
  let t;
  for (const i of e.children)
    v4(i);
  const n = rE(e.children, (i) => {
    const r = i.component.projection;
    if (r)
      if (t) {
        const o = Ble(t, r);
        return o && (t = o), !!o;
      } else
        return t = r, !0;
    else
      return !0;
  });
  if (t && n) {
    const i = e.projectionName(!0), r = new y4(i, t.specifiedProjection, t.size, ae(t.data));
    for (const o of e.children) {
      const a = o.component.projection;
      a && (a.isFit && r.data.push(...o.component.projection.data), o.renameProjection(a.get("name"), i), a.merged = !0);
    }
    return r;
  }
}
function Ule(e, t, n, i) {
  var r, o;
  if (ld(t, n)) {
    const a = Je(e) ? (o = (r = e.axis(n)) != null ? r : e.legend(n)) != null ? o : {} : {}, s = H(t, { expr: "datum" }), u = H(t, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: H(t, { binSuffix: "range", forAs: !0 }),
      formula: ad(s, u, a.format, a.formatType, i)
    };
  }
  return {};
}
function b4(e, t) {
  return `${UR(e)}_${t}`;
}
function qle(e, t) {
  return {
    signal: e.getName(`${t}_bins`),
    extentSignal: e.getName(`${t}_extent`)
  };
}
function p_(e, t, n) {
  var o;
  const i = (o = Wm(n, void 0)) != null ? o : {}, r = b4(i, t);
  return e.getName(`${r}_bins`);
}
function Wle(e) {
  return "as" in e;
}
function xC(e, t, n) {
  let i, r;
  Wle(e) ? i = Y(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [H(e, { forAs: !0 }), H(e, { binSuffix: "end", forAs: !0 })];
  const o = { ...Wm(t, void 0) }, a = b4(o, e.field), { signal: s, extentSignal: u } = qle(n, a);
  if (Nm(o.extent)) {
    const c = o.extent;
    r = JL(n, c.param, c), delete o.extent;
  }
  const l = {
    bin: o,
    field: e.field,
    as: [i],
    ...s ? { signal: s } : {},
    ...u ? { extentSignal: u } : {},
    ...r ? { span: r } : {}
  };
  return { key: a, binComponent: l };
}
class dr extends Ne {
  clone() {
    return new dr(null, ae(this.bins));
  }
  constructor(t, n) {
    super(t), this.bins = n;
  }
  static makeFromEncoding(t, n) {
    const i = n.reduceFieldDef((r, o, a) => {
      if (sn(o) && ze(o.bin)) {
        const { key: s, binComponent: u } = xC(o, o.bin, n);
        r[s] = {
          ...u,
          ...r[s],
          ...Ule(n, o, a, n.config)
        };
      }
      return r;
    }, {});
    return De(i) ? null : new dr(t, i);
  }
  static makeFromTransform(t, n, i) {
    const { key: r, binComponent: o } = xC(n, n.bin, i);
    return new dr(t, {
      [r]: o
    });
  }
  merge(t, n) {
    for (const i of B(t.bins))
      i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = or([...this.bins[i].as, ...t.bins[i].as], ge)) : this.bins[i] = t.bins[i];
    for (const i of t.children)
      t.removeChild(i), i.parent = this;
    t.remove();
  }
  producedFields() {
    return new Set(kt(this.bins).map((t) => t.as).flat(2));
  }
  dependentFields() {
    return new Set(kt(this.bins).map((t) => t.field));
  }
  hash() {
    return `Bin ${ge(this.bins)}`;
  }
  assemble() {
    return kt(this.bins).flatMap((t) => {
      const n = [], [i, ...r] = t.as, { extent: o, ...a } = t.bin, s = {
        type: "bin",
        field: ri(t.field),
        as: i,
        signal: t.signal,
        ...Nm(o) ? { extent: null } : { extent: o },
        ...t.span ? { span: { signal: `span(${t.span})` } } : {},
        ...a
      };
      !o && t.extentSignal && (n.push({
        type: "extent",
        field: ri(t.field),
        signal: t.extentSignal
      }), s.extent = { signal: t.extentSignal }), n.push(s);
      for (const u of r)
        for (let l = 0; l < 2; l++)
          n.push({
            type: "formula",
            expr: H({ field: i[l] }, { expr: "datum" }),
            as: u[l]
          });
      return t.formula && n.push({
        type: "formula",
        expr: t.formula,
        as: t.formulaAs
      }), n;
    });
  }
}
function Gle(e, t, n, i) {
  var o;
  const r = Je(i) ? i.encoding[Tr(t)] : void 0;
  if (sn(n) && Je(i) && L6(n, r, i.markDef, i.config))
    e.add(H(n, {})), e.add(H(n, { suffix: "end" })), n.bin && ld(n, t) && e.add(H(n, { binSuffix: "range" }));
  else if (TR(t)) {
    const a = MR(t);
    e.add(i.getName(a));
  } else
    e.add(H(n));
  return js(n) && Roe((o = n.scale) == null ? void 0 : o.range) && e.add(n.scale.range.field), e;
}
function Hle(e, t) {
  var n;
  for (const i of B(t)) {
    const r = t[i];
    for (const o of B(r))
      i in e ? e[i][o] = /* @__PURE__ */ new Set([...(n = e[i][o]) != null ? n : [], ...r[o]]) : e[i] = { [o]: r[o] };
  }
}
class Mi extends Ne {
  clone() {
    return new Mi(null, new Set(this.dimensions), ae(this.measures));
  }
  constructor(t, n, i) {
    super(t), this.dimensions = n, this.measures = i;
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(t, n) {
    let i = !1;
    n.forEachFieldDef((a) => {
      a.aggregate && (i = !0);
    });
    const r = {}, o = /* @__PURE__ */ new Set();
    return !i || (n.forEachFieldDef((a, s) => {
      var c, f, d, h;
      const { aggregate: u, field: l } = a;
      if (u)
        if (u === "count")
          (c = r["*"]) != null || (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([H(a, { forAs: !0 })]);
        else {
          if (ao(u) || xa(u)) {
            const p = ao(u) ? "argmin" : "argmax", g = u[p];
            (f = r[g]) != null || (r[g] = {}), r[g][p] = /* @__PURE__ */ new Set([H({ op: p, field: g }, { forAs: !0 })]);
          } else
            (d = r[l]) != null || (r[l] = {}), r[l][u] = /* @__PURE__ */ new Set([H(a, { forAs: !0 })]);
          mo(s) && n.scaleDomain(s) === "unaggregated" && ((h = r[l]) != null || (r[l] = {}), r[l].min = /* @__PURE__ */ new Set([H({ field: l, aggregate: "min" }, { forAs: !0 })]), r[l].max = /* @__PURE__ */ new Set([H({ field: l, aggregate: "max" }, { forAs: !0 })]));
        }
      else
        Gle(o, s, a, n);
    }), o.size + B(r).length === 0) ? null : new Mi(t, o, r);
  }
  static makeFromTransform(t, n) {
    var o, a, s;
    const i = /* @__PURE__ */ new Set(), r = {};
    for (const u of n.aggregate) {
      const { op: l, field: c, as: f } = u;
      l && (l === "count" ? ((o = r["*"]) != null || (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([f || H(u, { forAs: !0 })])) : ((a = r[c]) != null || (r[c] = {}), r[c][l] = /* @__PURE__ */ new Set([f || H(u, { forAs: !0 })])));
    }
    for (const u of (s = n.groupby) != null ? s : [])
      i.add(u);
    return i.size + B(r).length === 0 ? null : new Mi(t, i, r);
  }
  merge(t) {
    return ER(this.dimensions, t.dimensions) ? (Hle(this.measures, t.measures), !0) : (aoe("different dimensions, cannot merge"), !1);
  }
  addDimensions(t) {
    t.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...B(this.measures)]);
  }
  producedFields() {
    const t = /* @__PURE__ */ new Set();
    for (const n of B(this.measures))
      for (const i of B(this.measures[n])) {
        const r = this.measures[n][i];
        r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t);
      }
    return t;
  }
  hash() {
    return `Aggregate ${ge({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const t = [], n = [], i = [];
    for (const o of B(this.measures))
      for (const a of B(this.measures[o]))
        for (const s of this.measures[o][a])
          i.push(s), t.push(a), n.push(o === "*" ? null : ri(o));
    return {
      type: "aggregate",
      groupby: [...this.dimensions].map(ri),
      ops: t,
      fields: n,
      as: i
    };
  }
}
class Fl extends Ne {
  constructor(t, n, i, r) {
    super(t), this.model = n, this.name = i, this.data = r;
    for (const o of Jn) {
      const a = n.facet[o];
      if (a) {
        const { bin: s, sort: u } = a;
        this[o] = {
          name: n.getName(`${o}_domain`),
          fields: [H(a), ...ze(s) ? [H(a, { binSuffix: "end" })] : []],
          ...cr(u) ? { sortField: u } : P(u) ? { sortIndexField: ol(a, o) } : {}
        };
      }
    }
    this.childModel = n.child;
  }
  hash() {
    let t = "Facet";
    for (const n of Jn)
      this[n] && (t += ` ${n.charAt(0)}:${ge(this[n])}`);
    return t;
  }
  get fields() {
    var n;
    const t = [];
    for (const i of Jn)
      (n = this[i]) != null && n.fields && t.push(...this[i].fields);
    return t;
  }
  dependentFields() {
    const t = new Set(this.fields);
    for (const n of Jn)
      this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
    return t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const t = {};
    for (const n of Or) {
      const i = this.childModel.component.scales[n];
      if (i && !i.merged) {
        const r = i.get("type"), o = i.get("range");
        if (wt(r) && wa(o)) {
          const a = t0(this.childModel, n), s = v_(a);
          s ? t[n] = s : U(vE(n));
        }
      }
    }
    return t;
  }
  assembleRowColumnHeaderData(t, n, i) {
    const r = { row: "y", column: "x", facet: void 0 }[t], o = [], a = [], s = [];
    r && i && i[r] && (n ? (o.push(`distinct_${i[r]}`), a.push("max")) : (o.push(i[r]), a.push("distinct")), s.push(`distinct_${i[r]}`));
    const { sortField: u, sortIndexField: l } = this[t];
    if (u) {
      const { op: c = Bm, field: f } = u;
      o.push(f), a.push(c), s.push(H(u, { forAs: !0 }));
    } else
      l && (o.push(l), a.push("max"), s.push(l));
    return {
      name: this[t].name,
      source: n != null ? n : this.data,
      transform: [
        {
          type: "aggregate",
          groupby: this[t].fields,
          ...o.length ? {
            fields: o,
            ops: a,
            as: s
          } : {}
        }
      ]
    };
  }
  assembleFacetHeaderData(t) {
    var u, l;
    const { columns: n } = this.model.layout, { layoutHeaders: i } = this.model.component, r = [], o = {};
    for (const c of c_) {
      for (const f of f_) {
        const d = (u = i[c] && i[c][f]) != null ? u : [];
        for (const h of d)
          if (((l = h.axes) == null ? void 0 : l.length) > 0) {
            o[c] = !0;
            break;
          }
      }
      if (o[c]) {
        const f = `length(data("${this.facet.name}"))`, d = c === "row" ? n ? { signal: `ceil(${f} / ${n})` } : 1 : n ? { signal: `min(${f}, ${n})` } : { signal: f };
        r.push({
          name: `${this.facet.name}_${c}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: d
            }
          ]
        });
      }
    }
    const { row: a, column: s } = o;
    return (a || s) && r.unshift(this.assembleRowColumnHeaderData("facet", null, t)), r;
  }
  assemble() {
    var s, u;
    const t = [];
    let n = null;
    const i = this.getChildIndependentFieldsWithStep(), { column: r, row: o, facet: a } = this;
    if (r && o && (i.x || i.y)) {
      n = `cross_${this.column.name}_${this.row.name}`;
      const l = [].concat((s = i.x) != null ? s : [], (u = i.y) != null ? u : []), c = l.map(() => "distinct");
      t.push({
        name: n,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields: l,
            ops: c
          }
        ]
      });
    }
    for (const l of [eo, Zr])
      this[l] && t.push(this.assembleRowColumnHeaderData(l, n, i));
    if (a) {
      const l = this.assembleFacetHeaderData(i);
      l && t.push(...l);
    }
    return t;
  }
}
function wC(e) {
  return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;
}
function Yle(e, t) {
  const n = sE(e);
  if (t === "number")
    return `toNumber(${n})`;
  if (t === "boolean")
    return `toBoolean(${n})`;
  if (t === "string")
    return `toString(${n})`;
  if (t === "date")
    return `toDate(${n})`;
  if (t === "flatten")
    return n;
  if (t.startsWith("date:")) {
    const i = wC(t.slice(5, t.length));
    return `timeParse(${n},'${i}')`;
  } else if (t.startsWith("utc:")) {
    const i = wC(t.slice(4, t.length));
    return `utcParse(${n},'${i}')`;
  } else
    return U(hre(t)), null;
}
function Xle(e) {
  const t = {};
  return Ah(e.filter, (n) => {
    var i;
    if (h6(n)) {
      let r = null;
      EE(n) ? r = Ln(n.equal) : SE(n) ? r = Ln(n.lte) : _E(n) ? r = Ln(n.lt) : AE(n) ? r = Ln(n.gt) : $E(n) ? r = Ln(n.gte) : kE(n) ? r = n.range[0] : CE(n) && (r = ((i = n.oneOf) != null ? i : n.in)[0]), r && (zs(r) ? t[n.field] = "date" : Oe(r) ? t[n.field] = "number" : Y(r) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
    }
  }), t;
}
function Vle(e) {
  const t = {};
  function n(i) {
    tl(i) ? t[i.field] = "date" : i.type === "quantitative" && Gie(i.aggregate) ? t[i.field] = "number" : Xu(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : js(i) && cr(i.sort) && Xu(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"));
  }
  if ((Je(e) || Ti(e)) && e.forEachFieldDef((i, r) => {
    if (sn(i))
      n(i);
    else {
      const o = Is(r), a = e.fieldDef(o);
      n({
        ...i,
        type: a.type
      });
    }
  }), Je(e)) {
    const { mark: i, markDef: r, encoding: o } = e;
    if (Ea(i) && !e.encoding.order) {
      const a = r.orient === "horizontal" ? "y" : "x", s = o[a];
      q(s) && s.type === "quantitative" && !(s.field in t) && (t[s.field] = "number");
    }
  }
  return t;
}
function Kle(e) {
  const t = {};
  if (Je(e) && e.component.selection)
    for (const n of B(e.component.selection)) {
      const i = e.component.selection[n];
      for (const r of i.project.items)
        !r.channel && Xu(r.field) > 1 && (t[r.field] = "flatten");
    }
  return t;
}
class zt extends Ne {
  clone() {
    return new zt(null, ae(this._parse));
  }
  constructor(t, n) {
    super(t), this._parse = n;
  }
  hash() {
    return `Parse ${ge(this._parse)}`;
  }
  static makeExplicit(t, n, i) {
    var a;
    let r = {};
    const o = n.data;
    return !Wo(o) && ((a = o == null ? void 0 : o.format) == null ? void 0 : a.parse) && (r = o.format.parse), this.makeWithAncestors(t, r, {}, i);
  }
  static makeWithAncestors(t, n, i, r) {
    for (const s of B(i)) {
      const u = r.getWithExplicit(s);
      u.value !== void 0 && (u.explicit || u.value === i[s] || u.value === "derived" || i[s] === "flatten" ? delete i[s] : U(Nk(s, i[s], u.value)));
    }
    for (const s of B(n)) {
      const u = r.get(s);
      u !== void 0 && (u === n[s] ? delete n[s] : U(Nk(s, n[s], u)));
    }
    const o = new vo(n, i);
    r.copyAll(o);
    const a = {};
    for (const s of B(o.combine())) {
      const u = o.get(s);
      u !== null && (a[s] = u);
    }
    return B(a).length === 0 || r.parseNothing ? null : new zt(t, a);
  }
  get parse() {
    return this._parse;
  }
  merge(t) {
    this._parse = { ...this._parse, ...t.parse }, t.remove();
  }
  assembleFormatParse() {
    const t = {};
    for (const n of B(this._parse)) {
      const i = this._parse[n];
      Xu(n) === 1 && (t[n] = i);
    }
    return t;
  }
  producedFields() {
    return new Set(B(this._parse));
  }
  dependentFields() {
    return new Set(B(this._parse));
  }
  assembleTransforms(t = !1) {
    return B(this._parse).filter((n) => t ? Xu(n) > 1 : !0).map((n) => {
      const i = Yle(n, this._parse[n]);
      return i ? {
        type: "formula",
        expr: i,
        as: uE(n)
      } : null;
    }).filter((n) => n !== null);
  }
}
class sa extends Ne {
  clone() {
    return new sa(null);
  }
  constructor(t) {
    super(t);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([Li]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: Li };
  }
}
class dd extends Ne {
  clone() {
    return new dd(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  hash() {
    return `Graticule ${ge(this.params)}`;
  }
  assemble() {
    return {
      type: "graticule",
      ...this.params === !0 ? {} : this.params
    };
  }
}
class hd extends Ne {
  clone() {
    return new hd(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    var t;
    return /* @__PURE__ */ new Set([(t = this.params.as) != null ? t : "data"]);
  }
  hash() {
    return `Hash ${ge(this.params)}`;
  }
  assemble() {
    return {
      type: "sequence",
      ...this.params
    };
  }
}
class As extends Ne {
  constructor(t) {
    super(null), t != null || (t = { name: "source" });
    let n;
    if (Wo(t) || (n = t.format ? { ...bn(t.format, ["parse"]) } : {}), vf(t))
      this._data = { values: t.values };
    else if (nl(t)) {
      if (this._data = { url: t.url }, !n.type) {
        let i = /(?:\.([^.]+))?$/.exec(t.url)[1];
        me(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i;
      }
    } else
      CL(t) ? this._data = { values: [{ type: "Sphere" }] } : ($L(t) || Wo(t)) && (this._data = {});
    this._generator = Wo(t), t.name && (this._name = t.name), n && !De(n) && (this._data.format = n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(t) {
    this._name = t;
  }
  set parent(t) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return {
      name: this._name,
      ...this._data,
      transform: []
    };
  }
}
var EC = globalThis && globalThis.__classPrivateFieldSet || function(e, t, n, i, r) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !r)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? r.call(e, n) : r ? r.value = n : t.set(e, n), n;
}, Jle = globalThis && globalThis.__classPrivateFieldGet || function(e, t, n, i) {
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e);
}, Cc;
function g_(e) {
  return e instanceof As || e instanceof dd || e instanceof hd;
}
class m_ {
  constructor() {
    Cc.set(this, void 0), EC(this, Cc, !1, "f");
  }
  setModified() {
    EC(this, Cc, !0, "f");
  }
  get modifiedFlag() {
    return Jle(this, Cc, "f");
  }
}
Cc = /* @__PURE__ */ new WeakMap();
class Us extends m_ {
  getNodeDepths(t, n, i) {
    i.set(t, n);
    for (const r of t.children)
      this.getNodeDepths(r, n + 1, i);
    return i;
  }
  optimize(t) {
    const i = [...this.getNodeDepths(t, 0, /* @__PURE__ */ new Map()).entries()].sort((r, o) => o[1] - r[1]);
    for (const r of i)
      this.run(r[0]);
    return this.modifiedFlag;
  }
}
class y_ extends m_ {
  optimize(t) {
    this.run(t);
    for (const n of t.children)
      this.optimize(n);
    return this.modifiedFlag;
  }
}
class Qle extends y_ {
  mergeNodes(t, n) {
    const i = n.shift();
    for (const r of n)
      t.removeChild(r), r.parent = i, r.remove();
  }
  run(t) {
    const n = t.children.map((r) => r.hash()), i = {};
    for (let r = 0; r < n.length; r++)
      i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
    for (const r of B(i))
      i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]));
  }
}
class Zle extends y_ {
  constructor(t) {
    super(), this.requiresSelectionId = t && l_(t);
  }
  run(t) {
    t instanceof sa && (this.requiresSelectionId && (g_(t.parent) || t.parent instanceof Mi || t.parent instanceof zt) || (this.setModified(), t.remove()));
  }
}
class ece extends m_ {
  optimize(t) {
    return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
  }
  run(t, n) {
    let i = /* @__PURE__ */ new Set();
    t instanceof fr && (i = t.producedFields(), oE(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
    for (const r of t.children)
      this.run(r, /* @__PURE__ */ new Set([...n, ...i]));
  }
}
class tce extends y_ {
  constructor() {
    super();
  }
  run(t) {
    t instanceof rn && !t.isRequired() && (this.setModified(), t.remove());
  }
}
class nce extends Us {
  run(t) {
    if (!g_(t) && !(t.numChildren() > 1)) {
      for (const n of t.children)
        if (n instanceof zt)
          if (t instanceof zt)
            this.setModified(), t.merge(n);
          else {
            if (aE(t.producedFields(), n.dependentFields()))
              continue;
            this.setModified(), n.swapWithParent();
          }
    }
  }
}
class ice extends Us {
  run(t) {
    const n = [...t.children], i = t.children.filter((r) => r instanceof zt);
    if (t.numChildren() > 1 && i.length >= 1) {
      const r = {}, o = /* @__PURE__ */ new Set();
      for (const a of i) {
        const s = a.parse;
        for (const u of B(s))
          u in r ? r[u] !== s[u] && o.add(u) : r[u] = s[u];
      }
      for (const a of o)
        delete r[a];
      if (!De(r)) {
        this.setModified();
        const a = new zt(t, r);
        for (const s of n) {
          if (s instanceof zt)
            for (const u of B(r))
              delete s.parse[u];
          t.removeChild(s), s.parent = a, s instanceof zt && B(s.parse).length === 0 && s.remove();
        }
      }
    }
  }
}
class rce extends Us {
  run(t) {
    t instanceof rn || t.numChildren() > 0 || t instanceof Fl || t instanceof As || (this.setModified(), t.remove());
  }
}
class oce extends Us {
  run(t) {
    const n = t.children.filter((r) => r instanceof fr), i = n.pop();
    for (const r of n)
      this.setModified(), i.merge(r);
  }
}
class ace extends Us {
  run(t) {
    const n = t.children.filter((r) => r instanceof Mi), i = {};
    for (const r of n) {
      const o = ge(r.groupBy);
      o in i || (i[o] = []), i[o].push(r);
    }
    for (const r of B(i)) {
      const o = i[r];
      if (o.length > 1) {
        const a = o.pop();
        for (const s of o)
          a.merge(s) && (t.removeChild(s), s.parent = a, s.remove(), this.setModified());
      }
    }
  }
}
class sce extends Us {
  constructor(t) {
    super(), this.model = t;
  }
  run(t) {
    const n = !(g_(t) || t instanceof Cl || t instanceof zt || t instanceof sa), i = [], r = [];
    for (const o of t.children)
      o instanceof dr && (n && !aE(t.producedFields(), o.dependentFields()) ? i.push(o) : r.push(o));
    if (i.length > 0) {
      const o = i.pop();
      for (const a of i)
        o.merge(a, this.model.renameSignal.bind(this.model));
      this.setModified(), t instanceof dr ? t.merge(o, this.model.renameSignal.bind(this.model)) : o.swapWithParent();
    }
    if (r.length > 1) {
      const o = r.pop();
      for (const a of r)
        o.merge(a, this.model.renameSignal.bind(this.model));
      this.setModified();
    }
  }
}
class uce extends Us {
  run(t) {
    const n = [...t.children];
    if (!ms(n, (a) => a instanceof rn) || t.numChildren() <= 1)
      return;
    const r = [];
    let o;
    for (const a of n)
      if (a instanceof rn) {
        let s = a;
        for (; s.numChildren() === 1; ) {
          const [u] = s.children;
          if (u instanceof rn)
            s = u;
          else
            break;
        }
        r.push(...s.children), o ? (t.removeChild(a), a.parent = o.parent, o.parent.removeChild(o), o.parent = s, this.setModified()) : o = s;
      } else
        r.push(a);
    if (r.length) {
      this.setModified();
      for (const a of r)
        a.parent.removeChild(a), a.parent = o;
    }
  }
}
class qs extends Ne {
  clone() {
    return new qs(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = or(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(t) {
    var n;
    return (n = t.as) != null ? n : H(t);
  }
  hash() {
    return `JoinAggregateTransform ${ge(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], i = [];
    for (const o of this.transform.joinaggregate)
      n.push(o.op), i.push(this.getDefaultName(o)), t.push(o.field === void 0 ? null : o.field);
    const r = this.transform.groupby;
    return {
      type: "joinaggregate",
      as: i,
      ops: n,
      fields: t,
      ...r !== void 0 ? { groupby: r } : {}
    };
  }
}
function lce(e) {
  return e.stack.stackBy.reduce((t, n) => {
    const i = n.fieldDef, r = H(i);
    return r && t.push(r), t;
  }, []);
}
function cce(e) {
  return P(e) && e.every((t) => Y(t)) && e.length > 1;
}
class no extends Ne {
  clone() {
    return new no(null, ae(this._stack));
  }
  constructor(t, n) {
    super(t), this._stack = n;
  }
  static makeFromTransform(t, n) {
    const { stack: i, groupby: r, as: o, offset: a = "zero" } = n, s = [], u = [];
    if (n.sort !== void 0)
      for (const f of n.sort)
        s.push(f.field), u.push(tt(f.order, "ascending"));
    const l = {
      field: s,
      order: u
    };
    let c;
    return cce(o) ? c = o : Y(o) ? c = [o, `${o}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new no(t, {
      dimensionFieldDefs: [],
      stackField: i,
      groupby: r,
      offset: a,
      sort: l,
      facetby: [],
      as: c
    });
  }
  static makeFromEncoding(t, n) {
    const i = n.stack, { encoding: r } = n;
    if (!i)
      return null;
    const { groupbyChannels: o, fieldChannel: a, offset: s, impute: u } = i, l = o.map((h) => {
      const p = r[h];
      return xr(p);
    }).filter((h) => !!h), c = lce(n), f = n.encoding.order;
    let d;
    if (P(f) || q(f))
      d = YR(f);
    else {
      const h = I6(f) ? f.sort : a === "y" ? "descending" : "ascending";
      d = c.reduce((p, g) => (p.field.push(g), p.order.push(h), p), { field: [], order: [] });
    }
    return new no(t, {
      dimensionFieldDefs: l,
      stackField: n.vgField(a),
      facetby: [],
      stackby: c,
      sort: d,
      offset: s,
      impute: u,
      as: [
        n.vgField(a, { suffix: "start", forAs: !0 }),
        n.vgField(a, { suffix: "end", forAs: !0 })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(t) {
    this._stack.facetby.push(...t);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${ge(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs: t, impute: n, groupby: i } = this._stack;
    return t.length > 0 ? t.map((r) => r.bin ? n ? [H(r, { binSuffix: "mid" })] : [
      H(r, {}),
      H(r, { binSuffix: "end" })
    ] : [H(r)]).flat() : i != null ? i : [];
  }
  assemble() {
    const t = [], { facetby: n, dimensionFieldDefs: i, stackField: r, stackby: o, sort: a, offset: s, impute: u, as: l } = this._stack;
    if (u)
      for (const c of i) {
        const { bandPosition: f = 0.5, bin: d } = c;
        if (d) {
          const h = H(c, { expr: "datum" }), p = H(c, { expr: "datum", binSuffix: "end" });
          t.push({
            type: "formula",
            expr: `${f}*${h}+${1 - f}*${p}`,
            as: H(c, { binSuffix: "mid", forAs: !0 })
          });
        }
        t.push({
          type: "impute",
          field: r,
          groupby: [...o, ...n],
          key: H(c, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    return t.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...n],
      field: r,
      sort: a,
      as: l,
      offset: s
    }), t;
  }
}
class Ml extends Ne {
  clone() {
    return new Ml(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = or(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    var n, i;
    const t = /* @__PURE__ */ new Set();
    return ((n = this.transform.groupby) != null ? n : []).forEach(t.add, t), ((i = this.transform.sort) != null ? i : []).forEach((r) => t.add(r.field)), this.transform.window.map((r) => r.field).filter((r) => r !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(t) {
    var n;
    return (n = t.as) != null ? n : H(t);
  }
  hash() {
    return `WindowTransform ${ge(this.transform)}`;
  }
  assemble() {
    var f;
    const t = [], n = [], i = [], r = [];
    for (const d of this.transform.window)
      n.push(d.op), i.push(this.getDefaultName(d)), r.push(d.param === void 0 ? null : d.param), t.push(d.field === void 0 ? null : d.field);
    const o = this.transform.frame, a = this.transform.groupby;
    if (o && o[0] === null && o[1] === null && n.every((d) => mE(d)))
      return {
        type: "joinaggregate",
        as: i,
        ops: n,
        fields: t,
        ...a !== void 0 ? { groupby: a } : {}
      };
    const s = [], u = [];
    if (this.transform.sort !== void 0)
      for (const d of this.transform.sort)
        s.push(d.field), u.push((f = d.order) != null ? f : "ascending");
    const l = {
      field: s,
      order: u
    }, c = this.transform.ignorePeers;
    return {
      type: "window",
      params: r,
      as: i,
      ops: n,
      fields: t,
      sort: l,
      ...c !== void 0 ? { ignorePeers: c } : {},
      ...a !== void 0 ? { groupby: a } : {},
      ...o !== void 0 ? { frame: o } : {}
    };
  }
}
function fce(e) {
  function t(n) {
    if (!(n instanceof Fl)) {
      const i = n.clone();
      if (i instanceof rn) {
        const r = Kv + i.getSource();
        i.setSource(r), e.model.component.data.outputNodes[r] = i;
      } else
        (i instanceof Mi || i instanceof no || i instanceof Ml || i instanceof qs) && i.addDimensions(e.fields);
      for (const r of n.children.flatMap(t))
        r.parent = i;
      return [i];
    }
    return n.children.flatMap(t);
  }
  return t;
}
function Vv(e) {
  if (e instanceof Fl)
    if (e.numChildren() === 1 && !(e.children[0] instanceof rn)) {
      const t = e.children[0];
      (t instanceof Mi || t instanceof no || t instanceof Ml || t instanceof qs) && t.addDimensions(e.fields), t.swapWithParent(), Vv(e);
    } else {
      const t = e.model.component.data.main;
      x4(t);
      const n = fce(e), i = e.children.map(n).flat();
      for (const r of i)
        r.parent = t;
    }
  else
    e.children.map(Vv);
}
function x4(e) {
  if (e instanceof rn && e.type === Ie.Main && e.numChildren() === 1) {
    const t = e.children[0];
    t instanceof Fl || (t.swapWithParent(), x4(e));
  }
}
const Kv = "scale_", Hd = 5;
function Jv(e) {
  for (const t of e) {
    for (const n of t.children)
      if (n.parent !== t)
        return !1;
    if (!Jv(t.children))
      return !1;
  }
  return !0;
}
function li(e, t) {
  let n = !1;
  for (const i of t)
    n = e.optimize(i) || n;
  return n;
}
function _C(e, t, n) {
  let i = e.sources, r = !1;
  return r = li(new tce(), i) || r, r = li(new Zle(t), i) || r, i = i.filter((o) => o.numChildren() > 0), r = li(new rce(), i) || r, i = i.filter((o) => o.numChildren() > 0), n || (r = li(new nce(), i) || r, r = li(new sce(t), i) || r, r = li(new ece(), i) || r, r = li(new ice(), i) || r, r = li(new ace(), i) || r, r = li(new oce(), i) || r, r = li(new Qle(), i) || r, r = li(new uce(), i) || r), e.sources = i, r;
}
function dce(e, t) {
  Jv(e.sources);
  let n = 0, i = 0;
  for (let r = 0; r < Hd && _C(e, t, !0); r++)
    n++;
  e.sources.map(Vv);
  for (let r = 0; r < Hd && _C(e, t, !1); r++)
    i++;
  Jv(e.sources), Math.max(n, i) === Hd && U(`Maximum optimization runs(${Hd}) reached.`);
}
class wn {
  constructor(t) {
    Object.defineProperty(this, "signal", {
      enumerable: !0,
      get: t
    });
  }
  static fromName(t, n) {
    return new wn(() => t(n));
  }
}
function w4(e) {
  Je(e) ? hce(e) : pce(e);
}
function hce(e) {
  const t = e.component.scales;
  for (const n of B(t)) {
    const i = mce(e, n);
    if (t[n].setWithExplicit("domains", i), vce(e, n), e.component.data.isFaceted) {
      let o = e;
      for (; !Ti(o) && o.parent; )
        o = o.parent;
      if (o.component.resolve.scale[n] === "shared")
        for (const s of i.value)
          Vr(s) && (s.data = Kv + s.data.replace(Kv, ""));
    }
  }
}
function pce(e) {
  for (const n of e.children)
    w4(n);
  const t = e.component.scales;
  for (const n of B(t)) {
    let i, r = null;
    for (const o of e.children) {
      const a = o.component.scales[n];
      if (a) {
        i === void 0 ? i = a.getWithExplicit("domains") : i = ra(i, a.getWithExplicit("domains"), "domains", "scale", Qv);
        const s = a.get("selectionExtent");
        r && s && r.param !== s.param && U(lre), r = s;
      }
    }
    t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0);
  }
}
function gce(e, t, n, i) {
  if (e === "unaggregated") {
    const { valid: r, reason: o } = SC(t, n);
    if (!r) {
      U(o);
      return;
    }
  } else if (e === void 0 && i.useUnaggregatedDomain) {
    const { valid: r } = SC(t, n);
    if (r)
      return "unaggregated";
  }
  return e;
}
function mce(e, t) {
  const n = e.getScaleComponent(t).get("type"), { encoding: i } = e, r = gce(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
  return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
    ...e.specifiedScales[t],
    domain: r
  }), t === "x" && st(i.x2) ? st(i.x) ? ra(Eo(n, r, e, "x"), Eo(n, r, e, "x2"), "domain", "scale", Qv) : Eo(n, r, e, "x2") : t === "y" && st(i.y2) ? st(i.y) ? ra(Eo(n, r, e, "y"), Eo(n, r, e, "y2"), "domain", "scale", Qv) : Eo(n, r, e, "y2") : Eo(n, r, e, t);
}
function yce(e, t, n) {
  return e.map((i) => ({ signal: `{data: ${Gm(i, { timeUnit: n, type: t })}}` }));
}
function T1(e, t, n) {
  var r;
  const i = (r = vt(n)) == null ? void 0 : r.unit;
  return t === "temporal" || i ? yce(e, t, i) : [e];
}
function Eo(e, t, n, i) {
  const { encoding: r } = n, o = st(r[i]), { type: a } = o, s = o.timeUnit;
  if (Doe(t)) {
    const f = Eo(e, void 0, n, i), d = T1(t.unionWith, a, s);
    return Qi([...d, ...f.value]);
  } else {
    if (Z(t))
      return Qi([t]);
    if (t && t !== "unaggregated" && !x6(t))
      return Qi(T1(t, a, s));
  }
  const u = n.stack;
  if (u && i === u.fieldChannel) {
    if (u.offset === "normalize")
      return Nn([[0, 1]]);
    const f = n.requestDataName(Ie.Main);
    return Nn([
      {
        data: f,
        field: n.vgField(i, { suffix: "start" })
      },
      {
        data: f,
        field: n.vgField(i, { suffix: "end" })
      }
    ]);
  }
  const l = mo(i) && q(o) ? bce(n, i, e) : void 0;
  if (Nr(o)) {
    const f = T1([o.datum], a, s);
    return Nn(f);
  }
  const c = o;
  if (t === "unaggregated") {
    const f = n.requestDataName(Ie.Main), { field: d } = o;
    return Nn([
      {
        data: f,
        field: H({ field: d, aggregate: "min" })
      },
      {
        data: f,
        field: H({ field: d, aggregate: "max" })
      }
    ]);
  } else if (ze(c.bin)) {
    if (wt(e))
      return Nn(e === "bin-ordinal" ? [] : [
        {
          data: mf(l) ? n.requestDataName(Ie.Main) : n.requestDataName(Ie.Raw),
          field: n.vgField(i, ld(c, i) ? { binSuffix: "range" } : {}),
          sort: l === !0 || !K(l) ? {
            field: n.vgField(i, {}),
            op: "min"
          } : l
        }
      ]);
    {
      const { bin: f } = c;
      if (ze(f)) {
        const d = p_(n, c.field, f);
        return Nn([
          new wn(() => {
            const h = n.getSignalName(d);
            return `[${h}.start, ${h}.stop]`;
          })
        ]);
      } else
        return Nn([
          {
            data: n.requestDataName(Ie.Main),
            field: n.vgField(i, {})
          }
        ]);
    }
  } else if (c.timeUnit && me(["time", "utc"], e) && L6(c, Je(n) ? n.encoding[Tr(i)] : void 0, n.markDef, n.config)) {
    const f = n.requestDataName(Ie.Main);
    return Nn([
      {
        data: f,
        field: n.vgField(i)
      },
      {
        data: f,
        field: n.vgField(i, { suffix: "end" })
      }
    ]);
  } else
    return Nn(l ? [
      {
        data: mf(l) ? n.requestDataName(Ie.Main) : n.requestDataName(Ie.Raw),
        field: n.vgField(i),
        sort: l
      }
    ] : [
      {
        data: n.requestDataName(Ie.Main),
        field: n.vgField(i)
      }
    ]);
}
function O1(e, t) {
  const { op: n, field: i, order: r } = e;
  return {
    op: n != null ? n : t ? "sum" : Bm,
    ...i ? { field: ri(i) } : {},
    ...r ? { order: r } : {}
  };
}
function vce(e, t) {
  var s;
  const n = e.component.scales[t], i = e.specifiedScales[t].domain, r = (s = e.fieldDef(t)) == null ? void 0 : s.bin, o = x6(i) && i, a = Ps(r) && Nm(r.extent) && r.extent;
  (o || a) && n.set("selectionExtent", o != null ? o : a, !0);
}
function bce(e, t, n) {
  if (!wt(n))
    return;
  const i = e.fieldDef(t), r = i.sort;
  if (N6(r))
    return {
      op: "min",
      field: ol(i, t),
      order: "ascending"
    };
  const { stack: o } = e, a = o ? /* @__PURE__ */ new Set([...o.groupbyFields, ...o.stackBy.map((s) => s.fieldDef.field)]) : void 0;
  if (cr(r)) {
    const s = o && !a.has(r.field);
    return O1(r, s);
  } else if (O6(r)) {
    const { encoding: s, order: u } = r, l = e.fieldDef(s), { aggregate: c, field: f } = l, d = o && !a.has(f);
    if (ao(c) || xa(c))
      return O1({
        field: H(l),
        order: u
      }, d);
    if (mE(c) || !c)
      return O1({
        op: c,
        field: f,
        order: u
      }, d);
  } else {
    if (r === "descending")
      return {
        op: "min",
        field: e.vgField(t),
        order: "descending"
      };
    if (me(["ascending", void 0], r))
      return !0;
  }
}
function SC(e, t) {
  const { aggregate: n, type: i } = e;
  return n ? Y(n) && !Yie.has(n) ? {
    valid: !1,
    reason: Ire(n)
  } : i === "quantitative" && t === "log" ? {
    valid: !1,
    reason: Pre(e)
  } : { valid: !0 } : {
    valid: !1,
    reason: Lre(e)
  };
}
function Qv(e, t, n, i) {
  return e.explicit && t.explicit && U(qre(n, i, e.value, t.value)), { explicit: e.explicit, value: [...e.value, ...t.value] };
}
function xce(e) {
  const t = or(e.map((a) => {
    if (Vr(a)) {
      const { sort: s, ...u } = a;
      return u;
    }
    return a;
  }), ge), n = or(e.map((a) => {
    if (Vr(a)) {
      const s = a.sort;
      return s !== void 0 && !mf(s) && ("op" in s && s.op === "count" && delete s.field, s.order === "ascending" && delete s.order), s;
    }
  }).filter((a) => a !== void 0), ge);
  if (t.length === 0)
    return;
  if (t.length === 1) {
    const a = e[0];
    if (Vr(a) && n.length > 0) {
      let s = n[0];
      if (n.length > 1) {
        U(Rk);
        const u = n.filter((l) => K(l) && "op" in l && l.op !== "min");
        n.every((l) => K(l) && "op" in l) && u.length === 1 ? s = u[0] : s = !0;
      } else if (K(s) && "field" in s) {
        const u = s.field;
        a.field === u && (s = s.order ? { order: s.order } : !0);
      }
      return {
        ...a,
        sort: s
      };
    }
    return a;
  }
  const i = or(n.map((a) => mf(a) || !("op" in a) || Y(a.op) && a.op in qie ? a : (U(Gre(a)), !0)), ge);
  let r;
  i.length === 1 ? r = i[0] : i.length > 1 && (U(Rk), r = !0);
  const o = or(e.map((a) => Vr(a) ? a.data : null), (a) => a);
  return o.length === 1 && o[0] !== null ? {
    data: o[0],
    fields: t.map((s) => s.field),
    ...r ? { sort: r } : {}
  } : { fields: t, ...r ? { sort: r } : {} };
}
function v_(e) {
  if (Vr(e) && Y(e.field))
    return e.field;
  if (Xie(e)) {
    let t;
    for (const n of e.fields)
      if (Vr(n) && Y(n.field)) {
        if (!t)
          t = n.field;
        else if (t !== n.field)
          return U(Hre), t;
      }
    return U(Yre), t;
  } else if (Vie(e)) {
    U(Xre);
    const t = e.fields[0];
    return Y(t) ? t : void 0;
  }
}
function t0(e, t) {
  const i = e.component.scales[t].get("domains").map((r) => (Vr(r) && (r.data = e.lookupDataSource(r.data)), r));
  return xce(i);
}
function E4(e) {
  return Tl(e) || b_(e) ? e.children.reduce((t, n) => t.concat(E4(n)), AC(e)) : AC(e);
}
function AC(e) {
  return B(e.component.scales).reduce((t, n) => {
    const i = e.component.scales[n];
    if (i.merged)
      return t;
    const r = i.combine(), { name: o, type: a, selectionExtent: s, domains: u, range: l, reverse: c, ...f } = r, d = wce(r.range, o, n, e), h = t0(e, n), p = s ? gue(e, s, i, h) : null;
    return t.push({
      name: o,
      type: a,
      ...h ? { domain: h } : {},
      ...p ? { domainRaw: p } : {},
      range: d,
      ...c !== void 0 ? { reverse: c } : {},
      ...f
    }), t;
  }, []);
}
function wce(e, t, n, i) {
  if (xt(n)) {
    if (wa(e))
      return {
        step: { signal: `${t}_step` }
      };
  } else if (K(e) && Vr(e))
    return {
      ...e,
      data: i.lookupDataSource(e.data)
    };
  return e;
}
class _4 extends vo {
  constructor(t, n) {
    super(
      {},
      { name: t }
    ), this.merged = !1, this.setWithExplicit("type", n);
  }
  domainDefinitelyIncludesZero() {
    return this.get("zero") !== !1 ? !0 : ms(this.get("domains"), (t) => P(t) && t.length === 2 && t[0] <= 0 && t[1] >= 0);
  }
}
const Ece = ["range", "scheme"];
function _ce(e) {
  const t = e.component.scales;
  for (const n of Om) {
    const i = t[n];
    if (!i)
      continue;
    const r = Sce(n, e);
    i.setWithExplicit("range", r);
  }
}
function $C(e, t) {
  const n = e.fieldDef(t);
  if (n != null && n.bin) {
    const { bin: i, field: r } = n, o = Cn(t), a = e.getName(o);
    if (K(i) && i.binned && i.step !== void 0)
      return new wn(() => {
        const s = e.scaleName(t), u = `(domain("${s}")[1] - domain("${s}")[0]) / ${i.step}`;
        return `${e.getSignalName(a)} / (${u})`;
      });
    if (ze(i)) {
      const s = p_(e, r, i);
      return new wn(() => {
        const u = e.getSignalName(s), l = `(${u}.stop - ${u}.start) / ${u}.step`;
        return `${e.getSignalName(a)} / (${l})`;
      });
    }
  }
}
function Sce(e, t) {
  const n = t.specifiedScales[e], { size: i } = t, o = t.getScaleComponent(e).get("type");
  for (const f of Ece)
    if (n[f] !== void 0) {
      const d = Rv(o, f), h = w6(e, f);
      if (!d)
        U(e6(o, f, e));
      else if (h)
        U(h);
      else
        switch (f) {
          case "range": {
            const p = n.range;
            if (P(p)) {
              if (xt(e))
                return Qi(p.map((g) => {
                  if (g === "width" || g === "height") {
                    const m = t.getName(g), y = t.getSignalName.bind(t);
                    return wn.fromName(y, m);
                  }
                  return g;
                }));
            } else if (K(p))
              return Qi({
                data: t.requestDataName(Ie.Main),
                field: p.field,
                sort: { op: "min", field: t.vgField(e) }
              });
            return Qi(p);
          }
          case "scheme":
            return Qi(Ace(n[f]));
        }
    }
  const a = e === Ge || e === "xOffset" ? "width" : "height", s = i[a];
  if (wr(s)) {
    if (xt(e))
      if (wt(o)) {
        const f = S4(s, t, e);
        if (f)
          return Qi({ step: f });
      } else
        U(t6(a));
    else if (Al(e)) {
      const f = e === ga ? "x" : "y";
      if (t.getScaleComponent(f).get("type") === "band") {
        const p = A4(s, o);
        if (p)
          return Qi(p);
      }
    }
  }
  const { rangeMin: u, rangeMax: l } = n, c = $ce(e, t);
  return (u !== void 0 || l !== void 0) && Rv(o, "rangeMin") && P(c) && c.length === 2 ? Qi([u != null ? u : c[0], l != null ? l : c[1]]) : Nn(c);
}
function Ace(e) {
  return Noe(e) ? {
    scheme: e.name,
    ...bn(e, ["name"])
  } : { scheme: e };
}
function $ce(e, t) {
  const { size: n, config: i, mark: r, encoding: o } = t, a = t.getSignalName.bind(t), { type: s } = st(o[e]), l = t.getScaleComponent(e).get("type"), { domain: c, domainMid: f } = t.specifiedScales[e];
  switch (e) {
    case Ge:
    case bt: {
      if (me(["point", "band"], l)) {
        const p = $4(e, n, i.view);
        if (wr(p))
          return { step: S4(p, t, e) };
      }
      const d = Cn(e), h = t.getName(d);
      return e === bt && Wn(l) ? [wn.fromName(a, h), 0] : [0, wn.fromName(a, h)];
    }
    case ga:
    case Sl:
      return kce(e, t, l);
    case po: {
      const d = t.component.scales[e].get("zero"), h = k4(r, d, i), p = Mce(r, n, t, i);
      return Qu(l) ? Fce(h, p, Cce(l, i, c, e)) : [h, p];
    }
    case si:
      return [0, Math.PI * 2];
    case Ls:
      return [0, 360];
    case ji:
      return [
        0,
        new wn(() => {
          const d = t.getSignalName("width"), h = t.getSignalName("height");
          return `min(${d},${h})/2`;
        })
      ];
    case va:
      return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
    case ba:
      return [
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case kn:
      return "symbol";
    case $n:
    case Fr:
    case Mr:
      return l === "ordinal" ? s === "nominal" ? "category" : "ordinal" : f !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
    case go:
    case ma:
    case ya:
      return [i.scale.minOpacity, i.scale.maxOpacity];
  }
}
function S4(e, t, n) {
  var u, l, c, f, d;
  const { encoding: i } = t, r = t.getScaleComponent(n), o = dE(n), a = i[o];
  if (dL({ step: e, offsetIsDiscrete: se(a) && g6(a.type) }) === "offset" && X6(i, o)) {
    const h = t.getScaleComponent(o);
    let g = `domain('${t.scaleName(o)}').length`;
    if (h.get("type") === "band") {
      const y = (l = (u = h.get("paddingInner")) != null ? u : h.get("padding")) != null ? l : 0, v = (f = (c = h.get("paddingOuter")) != null ? c : h.get("padding")) != null ? f : 0;
      g = `bandspace(${g}, ${y}, ${v})`;
    }
    const m = (d = r.get("paddingInner")) != null ? d : r.get("padding");
    return {
      signal: `${e.step} * ${g} / (1-${Zie(m)})`
    };
  } else
    return e.step;
}
function A4(e, t) {
  if (dL({ step: e, offsetIsDiscrete: wt(t) }) === "offset")
    return { step: e.step };
}
function kce(e, t, n) {
  const i = e === ga ? "x" : "y", o = t.getScaleComponent(i).get("type"), a = t.scaleName(i);
  if (o === "band") {
    const s = $4(i, t.size, t.config.view);
    if (wr(s)) {
      const u = A4(s, n);
      if (u)
        return u;
    }
    return [0, { signal: `bandwidth('${a}')` }];
  } else {
    const s = t.encoding[i];
    if (q(s) && s.timeUnit) {
      const u = f6(s.timeUnit, (c) => `scale('${a}', ${c})`), l = t.config.scale.bandWithNestedOffsetPaddingInner;
      if (l) {
        const c = Z(l) ? `${l.signal}/2` : `${l / 2}`, f = Z(l) ? `(1 - ${l.signal}/2)` : `${1 - l / 2}`;
        return [{ signal: `${c} * (${u})` }, { signal: `${f} * (${u})` }];
      }
      return [0, { signal: u }];
    }
    return xR(`Cannot use ${e} scale if ${i} scale is not discrete.`);
  }
}
function $4(e, t, n) {
  const i = e === Ge ? "width" : "height", r = t[i];
  return r || tg(n, i);
}
function Cce(e, t, n, i) {
  switch (e) {
    case "quantile":
      return t.scale.quantileCount;
    case "quantize":
      return t.scale.quantizeCount;
    case "threshold":
      return n !== void 0 && P(n) ? n.length + 1 : (U(ioe(i)), 3);
  }
}
function Fce(e, t, n) {
  const i = () => {
    const r = Ai(t), o = Ai(e), a = `(${r} - ${o}) / (${n} - 1)`;
    return `sequence(${o}, ${r} + ${a}, ${a})`;
  };
  return Z(t) ? new wn(i) : { signal: i() };
}
function k4(e, t, n) {
  if (t)
    return Z(t) ? { signal: `${t.signal} ? 0 : ${k4(e, !1, n)}` } : 0;
  switch (e) {
    case "bar":
    case "tick":
      return n.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return n.scale.minStrokeWidth;
    case "text":
      return n.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return n.scale.minSize;
  }
  throw new Error(Dm("size", e));
}
const kC = 0.95;
function Mce(e, t, n, i) {
  const r = {
    x: $C(n, "x"),
    y: $C(n, "y")
  };
  switch (e) {
    case "bar":
    case "tick": {
      if (i.scale.maxBandSize !== void 0)
        return i.scale.maxBandSize;
      const o = CC(t, r, i.view);
      return Oe(o) ? o - 1 : new wn(() => `${o.signal} - 1`);
    }
    case "line":
    case "trail":
    case "rule":
      return i.scale.maxStrokeWidth;
    case "text":
      return i.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (i.scale.maxSize)
        return i.scale.maxSize;
      const o = CC(t, r, i.view);
      return Oe(o) ? Math.pow(kC * o, 2) : new wn(() => `pow(${kC} * ${o.signal}, 2)`);
    }
  }
  throw new Error(Dm("size", e));
}
function CC(e, t, n) {
  const i = wr(e.width) ? e.width.step : eg(n, "width"), r = wr(e.height) ? e.height.step : eg(n, "height");
  return t.x || t.y ? new wn(() => `min(${[
    t.x ? t.x.signal : i,
    t.y ? t.y.signal : r
  ].join(", ")})`) : Math.min(i, r);
}
function C4(e, t) {
  Je(e) ? Tce(e, t) : M4(e, t);
}
function Tce(e, t) {
  const n = e.component.scales, { config: i, encoding: r, markDef: o, specifiedScales: a } = e;
  for (const s of B(n)) {
    const u = a[s], l = n[s], c = e.getScaleComponent(s), f = st(r[s]), d = u[t], h = c.get("type"), p = c.get("padding"), g = c.get("paddingInner"), m = Rv(h, t), y = w6(s, t);
    if (d !== void 0 && (m ? y && U(y) : U(e6(h, t, s))), m && y === void 0)
      if (d !== void 0) {
        const v = f.timeUnit, b = f.type;
        switch (t) {
          case "domainMax":
          case "domainMin":
            zs(u[t]) || b === "temporal" || v ? l.set(t, { signal: Gm(u[t], { type: b, timeUnit: v }) }, !0) : l.set(t, u[t], !0);
            break;
          default:
            l.copyKeyFromObject(t, u);
        }
      } else {
        const v = t in FC ? FC[t]({
          model: e,
          channel: s,
          fieldOrDatumDef: f,
          scaleType: h,
          scalePadding: p,
          scalePaddingInner: g,
          domain: u.domain,
          domainMin: u.domainMin,
          domainMax: u.domainMax,
          markDef: o,
          config: i,
          hasNestedOffsetScale: Iv(r, s),
          hasSecondaryRangeChannel: !!r[Tr(s)]
        }) : i.scale[t];
        v !== void 0 && l.set(t, v, !1);
      }
  }
}
const FC = {
  bins: ({ model: e, fieldOrDatumDef: t }) => q(t) ? Oce(e, t) : void 0,
  interpolate: ({ channel: e, fieldOrDatumDef: t }) => Nce(e, t.type),
  nice: ({ scaleType: e, channel: t, domain: n, domainMin: i, domainMax: r, fieldOrDatumDef: o }) => Dce(e, t, n, i, r, o),
  padding: ({ channel: e, scaleType: t, fieldOrDatumDef: n, markDef: i, config: r }) => Rce(e, t, r.scale, n, i, r.bar),
  paddingInner: ({ scalePadding: e, channel: t, markDef: n, scaleType: i, config: r, hasNestedOffsetScale: o }) => Lce(e, t, n.type, i, r.scale, o),
  paddingOuter: ({ scalePadding: e, channel: t, scaleType: n, scalePaddingInner: i, config: r, hasNestedOffsetScale: o }) => Ice(e, t, n, i, r.scale, o),
  reverse: ({ fieldOrDatumDef: e, scaleType: t, channel: n, config: i }) => {
    const r = q(e) ? e.sort : void 0;
    return Pce(t, r, n, i.scale);
  },
  zero: ({ channel: e, fieldOrDatumDef: t, domain: n, markDef: i, scaleType: r, config: o, hasSecondaryRangeChannel: a }) => zce(e, t, n, i, r, o.scale, a)
};
function F4(e) {
  Je(e) ? _ce(e) : M4(e, "range");
}
function M4(e, t) {
  const n = e.component.scales;
  for (const i of e.children)
    t === "range" ? F4(i) : C4(i, t);
  for (const i of B(n)) {
    let r;
    for (const o of e.children) {
      const a = o.component.scales[i];
      if (a) {
        const s = a.getWithExplicit(t);
        r = ra(r, s, t, "scale", AL((u, l) => {
          switch (t) {
            case "range":
              return u.step && l.step ? u.step - l.step : 0;
          }
          return 0;
        }));
      }
    }
    n[i].setWithExplicit(t, r);
  }
}
function Oce(e, t) {
  const n = t.bin;
  if (ze(n)) {
    const i = p_(e, t.field, n);
    return new wn(() => e.getSignalName(i));
  } else if (_t(n) && Ps(n) && n.step !== void 0)
    return {
      step: n.step
    };
}
function Nce(e, t) {
  if (me([$n, Fr, Mr], e) && t !== "nominal")
    return "hcl";
}
function Dce(e, t, n, i, r, o) {
  var a;
  if (!(((a = xr(o)) == null ? void 0 : a.bin) || P(n) || r != null || i != null || me([xn.TIME, xn.UTC], e)))
    return xt(t) ? !0 : void 0;
}
function Rce(e, t, n, i, r, o) {
  if (xt(e)) {
    if ($i(t)) {
      if (n.continuousPadding !== void 0)
        return n.continuousPadding;
      const { type: a, orient: s } = r;
      if (a === "bar" && !(q(i) && (i.bin || i.timeUnit)) && (s === "vertical" && e === "x" || s === "horizontal" && e === "y"))
        return o.continuousBandSize;
    }
    if (t === xn.POINT)
      return n.pointPadding;
  }
}
function Lce(e, t, n, i, r, o = !1) {
  if (e === void 0) {
    if (xt(t)) {
      const { bandPaddingInner: a, barBandPaddingInner: s, rectBandPaddingInner: u, bandWithNestedOffsetPaddingInner: l } = r;
      return o ? l : tt(a, n === "bar" ? s : u);
    } else if (Al(t) && i === xn.BAND)
      return r.offsetBandPaddingInner;
  }
}
function Ice(e, t, n, i, r, o = !1) {
  if (e === void 0) {
    if (xt(t)) {
      const { bandPaddingOuter: a, bandWithNestedOffsetPaddingOuter: s } = r;
      if (o)
        return s;
      if (n === xn.BAND)
        return tt(
          a,
          Z(i) ? { signal: `${i.signal}/2` } : i / 2
        );
    } else if (Al(t)) {
      if (n === xn.POINT)
        return 0.5;
      if (n === xn.BAND)
        return r.offsetBandPaddingOuter;
    }
  }
}
function Pce(e, t, n, i) {
  if (n === "x" && i.xReverse !== void 0)
    return Wn(e) && t === "descending" ? Z(i.xReverse) ? { signal: `!${i.xReverse.signal}` } : !i.xReverse : i.xReverse;
  if (Wn(e) && t === "descending")
    return !0;
}
function zce(e, t, n, i, r, o, a) {
  if (!!n && n !== "unaggregated" && Wn(r)) {
    if (P(n)) {
      const u = n[0], l = n[n.length - 1];
      if (u <= 0 && l >= 0)
        return !0;
    }
    return !1;
  }
  if (e === "size" && t.type === "quantitative" && !Qu(r))
    return !0;
  if (!(q(t) && t.bin) && me([...Or, ...Rie], e)) {
    const { orient: u, type: l } = i;
    return me(["bar", "area", "line", "trail"], l) && (u === "horizontal" && e === "y" || u === "vertical" && e === "x") ? !1 : me(["bar", "area"], l) && !a ? !0 : o == null ? void 0 : o.zero;
  }
  return !1;
}
function Bce(e, t, n, i, r = !1) {
  const o = jce(t, n, i, r), { type: a } = e;
  return mo(t) ? a !== void 0 ? Boe(t, a) ? q(n) && !zoe(a, n.type) ? (U(jre(a, o)), o) : a : (U(Bre(t, a, o)), o) : o : null;
}
function jce(e, t, n, i) {
  var r;
  switch (t.type) {
    case "nominal":
    case "ordinal": {
      if (wu(e) || _1(e) === "discrete")
        return e === "shape" && t.type === "ordinal" && U(S1(e, "ordinal")), "ordinal";
      if (xt(e) || Al(e)) {
        if (me(["rect", "bar", "image", "rule"], n.type) || i)
          return "band";
      } else if (n.type === "arc" && e in gE)
        return "band";
      const o = n[Cn(e)];
      return ws(o) || el(t) && ((r = t.axis) == null ? void 0 : r.tickBand) ? "band" : "point";
    }
    case "temporal":
      return wu(e) ? "time" : _1(e) === "discrete" ? (U(S1(e, "temporal")), "ordinal") : q(t) && t.timeUnit && vt(t.timeUnit).utc ? "utc" : "time";
    case "quantitative":
      return wu(e) ? q(t) && ze(t.bin) ? "bin-ordinal" : "linear" : _1(e) === "discrete" ? (U(S1(e, "quantitative")), "ordinal") : "linear";
    case "geojson":
      return;
  }
  throw new Error(QR(t.type));
}
function Uce(e, { ignoreRange: t } = {}) {
  T4(e), w4(e);
  for (const n of Poe)
    C4(e, n);
  t || F4(e);
}
function T4(e) {
  Je(e) ? e.component.scales = qce(e) : e.component.scales = Gce(e);
}
function qce(e) {
  const { encoding: t, mark: n, markDef: i } = e, r = {};
  for (const o of Om) {
    const a = st(t[o]);
    if (a && n === S6 && o === kn && a.type === $l)
      continue;
    let s = a && a.scale;
    if (Al(o)) {
      const u = LR(o);
      if (!Iv(t, u)) {
        s && U($re(o));
        continue;
      }
    }
    if (a && s !== null && s !== !1) {
      s != null || (s = {});
      const u = Iv(t, o), l = Bce(s, o, a, i, u);
      r[o] = new _4(e.scaleName(`${o}`, !0), {
        value: l,
        explicit: s.type === l
      });
    }
  }
  return r;
}
const Wce = AL((e, t) => Ik(e) - Ik(t));
function Gce(e) {
  var o;
  var t;
  const n = e.component.scales = {}, i = {}, r = e.component.resolve;
  for (const a of e.children) {
    T4(a);
    for (const s of B(a.component.scales))
      if ((o = (t = r.scale)[s]) != null || (t[s] = u4(s, e)), r.scale[s] === "shared") {
        const u = i[s], l = a.component.scales[s].getWithExplicit("type");
        u ? Coe(u.value, l.value) ? i[s] = ra(u, l, "type", "scale", Wce) : (r.scale[s] = "independent", delete i[s]) : i[s] = l;
      }
  }
  for (const a of B(i)) {
    const s = e.scaleName(a, !0), u = i[a];
    n[a] = new _4(s, u);
    for (const l of e.children) {
      const c = l.component.scales[a];
      c && (l.renameScale(c.get("name"), s), c.merged = !0);
    }
  }
  return n;
}
class N1 {
  constructor() {
    this.nameMap = {};
  }
  rename(t, n) {
    this.nameMap[t] = n;
  }
  has(t) {
    return this.nameMap[t] !== void 0;
  }
  get(t) {
    for (; this.nameMap[t] && t !== this.nameMap[t]; )
      t = this.nameMap[t];
    return t;
  }
}
function Je(e) {
  return (e == null ? void 0 : e.type) === "unit";
}
function Ti(e) {
  return (e == null ? void 0 : e.type) === "facet";
}
function b_(e) {
  return (e == null ? void 0 : e.type) === "concat";
}
function Tl(e) {
  return (e == null ? void 0 : e.type) === "layer";
}
class x_ {
  constructor(t, n, i, r, o, a, s) {
    var u, l;
    this.type = n, this.parent = i, this.config = o, this.correctDataNames = (c) => {
      var f, d, h;
      return (f = c.from) != null && f.data && (c.from.data = this.lookupDataSource(c.from.data)), (h = (d = c.from) == null ? void 0 : d.facet) != null && h.data && (c.from.facet.data = this.lookupDataSource(c.from.facet.data)), c;
    }, this.parent = i, this.config = o, this.view = pn(s), this.name = (u = t.name) != null ? u : r, this.title = ko(t.title) ? { text: t.title } : t.title ? pn(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new N1(), this.projectionNameMap = i ? i.projectionNameMap : new N1(), this.signalNameMap = i ? i.signalNameMap : new N1(), this.data = t.data, this.description = t.description, this.transforms = Qse((l = t.transform) != null ? l : []), this.layout = n === "layer" || n === "unit" ? {} : nse(t, n, o), this.component = {
      data: {
        sources: i ? i.component.data.sources : [],
        outputNodes: i ? i.component.data.outputNodes : {},
        outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {},
        isFaceted: jm(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
      },
      layoutSize: new vo(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: {
        scale: {},
        axis: {},
        legend: {},
        ...a ? ae(a) : {}
      },
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();
  }
  parseScale() {
    Uce(this);
  }
  parseProjection() {
    v4(this);
  }
  renameTopLevelLayoutSizeSignal() {
    this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
  }
  parseLegends() {
    h4(this);
  }
  assembleEncodeFromView(t) {
    const { style: n, ...i } = t, r = {};
    for (const o of B(i)) {
      const a = i[o];
      a !== void 0 && (r[o] = je(a));
    }
    return r;
  }
  assembleGroupEncodeEntry(t) {
    let n = {};
    return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = je(this.description)), this.type === "unit" || this.type === "layer") ? {
      width: this.getSizeSignalRef("width"),
      height: this.getSizeSignalRef("height"),
      ...n != null ? n : {}
    } : De(n) ? void 0 : n;
  }
  assembleLayout() {
    if (!this.layout)
      return;
    const { spacing: t, ...n } = this.layout, { component: i, config: r } = this, o = dle(i.layoutHeaders, r);
    return {
      padding: t,
      ...this.assembleDefaultLayout(),
      ...n,
      ...o ? { titleBand: o } : {}
    };
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: t } = this.component;
    let n = [];
    for (const i of Jn)
      t[i].title && n.push(ale(this, i));
    for (const i of c_)
      n = n.concat(sle(this, i));
    return n;
  }
  assembleAxes() {
    return Yue(this.component.axes, this.config);
  }
  assembleLegends() {
    return g4(this);
  }
  assembleProjections() {
    return Rle(this);
  }
  assembleTitle() {
    var r, o, a;
    const { encoding: t, ...n } = (r = this.title) != null ? r : {}, i = {
      ...qR(this.config.title).nonMarkTitleProperties,
      ...n,
      ...t ? { encode: { update: t } } : {}
    };
    if (i.text)
      return me(["unit", "layer"], this.type) ? me(["middle", void 0], i.anchor) && ((o = i.frame) != null || (i.frame = "group")) : (a = i.anchor) != null || (i.anchor = "start"), De(i) ? void 0 : i;
  }
  assembleGroup(t = []) {
    const n = {};
    t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
    const i = this.assembleLayout();
    i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const r = !this.parent || Ti(this.parent) ? E4(this) : [];
    r.length > 0 && (n.scales = r);
    const o = this.assembleAxes();
    o.length > 0 && (n.axes = o);
    const a = this.assembleLegends();
    return a.length > 0 && (n.legends = a), n;
  }
  getName(t) {
    return We((this.name ? `${this.name}_` : "") + t);
  }
  getDataName(t) {
    return this.getName(Ie[t].toLowerCase());
  }
  requestDataName(t) {
    const n = this.getDataName(t), i = this.component.data.outputNodeRefCounts;
    return i[n] = (i[n] || 0) + 1, n;
  }
  getSizeSignalRef(t) {
    if (Ti(this.parent)) {
      const n = a4(t), i = Tm(n), r = this.component.scales[i];
      if (r && !r.merged) {
        const o = r.get("type"), a = r.get("range");
        if (wt(o) && wa(a)) {
          const s = r.get("name"), u = t0(this, i), l = v_(u);
          if (l) {
            const c = H({ aggregate: "distinct", field: l }, { expr: "datum" });
            return {
              signal: o4(s, r, c)
            };
          } else
            return U(vE(i)), null;
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(t))
    };
  }
  lookupDataSource(t) {
    const n = this.component.data.outputNodes[t];
    return n ? n.getSource() : t;
  }
  getSignalName(t) {
    return this.signalNameMap.get(t);
  }
  renameSignal(t, n) {
    this.signalNameMap.rename(t, n);
  }
  renameScale(t, n) {
    this.scaleNameMap.rename(t, n);
  }
  renameProjection(t, n) {
    this.projectionNameMap.rename(t, n);
  }
  scaleName(t, n) {
    if (n)
      return this.getName(t);
    if (NR(t) && mo(t) && this.component.scales[t] || this.scaleNameMap.has(this.getName(t)))
      return this.scaleNameMap.get(this.getName(t));
  }
  projectionName(t) {
    if (t)
      return this.getName("projection");
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")))
      return this.projectionNameMap.get(this.getName("projection"));
  }
  getScaleComponent(t) {
    if (!this.component.scales)
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    const n = this.component.scales[t];
    return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
  }
  getSelectionComponent(t, n) {
    let i = this.component.selection[t];
    if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i)
      throw new Error(rre(n));
    return i;
  }
  hasAxisOrientSignalRef() {
    var t, n;
    return ((t = this.component.axes.x) == null ? void 0 : t.some((i) => i.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some((i) => i.hasOrientSignalRef()));
  }
}
class O4 extends x_ {
  vgField(t, n = {}) {
    const i = this.fieldDef(t);
    if (!!i)
      return H(i, n);
  }
  reduceFieldDef(t, n) {
    return Tae(this.getMapping(), (i, r, o) => {
      const a = xr(r);
      return a ? t(i, a, o) : i;
    }, n);
  }
  forEachFieldDef(t, n) {
    HE(this.getMapping(), (i, r) => {
      const o = xr(i);
      o && t(o, r);
    }, n);
  }
}
class n0 extends Ne {
  clone() {
    return new n0(null, ae(this.transform));
  }
  constructor(t, n) {
    var r, o, a;
    super(t), this.transform = n, this.transform = ae(n);
    const i = (r = this.transform.as) != null ? r : [void 0, void 0];
    this.transform.as = [(o = i[0]) != null ? o : "value", (a = i[1]) != null ? a : "density"], n.groupby && n.minsteps == null && n.maxsteps == null && n.steps == null && (this.transform.steps = 200);
  }
  dependentFields() {
    var t;
    return /* @__PURE__ */ new Set([this.transform.density, ...(t = this.transform.groupby) != null ? t : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { density: t, ...n } = this.transform;
    return {
      type: "kde",
      field: t,
      ...n
    };
  }
}
class i0 extends Ne {
  clone() {
    return new i0(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = ae(n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.extent]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([]);
  }
  hash() {
    return `ExtentTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { extent: t, param: n } = this.transform;
    return {
      type: "extent",
      field: t,
      signal: n
    };
  }
}
class bf extends Ne {
  clone() {
    return new bf(null, { ...this.filter });
  }
  constructor(t, n) {
    super(t), this.filter = n;
  }
  static make(t, n) {
    const { config: i, mark: r, markDef: o } = n;
    if (Me("invalid", o, i) !== "filter")
      return null;
    const s = n.reduceFieldDef((u, l, c) => {
      const f = mo(c) && n.getScaleComponent(c);
      if (f) {
        const d = f.get("type");
        Wn(d) && l.aggregate !== "count" && !Ea(r) && (u[l.field] = l);
      }
      return u;
    }, {});
    return B(s).length ? new bf(t, s) : null;
  }
  dependentFields() {
    return new Set(B(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${ge(this.filter)}`;
  }
  assemble() {
    const t = B(this.filter).reduce((n, i) => {
      const r = this.filter[i], o = H(r, { expr: "datum" });
      return r !== null && (r.type === "temporal" ? n.push(`(isDate(${o}) || (isValid(${o}) && isFinite(+${o})))`) : r.type === "quantitative" && (n.push(`isValid(${o})`), n.push(`isFinite(+${o})`))), n;
    }, []);
    return t.length > 0 ? {
      type: "filter",
      expr: t.join(" && ")
    } : null;
  }
}
class r0 extends Ne {
  clone() {
    return new r0(this.parent, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = ae(n);
    const { flatten: i, as: r = [] } = this.transform;
    this.transform.as = i.map((o, a) => {
      var s;
      return (s = r[a]) != null ? s : o;
    });
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { flatten: t, as: n } = this.transform;
    return {
      type: "flatten",
      fields: t,
      as: n
    };
  }
}
class o0 extends Ne {
  clone() {
    return new o0(null, ae(this.transform));
  }
  constructor(t, n) {
    var r, o, a;
    super(t), this.transform = n, this.transform = ae(n);
    const i = (r = this.transform.as) != null ? r : [void 0, void 0];
    this.transform.as = [(o = i[0]) != null ? o : "key", (a = i[1]) != null ? a : "value"];
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { fold: t, as: n } = this.transform;
    return {
      type: "fold",
      fields: t,
      as: n
    };
  }
}
class Su extends Ne {
  clone() {
    return new Su(null, ae(this.fields), this.geojson, this.signal);
  }
  static parseAll(t, n) {
    if (n.component.projection && !n.component.projection.isFit)
      return t;
    let i = 0;
    for (const r of [
      [qi, Ui],
      [oi, Wi]
    ]) {
      const o = r.map((a) => {
        const s = st(n.encoding[a]);
        return q(s) ? s.field : Nr(s) ? { expr: `${s.datum}` } : Ri(s) ? { expr: `${s.value}` } : void 0;
      });
      (o[0] || o[1]) && (t = new Su(t, o, null, n.getName(`geojson_${i++}`)));
    }
    if (n.channelHasField(kn)) {
      const r = n.typedFieldDef(kn);
      r.type === $l && (t = new Su(t, null, r.field, n.getName(`geojson_${i++}`)));
    }
    return t;
  }
  constructor(t, n, i, r) {
    super(t), this.fields = n, this.geojson = i, this.signal = r;
  }
  dependentFields() {
    var n;
    const t = ((n = this.fields) != null ? n : []).filter(Y);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...t]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${ge(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      {
        type: "geojson",
        ...this.fields ? { fields: this.fields } : {},
        ...this.geojson ? { geojson: this.geojson } : {},
        signal: this.signal
      }
    ];
  }
}
class xf extends Ne {
  clone() {
    return new xf(null, this.projection, ae(this.fields), ae(this.as));
  }
  constructor(t, n, i, r) {
    super(t), this.projection = n, this.fields = i, this.as = r;
  }
  static parseAll(t, n) {
    if (!n.projectionName())
      return t;
    for (const i of [
      [qi, Ui],
      [oi, Wi]
    ]) {
      const r = i.map((a) => {
        const s = st(n.encoding[a]);
        return q(s) ? s.field : Nr(s) ? { expr: `${s.datum}` } : Ri(s) ? { expr: `${s.value}` } : void 0;
      }), o = i[0] === oi ? "2" : "";
      (r[0] || r[1]) && (t = new xf(t, n.projectionName(), r, [
        n.getName(`x${o}`),
        n.getName(`y${o}`)
      ]));
    }
    return t;
  }
  dependentFields() {
    return new Set(this.fields.filter(Y));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${ge(this.fields)} ${ge(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
}
class rs extends Ne {
  clone() {
    return new rs(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    var t;
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...(t = this.transform.groupby) != null ? t : []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(t) {
    const { start: n = 0, stop: i, step: r } = t;
    return { signal: `sequence(${[n, i, ...r ? [r] : []].join(",")})` };
  }
  static makeFromTransform(t, n) {
    return new rs(t, n);
  }
  static makeFromEncoding(t, n) {
    const i = n.encoding, r = i.x, o = i.y;
    if (q(r) && q(o)) {
      const a = r.impute ? r : o.impute ? o : void 0;
      if (a === void 0)
        return;
      const s = r.impute ? o : o.impute ? r : void 0, { method: u, value: l, frame: c, keyvals: f } = a.impute, d = K6(n.mark, i);
      return new rs(t, {
        impute: a.field,
        key: s.field,
        ...u ? { method: u } : {},
        ...l !== void 0 ? { value: l } : {},
        ...c ? { frame: c } : {},
        ...f !== void 0 ? { keyvals: f } : {},
        ...d.length ? { groupby: d } : {}
      });
    }
    return null;
  }
  hash() {
    return `Impute ${ge(this.transform)}`;
  }
  assemble() {
    const { impute: t, key: n, keyvals: i, method: r, groupby: o, value: a, frame: s = [null, null] } = this.transform, u = {
      type: "impute",
      field: t,
      key: n,
      ...i ? { keyvals: Nse(i) ? this.processSequence(i) : i } : {},
      method: "value",
      ...o ? { groupby: o } : {},
      value: !r || r === "value" ? a : null
    };
    if (r && r !== "value") {
      const l = {
        type: "window",
        as: [`imputed_${t}_value`],
        ops: [r],
        fields: [t],
        frame: s,
        ignorePeers: !1,
        ...o ? { groupby: o } : {}
      }, c = {
        type: "formula",
        expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
        as: t
      };
      return [u, l, c];
    } else
      return [u];
  }
}
class a0 extends Ne {
  clone() {
    return new a0(null, ae(this.transform));
  }
  constructor(t, n) {
    var r, o, a;
    super(t), this.transform = n, this.transform = ae(n);
    const i = (r = this.transform.as) != null ? r : [void 0, void 0];
    this.transform.as = [(o = i[0]) != null ? o : n.on, (a = i[1]) != null ? a : n.loess];
  }
  dependentFields() {
    var t;
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...(t = this.transform.groupby) != null ? t : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { loess: t, on: n, ...i } = this.transform;
    return {
      type: "loess",
      x: n,
      y: t,
      ...i
    };
  }
}
class wf extends Ne {
  clone() {
    return new wf(null, ae(this.transform), this.secondary);
  }
  constructor(t, n, i) {
    super(t), this.transform = n, this.secondary = i;
  }
  static make(t, n, i, r) {
    const o = n.component.data.sources, { from: a } = i;
    let s = null;
    if (Dse(a)) {
      let u = R4(a.data, o);
      u || (u = new As(a.data), o.push(u));
      const l = n.getName(`lookup_${r}`);
      s = new rn(u, l, Ie.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[l] = s;
    } else if (Rse(a)) {
      const u = a.param;
      i = { as: u, ...i };
      let l;
      try {
        l = n.getSelectionComponent(We(u), u);
      } catch {
        throw new Error(sre(u));
      }
      if (s = l.materialized, !s)
        throw new Error(ure(u));
    }
    return new wf(t, i, s.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? X(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${ge({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let t;
    if (this.transform.from.fields)
      t = {
        values: this.transform.from.fields,
        ...this.transform.as ? { as: X(this.transform.as) } : {}
      };
    else {
      let n = this.transform.as;
      Y(n) || (U(mre), n = "_lookup"), t = {
        as: [n]
      };
    }
    return {
      type: "lookup",
      from: this.secondary,
      key: this.transform.from.key,
      fields: [this.transform.lookup],
      ...t,
      ...this.transform.default ? { default: this.transform.default } : {}
    };
  }
}
class s0 extends Ne {
  clone() {
    return new s0(null, ae(this.transform));
  }
  constructor(t, n) {
    var r, o, a;
    super(t), this.transform = n, this.transform = ae(n);
    const i = (r = this.transform.as) != null ? r : [void 0, void 0];
    this.transform.as = [(o = i[0]) != null ? o : "prob", (a = i[1]) != null ? a : "value"];
  }
  dependentFields() {
    var t;
    return /* @__PURE__ */ new Set([this.transform.quantile, ...(t = this.transform.groupby) != null ? t : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { quantile: t, ...n } = this.transform;
    return {
      type: "quantile",
      field: t,
      ...n
    };
  }
}
class u0 extends Ne {
  clone() {
    return new u0(null, ae(this.transform));
  }
  constructor(t, n) {
    var r, o, a;
    super(t), this.transform = n, this.transform = ae(n);
    const i = (r = this.transform.as) != null ? r : [void 0, void 0];
    this.transform.as = [(o = i[0]) != null ? o : n.on, (a = i[1]) != null ? a : n.regression];
  }
  dependentFields() {
    var t;
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...(t = this.transform.groupby) != null ? t : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { regression: t, on: n, ...i } = this.transform;
    return {
      type: "regression",
      x: n,
      y: t,
      ...i
    };
  }
}
class l0 extends Ne {
  clone() {
    return new l0(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    var n;
    this.transform.groupby = or(((n = this.transform.groupby) != null ? n : []).concat(t), (i) => i);
  }
  producedFields() {
  }
  dependentFields() {
    var t;
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...(t = this.transform.groupby) != null ? t : []]);
  }
  hash() {
    return `PivotTransform ${ge(this.transform)}`;
  }
  assemble() {
    const { pivot: t, value: n, groupby: i, limit: r, op: o } = this.transform;
    return {
      type: "pivot",
      field: t,
      value: n,
      ...r !== void 0 ? { limit: r } : {},
      ...o !== void 0 ? { op: o } : {},
      ...i !== void 0 ? { groupby: i } : {}
    };
  }
}
class c0 extends Ne {
  clone() {
    return new c0(null, ae(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${ge(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
}
function N4(e) {
  let t = 0;
  function n(i, r) {
    var o;
    if (i instanceof As && !i.isGenerator && !nl(i.data) && (e.push(r), r = {
      name: null,
      source: r.name,
      transform: []
    }), i instanceof zt && (i.parent instanceof As && !r.source ? (r.format = {
      ...(o = r.format) != null ? o : {},
      parse: i.assembleFormatParse()
    }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof Fl) {
      r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
      return;
    }
    switch ((i instanceof dd || i instanceof hd || i instanceof bf || i instanceof Cl || i instanceof rl || i instanceof xf || i instanceof Mi || i instanceof wf || i instanceof Ml || i instanceof qs || i instanceof o0 || i instanceof r0 || i instanceof n0 || i instanceof a0 || i instanceof s0 || i instanceof u0 || i instanceof sa || i instanceof c0 || i instanceof l0 || i instanceof i0) && r.transform.push(i.assemble()), (i instanceof dr || i instanceof fr || i instanceof rs || i instanceof no || i instanceof Su) && r.transform.push(...i.assemble()), i instanceof rn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof rn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
      name: null,
      source: r.name,
      transform: []
    }))), i.numChildren()) {
      case 0:
        i instanceof rn && (!r.source || r.transform.length > 0) && e.push(r);
        break;
      case 1:
        n(i.children[0], r);
        break;
      default: {
        r.name || (r.name = `data_${t++}`);
        let a = r.name;
        !r.source || r.transform.length > 0 ? e.push(r) : a = r.source;
        for (const s of i.children)
          n(s, {
            name: null,
            source: a,
            transform: []
          });
        break;
      }
    }
  }
  return n;
}
function Hce(e) {
  const t = [], n = N4(t);
  for (const i of e.children)
    n(i, {
      source: e.name,
      name: null,
      transform: []
    });
  return t;
}
function Yce(e, t) {
  var a, s;
  const n = [], i = N4(n);
  let r = 0;
  for (const u of e.sources) {
    u.hasName() || (u.dataName = `source_${r++}`);
    const l = u.assemble();
    i(u, l);
  }
  for (const u of n)
    u.transform.length === 0 && delete u.transform;
  let o = 0;
  for (const [u, l] of n.entries())
    ((a = l.transform) != null ? a : []).length === 0 && !l.source && n.splice(o++, 0, n.splice(u, 1)[0]);
  for (const u of n)
    for (const l of (s = u.transform) != null ? s : [])
      l.type === "lookup" && (l.from = e.outputNodes[l.from].getSource());
  for (const u of n)
    u.name in t && (u.values = t[u.name]);
  return n;
}
function Xce(e) {
  return e === "top" || e === "left" || Z(e) ? "header" : "footer";
}
function Vce(e) {
  for (const t of Jn)
    Kce(e, t);
  MC(e, "x"), MC(e, "y");
}
function Kce(e, t) {
  var a;
  const { facet: n, config: i, child: r, component: o } = e;
  if (e.channelHasField(t)) {
    const s = n[t], u = al("title", null, i, t);
    let l = Eu(s, i, {
      allowDisabling: !0,
      includeDefault: u === void 0 || !!u
    });
    r.component.layoutHeaders[t].title && (l = P(l) ? l.join(", ") : l, l += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
    const c = al("labelOrient", s.header, i, t), f = s.header !== null ? tt((a = s.header) == null ? void 0 : a.labels, i.header.labels, !0) : !1, d = me(["bottom", "right"], c) ? "footer" : "header";
    o.layoutHeaders[t] = {
      title: s.header !== null ? l : null,
      facetFieldDef: s,
      [d]: t === "facet" ? [] : [D4(e, t, f)]
    };
  }
}
function D4(e, t, n) {
  const i = t === "row" ? "height" : "width";
  return {
    labels: n,
    sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0,
    axes: []
  };
}
function MC(e, t) {
  var i;
  const { child: n } = e;
  if (n.component.axes[t]) {
    const { layoutHeaders: r, resolve: o } = e.component;
    if (o.axis[t] = h_(o, t), o.axis[t] === "shared") {
      const a = t === "x" ? "column" : "row", s = r[a];
      for (const u of n.component.axes[t]) {
        const l = Xce(u.get("orient"));
        (i = s[l]) != null || (s[l] = [D4(e, a, !1)]);
        const c = kc(u, "main", e.config, { header: !0 });
        c && s[l][0].axes.push(c), u.mainExtracted = !0;
      }
    }
  }
}
function Jce(e) {
  w_(e), og(e, "width"), og(e, "height");
}
function Qce(e) {
  w_(e);
  const t = e.layout.columns === 1 ? "width" : "childWidth", n = e.layout.columns === void 0 ? "height" : "childHeight";
  og(e, t), og(e, n);
}
function w_(e) {
  for (const t of e.children)
    t.parseLayoutSize();
}
function og(e, t) {
  var s;
  const n = a4(t), i = Tm(n), r = e.component.resolve, o = e.component.layoutSize;
  let a;
  for (const u of e.children) {
    const l = u.component.layoutSize.getWithExplicit(n), c = (s = r.scale[i]) != null ? s : u4(i, e);
    if (c === "independent" && l.value === "step") {
      a = void 0;
      break;
    }
    if (a) {
      if (c === "independent" && a.value !== l.value) {
        a = void 0;
        break;
      }
      a = ra(a, l, n, "");
    } else
      a = l;
  }
  if (a) {
    for (const u of e.children)
      e.renameSignal(u.getName(n), e.getName(t)), u.component.layoutSize.set(n, "merged", !1);
    o.setWithExplicit(t, a);
  } else
    o.setWithExplicit(t, {
      explicit: !1,
      value: void 0
    });
}
function Zce(e) {
  const { size: t, component: n } = e;
  for (const i of Or) {
    const r = Cn(i);
    if (t[r]) {
      const o = t[r];
      n.layoutSize.set(r, wr(o) ? "step" : o, !0);
    } else {
      const o = efe(e, r);
      n.layoutSize.set(r, o, !1);
    }
  }
}
function efe(e, t) {
  const n = t === "width" ? "x" : "y", i = e.config, r = e.getScaleComponent(n);
  if (r) {
    const o = r.get("type"), a = r.get("range");
    if (wt(o)) {
      const s = tg(i.view, t);
      return wa(a) || wr(s) ? "step" : s;
    } else
      return zv(i.view, t);
  } else {
    if (e.hasProjection || e.mark === "arc")
      return zv(i.view, t);
    {
      const o = tg(i.view, t);
      return wr(o) ? o.step : o;
    }
  }
}
function Zv(e, t, n) {
  return H(t, { suffix: `by_${H(e)}`, ...n != null ? n : {} });
}
class qc extends O4 {
  constructor(t, n, i, r) {
    super(t, "facet", n, i, r, t.resolve), this.child = $_(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet);
  }
  initFacet(t) {
    if (!sd(t))
      return { facet: this.initFacetFieldDef(t, "facet") };
    const n = B(t), i = {};
    for (const r of n) {
      if (![Zr, eo].includes(r)) {
        U(Dm(r, "facet"));
        break;
      }
      const o = t[r];
      if (o.field === void 0) {
        U(Nv(o, r));
        break;
      }
      i[r] = this.initFacetFieldDef(o, r);
    }
    return i;
  }
  initFacetFieldDef(t, n) {
    const i = WE(t, n);
    return i.header ? i.header = pn(i.header) : i.header === null && (i.header = null), i;
  }
  channelHasField(t) {
    return !!this.facet[t];
  }
  fieldDef(t) {
    return this.facet[t];
  }
  parseData() {
    this.component.data = f0(this), this.child.parseData();
  }
  parseLayoutSize() {
    w_(this);
  }
  parseSelections() {
    this.child.parseSelections(), this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders(), Vce(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.child.assembleSelectionTopLevelSignals(t);
  }
  assembleSignals() {
    return this.child.assembleSignals(), [];
  }
  assembleSelectionData(t) {
    return this.child.assembleSelectionData(t);
  }
  getHeaderLayoutMixins() {
    var n, i, r;
    const t = {};
    for (const o of Jn)
      for (const a of f_) {
        const s = this.component.layoutHeaders[o], u = s[a], { facetFieldDef: l } = s;
        if (l) {
          const c = al("titleOrient", l.header, this.config, o);
          if (["right", "bottom"].includes(c)) {
            const f = Zm(o, c);
            (n = t.titleAnchor) != null || (t.titleAnchor = {}), t.titleAnchor[f] = "end";
          }
        }
        if (u != null && u[0]) {
          const c = o === "row" ? "height" : "width", f = a === "header" ? "headerBand" : "footerBand";
          o !== "facet" && !this.child.component.layoutSize.get(c) && ((i = t[f]) != null || (t[f] = {}), t[f][o] = 0.5), s.title && ((r = t.offset) != null || (t.offset = {}), t.offset[o === "row" ? "rowTitle" : "columnTitle"] = 10);
        }
      }
    return t;
  }
  assembleDefaultLayout() {
    const { column: t, row: n } = this.facet, i = t ? this.columnDistinctSignal() : n ? 1 : void 0;
    let r = "all";
    return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (r = "none"), {
      ...this.getHeaderLayoutMixins(),
      ...i ? { columns: i } : {},
      bounds: "full",
      align: r
    };
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (!(this.parent && this.parent instanceof qc))
      return { signal: `length(data('${this.getName("column_domain")}'))` };
  }
  assembleGroupStyle() {
  }
  assembleGroup(t) {
    return this.parent && this.parent instanceof qc ? {
      ...this.channelHasField("column") ? {
        encode: {
          update: {
            columns: { field: H(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {},
      ...super.assembleGroup(t)
    } : super.assembleGroup(t);
  }
  getCardinalityAggregateForChild() {
    const t = [], n = [], i = [];
    if (this.child instanceof qc) {
      if (this.child.channelHasField("column")) {
        const r = H(this.child.facet.column);
        t.push(r), n.push("distinct"), i.push(`distinct_${r}`);
      }
    } else
      for (const r of Or) {
        const o = this.child.component.scales[r];
        if (o && !o.merged) {
          const a = o.get("type"), s = o.get("range");
          if (wt(a) && wa(s)) {
            const u = t0(this.child, r), l = v_(u);
            l ? (t.push(l), n.push("distinct"), i.push(`distinct_${l}`)) : U(vE(r));
          }
        }
      }
    return { fields: t, ops: n, as: i };
  }
  assembleFacet() {
    const { name: t, data: n } = this.component.data.facetRoot, { row: i, column: r } = this.facet, { fields: o, ops: a, as: s } = this.getCardinalityAggregateForChild(), u = [];
    for (const c of Jn) {
      const f = this.facet[c];
      if (f) {
        u.push(H(f));
        const { bin: d, sort: h } = f;
        if (ze(d) && u.push(H(f, { binSuffix: "end" })), cr(h)) {
          const { field: p, op: g = Bm } = h, m = Zv(f, h);
          i && r ? (o.push(m), a.push("max"), s.push(m)) : (o.push(p), a.push(g), s.push(m));
        } else if (P(h)) {
          const p = ol(f, c);
          o.push(p), a.push("max"), s.push(p);
        }
      }
    }
    const l = !!i && !!r;
    return {
      name: t,
      data: n,
      groupby: u,
      ...l || o.length > 0 ? {
        aggregate: {
          ...l ? { cross: l } : {},
          ...o.length ? { fields: o, ops: a, as: s } : {}
        }
      } : {}
    };
  }
  facetSortFields(t) {
    const { facet: n } = this, i = n[t];
    return i ? cr(i.sort) ? [Zv(i, i.sort, { expr: "datum" })] : P(i.sort) ? [ol(i, t, { expr: "datum" })] : [H(i, { expr: "datum" })] : [];
  }
  facetSortOrder(t) {
    const { facet: n } = this, i = n[t];
    if (i) {
      const { sort: r } = i;
      return [(cr(r) ? r.order : !P(r) && r) || "ascending"];
    }
    return [];
  }
  assembleLabelTitle() {
    var r;
    const { facet: t, config: n } = this;
    if (t.facet)
      return Yv(t.facet, "facet", n);
    const i = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const o of c_)
      if (t[o]) {
        const a = al("labelOrient", (r = t[o]) == null ? void 0 : r.header, n, o);
        if (i[o].includes(a))
          return Yv(t[o], o, n);
      }
  }
  assembleMarks() {
    const { child: t } = this, n = this.component.data.facetRoot, i = Hce(n), r = t.assembleGroupEncodeEntry(!1), o = this.assembleLabelTitle() || t.assembleTitle(), a = t.assembleGroupStyle();
    return [{
      name: this.getName("cell"),
      type: "group",
      ...o ? { title: o } : {},
      ...a ? { style: a } : {},
      from: {
        facet: this.assembleFacet()
      },
      sort: {
        field: Jn.map((u) => this.facetSortFields(u)).flat(),
        order: Jn.map((u) => this.facetSortOrder(u)).flat()
      },
      ...i.length > 0 ? { data: i } : {},
      ...r ? { encode: { update: r } } : {},
      ...t.assembleGroup(fue(this, []))
    }];
  }
  getMapping() {
    return this.facet;
  }
}
function tfe(e, t) {
  const { row: n, column: i } = t;
  if (n && i) {
    let r = null;
    for (const o of [n, i])
      if (cr(o.sort)) {
        const { field: a, op: s = Bm } = o.sort;
        e = r = new qs(e, {
          joinaggregate: [
            {
              op: s,
              field: a,
              as: Zv(o, o.sort, { forAs: !0 })
            }
          ],
          groupby: [H(o)]
        });
      }
    return r;
  }
  return null;
}
function R4(e, t) {
  var n, i, r, o;
  for (const a of t) {
    const s = a.data;
    if (e.name && a.hasName() && e.name !== a.dataName)
      continue;
    const u = (n = e.format) == null ? void 0 : n.mesh, l = (i = s.format) == null ? void 0 : i.feature;
    if (u && l)
      continue;
    const c = (r = e.format) == null ? void 0 : r.feature;
    if ((c || l) && c !== l)
      continue;
    const f = (o = s.format) == null ? void 0 : o.mesh;
    if (!((u || f) && u !== f)) {
      if (vf(e) && vf(s)) {
        if (rr(e.values, s.values))
          return a;
      } else if (nl(e) && nl(s)) {
        if (e.url === s.url)
          return a;
      } else if ($L(e) && e.name === a.dataName)
        return a;
    }
  }
  return null;
}
function nfe(e, t) {
  if (e.data || !e.parent) {
    if (e.data === null) {
      const i = new As({ values: [] });
      return t.push(i), i;
    }
    const n = R4(e.data, t);
    if (n)
      return Wo(e.data) || (n.data.format = wR({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n;
    {
      const i = new As(e.data);
      return t.push(i), i;
    }
  } else
    return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main;
}
function ife(e, t, n) {
  var r, o;
  let i = 0;
  for (const a of t.transforms) {
    let s, u;
    if (Gse(a))
      u = e = new rl(e, a), s = "derived";
    else if (i_(a)) {
      const l = Xle(a);
      u = e = (r = zt.makeWithAncestors(e, {}, l, n)) != null ? r : e, e = new Cl(e, t, a.filter);
    } else if (wL(a))
      u = e = dr.makeFromTransform(e, a, t), s = "number";
    else if (Yse(a))
      s = "date", n.getWithExplicit(a.field).value === void 0 && (e = new zt(e, { [a.field]: s }), n.set(a.field, s, !1)), u = e = fr.makeFromTransform(e, a);
    else if (Xse(a))
      u = e = Mi.makeFromTransform(e, a), s = "number", l_(t) && (e = new sa(e));
    else if (xL(a))
      u = e = wf.make(e, t, a, i++), s = "derived";
    else if (Use(a))
      u = e = new Ml(e, a), s = "number";
    else if (qse(a))
      u = e = new qs(e, a), s = "number";
    else if (Vse(a))
      u = e = no.makeFromTransform(e, a), s = "derived";
    else if (Kse(a))
      u = e = new o0(e, a), s = "derived";
    else if (Jse(a))
      u = e = new i0(e, a), s = "derived";
    else if (Wse(a))
      u = e = new r0(e, a), s = "derived";
    else if (Lse(a))
      u = e = new l0(e, a), s = "derived";
    else if (jse(a))
      e = new c0(e, a);
    else if (Hse(a))
      u = e = rs.makeFromTransform(e, a), s = "derived";
    else if (Ise(a))
      u = e = new n0(e, a), s = "derived";
    else if (Pse(a))
      u = e = new s0(e, a), s = "derived";
    else if (zse(a))
      u = e = new u0(e, a), s = "derived";
    else if (Bse(a))
      u = e = new a0(e, a), s = "derived";
    else {
      U(gre(a));
      continue;
    }
    if (u && s !== void 0)
      for (const l of (o = u.producedFields()) != null ? o : [])
        n.set(l, s, !1);
  }
  return e;
}
function f0(e) {
  var g, m, y, v, b, x, E, _, w, S;
  let t = nfe(e, e.component.data.sources);
  const { outputNodes: n, outputNodeRefCounts: i } = e.component.data, r = e.data, a = !(r && (Wo(r) || nl(r) || vf(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new lue();
  Wo(r) ? (kL(r) ? t = new hd(t, r.sequence) : r_(r) && (t = new dd(t, r.graticule)), a.parseNothing = !0) : ((g = r == null ? void 0 : r.format) == null ? void 0 : g.parse) === null && (a.parseNothing = !0), t = (m = zt.makeExplicit(t, e, a)) != null ? m : t, t = new sa(t);
  const s = e.parent && Tl(e.parent);
  (Je(e) || Ti(e)) && s && (t = (y = dr.makeFromEncoding(t, e)) != null ? y : t), e.transforms.length > 0 && (t = ife(t, e, a));
  const u = Kle(e), l = Vle(e);
  t = (v = zt.makeWithAncestors(t, {}, { ...u, ...l }, a)) != null ? v : t, Je(e) && (t = Su.parseAll(t, e), t = xf.parseAll(t, e)), (Je(e) || Ti(e)) && (s || (t = (b = dr.makeFromEncoding(t, e)) != null ? b : t), t = (x = fr.makeFromEncoding(t, e)) != null ? x : t, t = rl.parseAllForSortIndex(t, e));
  const c = e.getDataName(Ie.Raw), f = new rn(t, c, Ie.Raw, i);
  if (n[c] = f, t = f, Je(e)) {
    const C = Mi.makeFromEncoding(t, e);
    C && (t = C, l_(e) && (t = new sa(t))), t = (E = rs.makeFromEncoding(t, e)) != null ? E : t, t = (_ = no.makeFromEncoding(t, e)) != null ? _ : t;
  }
  Je(e) && (t = (w = bf.make(t, e)) != null ? w : t);
  const d = e.getDataName(Ie.Main), h = new rn(t, d, Ie.Main, i);
  n[d] = h, t = h, Je(e) && Gue(e, h);
  let p = null;
  if (Ti(e)) {
    const C = e.getName("facet");
    t = (S = tfe(t, e.facet)) != null ? S : t, p = new Fl(t, e, C, h.getSource()), n[C] = p;
  }
  return {
    ...e.component.data,
    outputNodes: n,
    outputNodeRefCounts: i,
    raw: f,
    main: h,
    facetRoot: p,
    ancestorParse: a
  };
}
class rfe extends x_ {
  constructor(t, n, i, r) {
    var o, a, s, u;
    super(t, "concat", n, i, r, t.resolve), (((a = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : a.x) === "shared" || ((u = (s = t.resolve) == null ? void 0 : s.axis) == null ? void 0 : u.y) === "shared") && U(dre), this.children = this.getChildren(t).map((l, c) => $_(l, this, this.getName(`concat_${c}`), void 0, r));
  }
  parseData() {
    this.component.data = f0(this);
    for (const t of this.children)
      t.parseData();
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of B(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    for (const t of this.children)
      t.parseAxesAndHeaders();
  }
  getChildren(t) {
    return Xm(t) ? t.vconcat : t_(t) ? t.hconcat : t.concat;
  }
  parseLayoutSize() {
    Qce(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
  }
  assembleSignals() {
    return this.children.forEach((t) => t.assembleSignals()), [];
  }
  assembleLayoutSignals() {
    const t = d_(this);
    for (const n of this.children)
      t.push(...n.assembleLayoutSignals());
    return t;
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
  }
  assembleMarks() {
    return this.children.map((t) => {
      const n = t.assembleTitle(), i = t.assembleGroupStyle(), r = t.assembleGroupEncodeEntry(!1);
      return {
        type: "group",
        name: t.getName("group"),
        ...n ? { title: n } : {},
        ...i ? { style: i } : {},
        ...r ? { encode: { update: r } } : {},
        ...t.assembleGroup()
      };
    });
  }
  assembleGroupStyle() {
  }
  assembleDefaultLayout() {
    const t = this.layout.columns;
    return {
      ...t != null ? { columns: t } : {},
      bounds: "full",
      align: "each"
    };
  }
}
function ofe(e) {
  return e === !1 || e === null;
}
const afe = {
  disable: 1,
  gridScale: 1,
  scale: 1,
  ...H6,
  labelExpr: 1,
  encode: 1
}, L4 = B(afe);
class E_ extends vo {
  constructor(t = {}, n = {}, i = !1) {
    super(), this.explicit = t, this.implicit = n, this.mainExtracted = i;
  }
  clone() {
    return new E_(ae(this.explicit), ae(this.implicit), this.mainExtracted);
  }
  hasAxisPart(t) {
    return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !ofe(this.get(t));
  }
  hasOrientSignalRef() {
    return Z(this.explicit.orient);
  }
}
function sfe(e, t, n) {
  var l;
  const { encoding: i, config: r } = e, o = (l = st(i[t])) != null ? l : st(i[Tr(t)]), a = e.axis(t) || {}, { format: s, formatType: u } = a;
  if (Es(u))
    return {
      text: ki({
        fieldOrDatumDef: o,
        field: "datum.value",
        format: s,
        formatType: u,
        config: r
      }),
      ...n
    };
  if (s === void 0 && u === void 0 && r.customFormatTypes) {
    if (Zu(o) === "quantitative") {
      if (el(o) && o.stack === "normalize" && r.normalizedNumberFormatType)
        return {
          text: ki({
            fieldOrDatumDef: o,
            field: "datum.value",
            format: r.normalizedNumberFormat,
            formatType: r.normalizedNumberFormatType,
            config: r
          }),
          ...n
        };
      if (r.numberFormatType)
        return {
          text: ki({
            fieldOrDatumDef: o,
            field: "datum.value",
            format: r.numberFormat,
            formatType: r.numberFormatType,
            config: r
          }),
          ...n
        };
    }
    if (Zu(o) === "temporal" && r.timeFormatType && q(o) && !o.timeUnit)
      return {
        text: ki({
          fieldOrDatumDef: o,
          field: "datum.value",
          format: r.timeFormat,
          formatType: r.timeFormatType,
          config: r
        }),
        ...n
      };
  }
  return n;
}
function ufe(e) {
  return Or.reduce((t, n) => (e.component.scales[n] && (t[n] = [gfe(n, e)]), t), {});
}
const lfe = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function cfe(e) {
  var r;
  const { axes: t, resolve: n } = e.component, i = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const o of e.children) {
    o.parseAxesAndHeaders();
    for (const a of B(o.component.axes))
      n.axis[a] = h_(e.component.resolve, a), n.axis[a] === "shared" && (t[a] = ffe(t[a], o.component.axes[a]), t[a] || (n.axis[a] = "independent", delete t[a]));
  }
  for (const o of Or) {
    for (const a of e.children)
      if (!!a.component.axes[o]) {
        if (n.axis[o] === "independent") {
          t[o] = ((r = t[o]) != null ? r : []).concat(a.component.axes[o]);
          for (const s of a.component.axes[o]) {
            const { value: u, explicit: l } = s.getWithExplicit("orient");
            if (!Z(u)) {
              if (i[u] > 0 && !l) {
                const c = lfe[u];
                i[u] > i[c] && s.set("orient", c, !1);
              }
              i[u]++;
            }
          }
        }
        delete a.component.axes[o];
      }
    if (n.axis[o] === "independent" && t[o] && t[o].length > 1)
      for (const [a, s] of (t[o] || []).entries())
        a > 0 && !!s.get("grid") && !s.explicit.grid && (s.implicit.grid = !1);
  }
}
function ffe(e, t) {
  if (e) {
    if (e.length !== t.length)
      return;
    const n = e.length;
    for (let i = 0; i < n; i++) {
      const r = e[i], o = t[i];
      if (!!r != !!o)
        return;
      if (r && o) {
        const a = r.getWithExplicit("orient"), s = o.getWithExplicit("orient");
        if (a.explicit && s.explicit && a.value !== s.value)
          return;
        e[i] = dfe(r, o);
      }
    }
  } else
    return t.map((n) => n.clone());
  return e;
}
function dfe(e, t) {
  for (const n of L4) {
    const i = ra(
      e.getWithExplicit(n),
      t.getWithExplicit(n),
      n,
      "axis",
      (r, o) => {
        switch (n) {
          case "title":
            return KR(r, o);
          case "gridScale":
            return {
              explicit: r.explicit,
              value: tt(r.value, o.value)
            };
        }
        return Km(r, o, n, "axis");
      }
    );
    e.setWithExplicit(n, i);
  }
  return e;
}
function hfe(e, t, n, i, r) {
  if (t === "disable")
    return n !== void 0;
  switch (n = n || {}, t) {
    case "titleAngle":
    case "labelAngle":
      return e === (Z(n.labelAngle) ? n.labelAngle : yf(n.labelAngle));
    case "values":
      return !!n.values;
    case "encode":
      return !!n.encoding || !!n.labelAngle;
    case "title":
      if (e === t4(i, r))
        return !0;
  }
  return e === n[t];
}
const pfe = /* @__PURE__ */ new Set([
  "grid",
  "translate",
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function gfe(e, t) {
  var y, v, b;
  let n = t.axis(e);
  const i = new E_(), r = st(t.encoding[e]), { mark: o, config: a } = t, s = (n == null ? void 0 : n.orient) || ((y = a[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((v = a.axis) == null ? void 0 : v.orient) || tle(e), u = t.getScaleComponent(e).get("type"), l = Xue(e, u, s, t.config), c = n !== void 0 ? !n : Gv("disable", a.style, n == null ? void 0 : n.style, l).configValue;
  if (i.set("disable", c, n !== void 0), c)
    return i;
  n = n || {};
  const f = Que(r, n, e, a.style, l), d = M6(n.formatType, r, u), h = F6(r, r.type, n.format, n.formatType, a, !0), p = {
    fieldOrDatumDef: r,
    axis: n,
    channel: e,
    model: t,
    scaleType: u,
    orient: s,
    labelAngle: f,
    format: h,
    formatType: d,
    mark: o,
    config: a
  };
  for (const x of L4) {
    const E = x in gC ? gC[x](p) : Wk(x) ? n[x] : void 0, _ = E !== void 0, w = hfe(E, x, n, t, e);
    if (_ && w)
      i.set(x, E, w);
    else {
      const { configValue: S = void 0, configFrom: C = void 0 } = Wk(x) && x !== "values" ? Gv(x, a.style, n.style, l) : {}, $ = S !== void 0;
      _ && !$ ? i.set(x, E, w) : (C !== "vgAxisConfig" || pfe.has(x) && $ || cd(S) || Z(S)) && i.set(x, S, !1);
    }
  }
  const g = (b = n.encoding) != null ? b : {}, m = G6.reduce((x, E) => {
    var S;
    if (!i.hasAxisPart(E))
      return x;
    const _ = s4((S = g[E]) != null ? S : {}, t), w = E === "labels" ? sfe(t, e, _) : _;
    return w !== void 0 && !De(w) && (x[E] = { update: w }), x;
  }, {});
  return De(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i;
}
function mfe({ encoding: e, size: t }) {
  for (const n of Or) {
    const i = Cn(n);
    wr(t[i]) && Po(e[n]) && (delete t[i], U(t6(i)));
  }
  return t;
}
const yfe = {
  vgMark: "arc",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Pt("x", e, { defaultPos: "mid" }),
    ...Pt("y", e, { defaultPos: "mid" }),
    ...oa(e, "radius"),
    ...oa(e, "theta")
  })
}, vfe = {
  vgMark: "area",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    }),
    ...ng("x", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "horizontal"
    }),
    ...ng("y", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "vertical"
    }),
    ...u_(e)
  })
}, bfe = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...oa(e, "x"),
    ...oa(e, "y")
  })
}, xfe = {
  vgMark: "shape",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })
  }),
  postEncodingTransform: (e) => {
    const { encoding: t } = e, n = t.shape;
    return [{
      type: "geoshape",
      projection: e.projectionName(),
      ...n && q(n) && n.type === $l ? { field: H(n, { expr: "datum" }) } : {}
    }];
  }
}, wfe = {
  vgMark: "image",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...oa(e, "x"),
    ...oa(e, "y"),
    ...a_(e, "url")
  })
}, Efe = {
  vgMark: "line",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Pt("x", e, { defaultPos: "mid" }),
    ...Pt("y", e, { defaultPos: "mid" }),
    ...dt("size", e, {
      vgChannel: "strokeWidth"
    }),
    ...u_(e)
  })
}, _fe = {
  vgMark: "trail",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Pt("x", e, { defaultPos: "mid" }),
    ...Pt("y", e, { defaultPos: "mid" }),
    ...dt("size", e),
    ...u_(e)
  })
};
function __(e, t) {
  const { config: n } = e;
  return {
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Pt("x", e, { defaultPos: "mid" }),
    ...Pt("y", e, { defaultPos: "mid" }),
    ...dt("size", e),
    ...dt("angle", e),
    ...Sfe(e, n, t)
  };
}
function Sfe(e, t, n) {
  return n ? { shape: { value: n } } : dt("shape", e);
}
const Afe = {
  vgMark: "symbol",
  encodeEntry: (e) => __(e)
}, $fe = {
  vgMark: "symbol",
  encodeEntry: (e) => __(e, "circle")
}, kfe = {
  vgMark: "symbol",
  encodeEntry: (e) => __(e, "square")
}, Cfe = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...ui(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...oa(e, "x"),
    ...oa(e, "y")
  })
}, Ffe = {
  vgMark: "rule",
  encodeEntry: (e) => {
    const { markDef: t } = e, n = t.orient;
    return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
      ...ui(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...ng("x", e, {
        defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "vertical"
      }),
      ...ng("y", e, {
        defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "horizontal"
      }),
      ...dt("size", e, {
        vgChannel: "strokeWidth"
      })
    };
  }
}, Mfe = {
  vgMark: "text",
  encodeEntry: (e) => {
    const { config: t, encoding: n } = e;
    return {
      ...ui(e, {
        align: "include",
        baseline: "include",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "include"
      }),
      ...Pt("x", e, { defaultPos: "mid" }),
      ...Pt("y", e, { defaultPos: "mid" }),
      ...a_(e),
      ...dt("size", e, {
        vgChannel: "fontSize"
      }),
      ...dt("angle", e),
      ...fC("align", Tfe(e.markDef, n, t)),
      ...fC("baseline", Ofe(e.markDef, n, t)),
      ...Pt("radius", e, { defaultPos: null }),
      ...Pt("theta", e, { defaultPos: null })
    };
  }
};
function Tfe(e, t, n) {
  if (Me("align", e, n) === void 0)
    return "center";
}
function Ofe(e, t, n) {
  if (Me("baseline", e, n) === void 0)
    return "middle";
}
const Nfe = {
  vgMark: "rect",
  encodeEntry: (e) => {
    const { config: t, markDef: n } = e, i = n.orient, r = i === "horizontal" ? "width" : "height", o = i === "horizontal" ? "height" : "width";
    return {
      ...ui(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Pt("x", e, { defaultPos: "mid", vgChannel: "xc" }),
      ...Pt("y", e, { defaultPos: "mid", vgChannel: "yc" }),
      ...dt("size", e, {
        defaultValue: Dfe(e),
        vgChannel: r
      }),
      [o]: je(Me("thickness", n, t))
    };
  }
};
function Dfe(e) {
  var s;
  const { config: t, markDef: n } = e, { orient: i } = n, r = i === "horizontal" ? "width" : "height", o = e.getScaleComponent(i === "horizontal" ? "x" : "y"), a = (s = Me("size", n, t, { vgChannel: r })) != null ? s : t.tick.bandSize;
  if (a !== void 0)
    return a;
  {
    const u = o ? o.get("range") : void 0;
    return u && wa(u) && Oe(u.step) ? u.step * 3 / 4 : eg(t.view, r) * 3 / 4;
  }
}
const Yd = {
  arc: yfe,
  area: vfe,
  bar: bfe,
  circle: $fe,
  geoshape: xfe,
  image: wfe,
  line: Efe,
  point: Afe,
  rect: Cfe,
  rule: Ffe,
  square: kfe,
  text: Mfe,
  tick: Nfe,
  trail: _fe
};
function Rfe(e) {
  if (me([Pm, Lm, qoe], e.mark)) {
    const t = K6(e.mark, e.encoding);
    if (t.length > 0)
      return Lfe(e, t);
  } else if (e.mark === Im) {
    const t = Ov.some((n) => Me(n, e.markDef, e.config));
    if (e.stack && !e.fieldDef("size") && t)
      return Ife(e);
  }
  return S_(e);
}
const TC = "faceted_path_";
function Lfe(e, t) {
  return [
    {
      name: e.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: TC + e.requestDataName(Ie.Main),
          data: e.requestDataName(Ie.Main),
          groupby: t
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      marks: S_(e, { fromPrefix: TC })
    }
  ];
}
const OC = "stack_group_";
function Ife(e) {
  var l;
  const [t] = S_(e, { fromPrefix: OC }), n = e.scaleName(e.stack.fieldChannel), i = (c = {}) => e.vgField(e.stack.fieldChannel, c), r = (c, f) => {
    const d = [
      i({ prefix: "min", suffix: "start", expr: f }),
      i({ prefix: "max", suffix: "start", expr: f }),
      i({ prefix: "min", suffix: "end", expr: f }),
      i({ prefix: "max", suffix: "end", expr: f })
    ];
    return `${c}(${d.map((h) => `scale('${n}',${h})`).join(",")})`;
  };
  let o, a;
  e.stack.fieldChannel === "x" ? (o = {
    ...Yu(t.encode.update, ["y", "yc", "y2", "height", ...Ov]),
    x: { signal: r("min", "datum") },
    x2: { signal: r("max", "datum") },
    clip: { value: !0 }
  }, a = {
    x: { field: { group: "x" }, mult: -1 },
    height: { field: { group: "height" } }
  }, t.encode.update = {
    ...bn(t.encode.update, ["y", "yc", "y2"]),
    height: { field: { group: "height" } }
  }) : (o = {
    ...Yu(t.encode.update, ["x", "xc", "x2", "width"]),
    y: { signal: r("min", "datum") },
    y2: { signal: r("max", "datum") },
    clip: { value: !0 }
  }, a = {
    y: { field: { group: "y" }, mult: -1 },
    width: { field: { group: "width" } }
  }, t.encode.update = {
    ...bn(t.encode.update, ["x", "xc", "x2"]),
    width: { field: { group: "width" } }
  });
  for (const c of Ov) {
    const f = so(c, e.markDef, e.config);
    t.encode.update[c] ? (o[c] = t.encode.update[c], delete t.encode.update[c]) : f && (o[c] = je(f)), f && (t.encode.update[c] = { value: 0 });
  }
  const s = [];
  if (((l = e.stack.groupbyChannels) == null ? void 0 : l.length) > 0)
    for (const c of e.stack.groupbyChannels) {
      const f = e.fieldDef(c), d = H(f);
      d && s.push(d), ((f == null ? void 0 : f.bin) || (f == null ? void 0 : f.timeUnit)) && s.push(H(f, { binSuffix: "end" }));
    }
  return o = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ].reduce((c, f) => {
    if (t.encode.update[f])
      return { ...c, [f]: t.encode.update[f] };
    {
      const d = so(f, e.markDef, e.config);
      return d !== void 0 ? { ...c, [f]: je(d) } : c;
    }
  }, o), o.stroke && (o.strokeForeground = { value: !0 }, o.strokeOffset = { value: 0 }), [
    {
      type: "group",
      from: {
        facet: {
          data: e.requestDataName(Ie.Main),
          name: OC + e.requestDataName(Ie.Main),
          groupby: s,
          aggregate: {
            fields: [
              i({ suffix: "start" }),
              i({ suffix: "start" }),
              i({ suffix: "end" }),
              i({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: o
      },
      marks: [
        {
          type: "group",
          encode: { update: a },
          marks: [t]
        }
      ]
    }
  ];
}
function Pfe(e) {
  var s;
  const { encoding: t, stack: n, mark: i, markDef: r, config: o } = e, a = t.order;
  if (!(!P(a) && Ri(a) && Mv(a.value) || !a && Mv(Me("order", r, o)))) {
    if ((P(a) || q(a)) && !n)
      return YR(a, { expr: "datum" });
    if (Ea(i)) {
      const u = r.orient === "horizontal" ? "y" : "x", l = t[u];
      if (q(l)) {
        const c = l.sort;
        if (P(c))
          return {
            field: H(l, { prefix: u, suffix: "sort_index", expr: "datum" })
          };
        if (cr(c))
          return {
            field: H({
              aggregate: GE(e.encoding) ? c.op : void 0,
              field: c.field
            }, { expr: "datum" })
          };
        if (O6(c)) {
          const f = e.fieldDef(c.encoding);
          return {
            field: H(f, { expr: "datum" }),
            order: c.order
          };
        } else
          return c === null ? void 0 : {
            field: H(l, {
              binSuffix: (s = e.stack) != null && s.impute ? "mid" : void 0,
              expr: "datum"
            })
          };
      }
      return;
    }
  }
}
function S_(e, t = { fromPrefix: "" }) {
  const { mark: n, markDef: i, encoding: r, config: o } = e, a = tt(i.clip, zfe(e), Bfe(e)), s = GR(i), u = r.key, l = Pfe(e), c = jfe(e), f = Me("aria", i, o), d = Yd[n].postEncodingTransform ? Yd[n].postEncodingTransform(e) : null;
  return [
    {
      name: e.getName("marks"),
      type: Yd[n].vgMark,
      ...a ? { clip: !0 } : {},
      ...s ? { style: s } : {},
      ...u ? { key: u.field } : {},
      ...l ? { sort: l } : {},
      ...c || {},
      ...f === !1 ? { aria: f } : {},
      from: { data: t.fromPrefix + e.requestDataName(Ie.Main) },
      encode: {
        update: Yd[n].encodeEntry(e)
      },
      ...d ? {
        transform: d
      } : {}
    }
  ];
}
function zfe(e) {
  const t = e.getScaleComponent("x"), n = e.getScaleComponent("y");
  return (t == null ? void 0 : t.get("selectionExtent")) || (n == null ? void 0 : n.get("selectionExtent")) ? !0 : void 0;
}
function Bfe(e) {
  const t = e.component.projection;
  return t && !t.isFit ? !0 : void 0;
}
function jfe(e) {
  if (!e.component.selection)
    return null;
  const t = B(e.component.selection).length;
  let n = t, i = e.parent;
  for (; i && n === 0; )
    n = B(i.component.selection).length, i = i.parent;
  return n ? {
    interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip
  } : null;
}
class I4 extends O4 {
  constructor(t, n, i, r = {}, o) {
    var l;
    super(t, "unit", n, i, o, void 0, Hk(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
    const a = br(t.mark) ? { ...t.mark } : { type: t.mark }, s = a.type;
    a.filled === void 0 && (a.filled = Ase(a, o, {
      graticule: t.data && r_(t.data)
    }));
    const u = this.encoding = Fae(t.encoding || {}, s, a.filled, o);
    this.markDef = yL(a, u, o), this.size = mfe({
      encoding: u,
      size: Hk(t) ? {
        ...r,
        ...t.width ? { width: t.width } : {},
        ...t.height ? { height: t.height } : {}
      } : r
    }), this.stack = mL(this.markDef, u), this.specifiedScales = this.initScales(s, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = ((l = t.params) != null ? l : []).filter((c) => ZE(c));
  }
  get hasProjection() {
    const { encoding: t } = this, n = this.mark === S6, i = t && kie.some((r) => se(t[r]));
    return n || i;
  }
  scaleDomain(t) {
    const n = this.specifiedScales[t];
    return n ? n.domain : void 0;
  }
  axis(t) {
    return this.specifiedAxes[t];
  }
  legend(t) {
    return this.specifiedLegends[t];
  }
  initScales(t, n) {
    return Om.reduce((i, r) => {
      var a;
      const o = st(n[r]);
      return o && (i[r] = this.initScale((a = o.scale) != null ? a : {})), i;
    }, {});
  }
  initScale(t) {
    const { domain: n, range: i } = t, r = pn(t);
    return P(n) && (r.domain = n.map(Ln)), P(i) && (r.range = i.map(Ln)), r;
  }
  initAxes(t) {
    return Or.reduce((n, i) => {
      const r = t[i];
      if (se(r) || i === Ge && se(t.x2) || i === bt && se(t.y2)) {
        const o = se(r) ? r.axis : void 0;
        n[i] = o && this.initAxis({ ...o });
      }
      return n;
    }, {});
  }
  initAxis(t) {
    const n = B(t), i = {};
    for (const r of n) {
      const o = t[r];
      i[r] = cd(o) ? WR(o) : Ln(o);
    }
    return i;
  }
  initLegends(t) {
    return Lie.reduce((n, i) => {
      const r = st(t[i]);
      if (r && Pie(i)) {
        const o = r.legend;
        n[i] = o && pn(o);
      }
      return n;
    }, {});
  }
  parseData() {
    this.component.data = f0(this);
  }
  parseLayoutSize() {
    Zce(this);
  }
  parseSelections() {
    this.component.selection = Wue(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = Rfe(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = ufe(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return due(this, t);
  }
  assembleSignals() {
    return [...QL(this), ...cue(this, [])];
  }
  assembleSelectionData(t) {
    return hue(this, t);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return d_(this);
  }
  assembleMarks() {
    var n;
    let t = (n = this.component.mark) != null ? n : [];
    return (!this.parent || !Tl(this.parent)) && (t = ML(this, t)), t.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: t } = this.view || {};
    return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view";
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(t) {
    return ns(this.encoding, t);
  }
  fieldDef(t) {
    const n = this.encoding[t];
    return xr(n);
  }
  typedFieldDef(t) {
    const n = this.fieldDef(t);
    return sn(n) ? n : null;
  }
}
class A_ extends x_ {
  constructor(t, n, i, r, o) {
    super(t, "layer", n, i, o, t.resolve, t.view);
    const a = {
      ...r,
      ...t.width ? { width: t.width } : {},
      ...t.height ? { height: t.height } : {}
    };
    this.children = t.layer.map((s, u) => {
      if (Vm(s))
        return new A_(s, this, this.getName(`layer_${u}`), a, o);
      if (yo(s))
        return new I4(s, this, this.getName(`layer_${u}`), a, o);
      throw new Error(yE(s));
    });
  }
  parseData() {
    this.component.data = f0(this);
    for (const t of this.children)
      t.parseData();
  }
  parseLayoutSize() {
    Jce(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of B(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    cfe(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
  }
  assembleSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleSignals()), QL(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), d_(this));
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
  }
  assembleGroupStyle() {
    const t = /* @__PURE__ */ new Set();
    for (const i of this.children)
      for (const r of X(i.assembleGroupStyle()))
        t.add(r);
    const n = Array.from(t);
    return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
  }
  assembleTitle() {
    let t = super.assembleTitle();
    if (t)
      return t;
    for (const n of this.children)
      if (t = n.assembleTitle(), t)
        return t;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return pue(this, this.children.flatMap((t) => t.assembleMarks()));
  }
  assembleLegends() {
    return this.children.reduce((t, n) => t.concat(n.assembleLegends()), g4(this));
  }
}
function $_(e, t, n, i, r) {
  if (jm(e))
    return new qc(e, t, n, r);
  if (Vm(e))
    return new A_(e, t, n, i, r);
  if (yo(e))
    return new I4(e, t, n, i, r);
  if (Zae(e))
    return new rfe(e, t, n, r);
  throw new Error(yE(e));
}
function Ufe(e, t = {}) {
  t.logger && roe(t.logger), t.fieldTitle && U6(t.fieldTitle);
  try {
    const n = gL(ll(t.config, e.config)), i = SL(e, n), r = $_(i, null, "", void 0, n);
    return r.parse(), dce(r.component.data, r), {
      spec: Wfe(r, qfe(e, i.autosize, n, r), e.datasets, e.usermeta),
      normalized: i
    };
  } finally {
    t.logger && ooe(), t.fieldTitle && xae();
  }
}
function qfe(e, t, n, i) {
  const r = i.component.layoutSize.get("width"), o = i.component.layoutSize.get("height");
  if (t === void 0 ? (t = { type: "pad" }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : Y(t) && (t = { type: t }), r && o && aue(t.type)) {
    if (r === "step" && o === "step")
      U(Mk()), t.type = "pad";
    else if (r === "step" || o === "step") {
      const a = r === "step" ? "width" : "height";
      U(Mk(Tm(a)));
      const s = a === "width" ? "height" : "width";
      t.type = sue(s);
    }
  }
  return {
    ...B(t).length === 1 && t.type ? t.type === "pad" ? {} : { autosize: t.type } : { autosize: t },
    ...rC(n, !1),
    ...rC(e, !0)
  };
}
function Wfe(e, t, n = {}, i) {
  const r = e.config ? hse(e.config) : void 0, o = [].concat(
    e.assembleSelectionData([]),
    Yce(e.component.data, n)
  ), a = e.assembleProjections(), s = e.assembleTitle(), u = e.assembleGroupStyle(), l = e.assembleGroupEncodeEntry(!0);
  let c = e.assembleLayoutSignals();
  c = c.filter((h) => (h.name === "width" || h.name === "height") && h.value !== void 0 ? (t[h.name] = +h.value, !1) : !0);
  const { params: f, ...d } = t;
  return {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    ...e.description ? { description: e.description } : {},
    ...d,
    ...s ? { title: s } : {},
    ...u ? { style: u } : {},
    ...l ? { encode: { update: l } } : {},
    data: o,
    ...a.length > 0 ? { projections: a } : {},
    ...e.assembleGroup([
      ...c,
      ...e.assembleSelectionTopLevelSignals([]),
      ...fL(f)
    ]),
    ...r ? { config: r } : {},
    ...i ? { usermeta: i } : {}
  };
}
const Gfe = bie.version, Hfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  version: Gfe,
  compile: Ufe,
  normalize: SL,
  deepEqual: rr,
  duplicate: ae,
  never: xR,
  pick: Yu,
  omit: bn,
  stringify: Pe,
  hash: ge,
  isNullOrFalse: Mv,
  contains: me,
  some: ms,
  every: rE,
  mergeDeep: wR,
  unique: or,
  isEqual: _ie,
  setEqual: ER,
  hasIntersection: oE,
  prefixGenerator: Tv,
  fieldIntersection: aE,
  isEmpty: De,
  keys: B,
  vals: kt,
  entries: na,
  isBoolean: mf,
  varName: We,
  logicalExpr: jc,
  deleteNestedProperty: Wp,
  titleCase: td,
  accessPathWithDatum: sE,
  flatAccessWithDatum: _R,
  replacePathInField: ri,
  replaceAll: ys,
  removePathFromField: uE,
  accessPathDepth: Xu,
  getFirstDefined: tt,
  uniqueId: AR,
  resetIdCounter: Aie,
  internalField: $R,
  isInternalField: kR,
  normalizeAngle: yf,
  isNumeric: Am
}, Symbol.toStringTag, { value: "Module" }));
function P4(e) {
  const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
  return { library: t, version: n };
}
var Yfe = "vega-themes", Xfe = "2.10.0", Vfe = "Themes for stylized Vega and Vega-Lite visualizations.", Kfe = [
  "vega",
  "vega-lite",
  "themes",
  "style"
], Jfe = "BSD-3-Clause", Qfe = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
}, Zfe = [
  {
    name: "Emily Gu",
    url: "https://github.com/emilygu"
  },
  {
    name: "Arvind Satyanarayan",
    url: "http://arvindsatya.com"
  },
  {
    name: "Jeffrey Heer",
    url: "https://idl.cs.washington.edu"
  },
  {
    name: "Dominik Moritz",
    url: "https://www.domoritz.de"
  }
], ede = "build/vega-themes.js", tde = "build/vega-themes.module.js", nde = "build/vega-themes.min.js", ide = "build/vega-themes.min.js", rde = "build/vega-themes.module.d.ts", ode = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
}, ade = [
  "src",
  "build"
], sde = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  prepare: "beemo create-config",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix",
  lint: "yarn eslintbase",
  release: "auto shipit"
}, ude = {
  "@auto-it/conventional-commits": "^10.32.2",
  "@auto-it/first-time-contributor": "^10.32.2",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^13.0.6",
  "rollup-plugin-ts": "^1.4.7",
  auto: "^10.32.2",
  "browser-sync": "^2.27.7",
  concurrently: "^6.4.0",
  "gh-pages": "^3.2.3",
  rollup: "^2.60.0",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  typescript: "^4.4.4",
  vega: "^5.19.1",
  "vega-lite": "^5.0.0",
  "vega-lite-dev-config": "^0.20.0"
}, lde = {
  vega: "*",
  "vega-lite": "*"
}, cde = {
  name: Yfe,
  version: Xfe,
  description: Vfe,
  keywords: Kfe,
  license: Jfe,
  author: Qfe,
  contributors: Zfe,
  main: ede,
  module: tde,
  unpkg: nde,
  jsdelivr: ide,
  types: rde,
  repository: ode,
  files: ade,
  scripts: sde,
  devDependencies: ude,
  peerDependencies: lde
};
const iu = "#fff", fde = "#888", dde = {
  background: "#333",
  title: {
    color: iu,
    subtitleColor: iu
  },
  style: {
    "guide-label": {
      fill: iu
    },
    "guide-title": {
      fill: iu
    }
  },
  axis: {
    domainColor: iu,
    gridColor: fde,
    tickColor: iu
  }
}, ka = "#4572a7", hde = {
  background: "#fff",
  arc: { fill: ka },
  area: { fill: ka },
  line: { stroke: ka, strokeWidth: 2 },
  path: { stroke: ka },
  rect: { fill: ka },
  shape: { stroke: ka },
  symbol: { fill: ka, strokeWidth: 1.5, size: 50 },
  axis: {
    bandPosition: 0.5,
    grid: !0,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: !1,
    tickExtra: !0
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: [
      "#4572a7",
      "#aa4643",
      "#8aa453",
      "#71598e",
      "#4598ae",
      "#d98445",
      "#94aace",
      "#d09393",
      "#b9cc98",
      "#a99cbc"
    ]
  }
}, Ca = "#30a2da", D1 = "#cbcbcb", pde = "#999", gde = "#333", NC = "#f0f0f0", DC = "#333", mde = {
  arc: { fill: Ca },
  area: { fill: Ca },
  axis: {
    domainColor: D1,
    grid: !0,
    gridColor: D1,
    gridWidth: 1,
    labelColor: pde,
    labelFontSize: 10,
    titleColor: gde,
    tickColor: D1,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: !1
  },
  background: NC,
  group: {
    fill: NC
  },
  legend: {
    labelColor: DC,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: DC,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: Ca,
    strokeWidth: 2
  },
  path: { stroke: Ca, strokeWidth: 0.5 },
  rect: { fill: Ca },
  range: {
    category: [
      "#30a2da",
      "#fc4f30",
      "#e5ae38",
      "#6d904f",
      "#8b8b8b",
      "#b96db8",
      "#ff9e27",
      "#56cc60",
      "#52d2ca",
      "#52689e",
      "#545454",
      "#9fe4f8"
    ],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: !0,
    shape: "circle"
  },
  shape: { stroke: Ca },
  bar: {
    binSpacing: 2,
    fill: Ca,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
}, Fa = "#000", yde = {
  group: {
    fill: "#e5e5e5"
  },
  arc: { fill: Fa },
  area: { fill: Fa },
  line: { stroke: Fa },
  path: { stroke: Fa },
  rect: { fill: Fa },
  shape: { stroke: Fa },
  symbol: { fill: Fa, size: 40 },
  axis: {
    domain: !1,
    grid: !0,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: [
      "#000000",
      "#7F7F7F",
      "#1A1A1A",
      "#999999",
      "#333333",
      "#B0B0B0",
      "#4D4D4D",
      "#C9C9C9",
      "#666666",
      "#DCDCDC"
    ]
  }
}, vde = 22, bde = "normal", RC = "Benton Gothic, sans-serif", LC = 11.5, xde = "normal", Ma = "#82c6df", R1 = "Benton Gothic Bold, sans-serif", IC = "normal", PC = 13, nc = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
}, wde = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: R1,
    fontSize: vde,
    fontWeight: bde
  },
  arc: { fill: Ma },
  area: { fill: Ma },
  line: { stroke: Ma, strokeWidth: 2 },
  path: { stroke: Ma },
  rect: { fill: Ma },
  shape: { stroke: Ma },
  symbol: { fill: Ma, size: 30 },
  axis: {
    labelFont: RC,
    labelFontSize: LC,
    labelFontWeight: xde,
    titleFont: R1,
    titleFontSize: PC,
    titleFontWeight: IC
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: RC,
    labelFontSize: LC,
    symbolType: "square",
    titleFont: R1,
    titleFontSize: PC,
    titleFontWeight: IC
  },
  range: {
    category: nc["category-6"],
    diverging: nc["fireandice-6"],
    heatmap: nc["fire-7"],
    ordinal: nc["fire-7"],
    ramp: nc["fire-7"]
  }
}, Ta = "#ab5787", Xd = "#979797", Ede = {
  background: "#f9f9f9",
  arc: { fill: Ta },
  area: { fill: Ta },
  line: { stroke: Ta },
  path: { stroke: Ta },
  rect: { fill: Ta },
  shape: { stroke: Ta },
  symbol: { fill: Ta, size: 30 },
  axis: {
    domainColor: Xd,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: Xd,
    tickColor: Xd,
    tickWidth: 0.2,
    titleColor: Xd
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    grid: !0,
    tickSize: 10
  },
  axisY: {
    domain: !1,
    grid: !0,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: [
      "#ab5787",
      "#51b2e5",
      "#703c5c",
      "#168dd9",
      "#d190b6",
      "#00609f",
      "#d365ba",
      "#154866",
      "#666666",
      "#c4c4c4"
    ]
  }
}, Oa = "#3e5c69", _de = {
  background: "#fff",
  arc: { fill: Oa },
  area: { fill: Oa },
  line: { stroke: Oa },
  path: { stroke: Oa },
  rect: { fill: Oa },
  shape: { stroke: Oa },
  symbol: { fill: Oa },
  axis: {
    domainWidth: 0.5,
    grid: !0,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
}, Yn = "#1696d2", zC = "#000000", Sde = "#FFFFFF", Vd = "Lato", L1 = "Lato", Ade = "Lato", $de = "#DEDDDD", kde = 18, ic = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
}, Cde = {
  background: Sde,
  title: {
    anchor: "start",
    fontSize: kde,
    font: Vd
  },
  axisX: {
    domain: !0,
    domainColor: zC,
    domainWidth: 1,
    grid: !1,
    labelFontSize: 12,
    labelFont: L1,
    labelAngle: 0,
    tickColor: zC,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: Vd
  },
  axisY: {
    domain: !1,
    domainWidth: 1,
    grid: !0,
    gridColor: $de,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont: L1,
    labelPadding: 8,
    ticks: !1,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: Vd,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont: L1,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: Vd,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: ic["six-groups-cat-1"],
    diverging: ic["diverging-colors"],
    heatmap: ic["diverging-colors"],
    ordinal: ic["six-groups-seq"],
    ramp: ic["shades-blue"]
  },
  area: {
    fill: Yn
  },
  rect: {
    fill: Yn
  },
  line: {
    color: Yn,
    stroke: Yn,
    strokeWidth: 5
  },
  trail: {
    color: Yn,
    stroke: Yn,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: Yn,
    strokeWidth: 0.5
  },
  point: {
    filled: !0
  },
  text: {
    font: Ade,
    color: Yn,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: Yn,
      stroke: null
    }
  },
  arc: { fill: Yn },
  shape: { stroke: Yn },
  symbol: { fill: Yn, size: 30 }
}, Na = "#3366CC", BC = "#ccc", Kd = "Arial, sans-serif", Fde = {
  arc: { fill: Na },
  area: { fill: Na },
  path: { stroke: Na },
  rect: { fill: Na },
  shape: { stroke: Na },
  symbol: { stroke: Na },
  circle: { fill: Na },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: Kd,
      fontSize: 12
    },
    "guide-title": {
      font: Kd,
      fontSize: 12
    },
    "group-title": {
      font: Kd,
      fontSize: 12
    }
  },
  title: {
    font: Kd,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor: BC,
    tickColor: BC,
    domain: !1,
    grid: !0
  },
  range: {
    category: [
      "#4285F4",
      "#DB4437",
      "#F4B400",
      "#0F9D58",
      "#AB47BC",
      "#00ACC1",
      "#FF7043",
      "#9E9D24",
      "#5C6BC0",
      "#F06292",
      "#00796B",
      "#C2185B"
    ],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
}, k_ = (e) => e * (1 / 3 + 1), jC = k_(9), UC = k_(10), qC = k_(12), rc = "Segoe UI", WC = "wf_standard-font, helvetica, arial, sans-serif", GC = "#252423", oc = "#605E5C", HC = "transparent", Mde = "#C8C6C4", fi = "#118DFF", Tde = "#12239E", Ode = "#E66C37", Nde = "#6B007B", Dde = "#E044A7", Rde = "#744EC2", Lde = "#D9B300", Ide = "#D64550", z4 = fi, B4 = "#DEEFFF", YC = [B4, z4], Pde = [
  B4,
  "#c7e4ff",
  "#b0d9ff",
  "#9aceff",
  "#83c3ff",
  "#6cb9ff",
  "#55aeff",
  "#3fa3ff",
  "#2898ff",
  z4
], zde = {
  view: { stroke: HC },
  background: HC,
  font: rc,
  header: {
    titleFont: WC,
    titleFontSize: qC,
    titleColor: GC,
    labelFont: rc,
    labelFontSize: UC,
    labelColor: oc
  },
  axis: {
    ticks: !1,
    grid: !1,
    domain: !1,
    labelColor: oc,
    labelFontSize: jC,
    titleFont: WC,
    titleColor: GC,
    titleFontSize: qC,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: !0,
    gridColor: Mde,
    gridDash: [1, 5],
    labelFlush: !1
  },
  axisBand: { tickExtra: !0 },
  axisX: { labelPadding: 5 },
  axisY: { labelPadding: 10 },
  bar: { fill: fi },
  line: {
    stroke: fi,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: { font: rc, fontSize: jC, fill: oc },
  arc: { fill: fi },
  area: { fill: fi, line: !0, opacity: 0.6 },
  path: { stroke: fi },
  rect: { fill: fi },
  point: { fill: fi, filled: !0, size: 75 },
  shape: { stroke: fi },
  symbol: { fill: fi, strokeWidth: 1.5, size: 50 },
  legend: {
    titleFont: rc,
    titleFontWeight: "bold",
    titleColor: oc,
    labelFont: rc,
    labelFontSize: UC,
    labelColor: oc,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [
      fi,
      Tde,
      Ode,
      Nde,
      Dde,
      Rde,
      Lde,
      Ide
    ],
    diverging: YC,
    heatmap: YC,
    ordinal: Pde
  }
}, Bde = cde.version, jde = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dark: dde,
  excel: hde,
  fivethirtyeight: mde,
  ggplot2: yde,
  googlecharts: Fde,
  latimes: wde,
  powerbi: zde,
  quartz: Ede,
  urbaninstitute: Cde,
  version: Bde,
  vox: _de
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Ude(e, t) {
  var n = {};
  for (var i in e)
    Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(e); r < i.length; r++)
      t.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[r]) && (n[i[r]] = e[i[r]]);
  return n;
}
function qde(e, t, n) {
  if (P(e))
    return `[${e.map((i) => t(Y(i) ? i : XC(i, n))).join(", ")}]`;
  if (K(e)) {
    let i = "";
    const r = e, { title: o, image: a } = r, s = Ude(r, ["title", "image"]);
    o && (i += `<h2>${t(o)}</h2>`), a && (i += `<img src="${t(a)}">`);
    const u = Object.keys(s);
    if (u.length > 0) {
      i += "<table>";
      for (const l of u) {
        let c = s[l];
        c !== void 0 && (K(c) && (c = XC(c, n)), i += `<tr><td class="key">${t(l)}:</td><td class="value">${t(c)}</td></tr>`);
      }
      i += "</table>";
    }
    return i || "{}";
  }
  return t(e);
}
function Wde(e) {
  const t = [];
  return function(n, i) {
    if (typeof i != "object" || i === null)
      return i;
    const r = t.indexOf(this) + 1;
    return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i);
  };
}
function XC(e, t) {
  return JSON.stringify(e, Wde(t));
}
var Gde = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element img {
  max-width: 200px;
  max-height: 200px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
const j4 = "vg-tooltip-element", Hde = {
  offsetX: 10,
  offsetY: 10,
  id: j4,
  styleId: "vega-tooltip-style",
  theme: "light",
  disableDefaultStyle: !1,
  sanitize: Yde,
  maxDepth: 2,
  formatTooltip: qde
};
function Yde(e) {
  return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function Xde(e) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(e))
    throw new Error("Invalid HTML ID");
  return Gde.toString().replace(j4, e);
}
function Vde(e, t, n, i) {
  let r = e.clientX + n;
  r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
  let o = e.clientY + i;
  return o + t.height > window.innerHeight && (o = +e.clientY - i - t.height), { x: r, y: o };
}
class Kde {
  constructor(t) {
    this.options = Object.assign(Object.assign({}, Hde), t);
    const n = this.options.id;
    if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const i = document.createElement("style");
      i.setAttribute("id", this.options.styleId), i.innerHTML = Xde(n);
      const r = document.head;
      r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i);
    }
  }
  tooltipHandler(t, n, i, r) {
    var o;
    if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), ((o = document.fullscreenElement) !== null && o !== void 0 ? o : document.body).appendChild(this.el)), r == null || r === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth), this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x: a, y: s } = Vde(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.setAttribute("style", `top: ${s}px; left: ${a}px`);
  }
}
function Jde(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function VC(e, t, n, i, r, o, a) {
  try {
    var s = e[o](a), u = s.value;
  } catch (l) {
    n(l);
    return;
  }
  s.done ? t(u) : Promise.resolve(u).then(i, r);
}
function ag(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(i, r) {
      var o = e.apply(t, n);
      function a(u) {
        VC(o, i, r, a, s, "next", u);
      }
      function s(u) {
        VC(o, i, r, a, s, "throw", u);
      }
      a(void 0);
    });
  };
}
var U4 = Object.prototype, Ya = U4.hasOwnProperty, ir, C_ = typeof Symbol == "function" ? Symbol : {}, d0 = C_.iterator || "@@iterator", Qde = C_.asyncIterator || "@@asyncIterator", sg = C_.toStringTag || "@@toStringTag";
function q4(e, t, n, i) {
  var r = t && t.prototype instanceof eb ? t : eb, o = Object.create(r.prototype), a = new tb(i || []);
  return o._invoke = ihe(e, n, a), o;
}
function F_(e, t, n) {
  try {
    return {
      type: "normal",
      arg: e.call(t, n)
    };
  } catch (i) {
    return {
      type: "throw",
      arg: i
    };
  }
}
var KC = "suspendedStart", Zde = "suspendedYield", JC = "executing", Jd = "completed", wi = {};
function eb() {
}
function h0() {
}
function sl() {
}
var M_ = {};
M_[d0] = function() {
  return this;
};
var I1 = Object.getPrototypeOf, Qd = I1 && I1(I1(T_([])));
Qd && Qd !== U4 && Ya.call(Qd, d0) && (M_ = Qd);
var Ol = sl.prototype = eb.prototype = Object.create(M_);
h0.prototype = Ol.constructor = sl;
sl.constructor = h0;
sl[sg] = h0.displayName = "GeneratorFunction";
function W4(e) {
  ["next", "throw", "return"].forEach(function(t) {
    e[t] = function(n) {
      return this._invoke(t, n);
    };
  });
}
function G4(e) {
  var t = typeof e == "function" && e.constructor;
  return t ? t === h0 || (t.displayName || t.name) === "GeneratorFunction" : !1;
}
function ehe(e) {
  return Object.setPrototypeOf ? Object.setPrototypeOf(e, sl) : (e.__proto__ = sl, sg in e || (e[sg] = "GeneratorFunction")), e.prototype = Object.create(Ol), e;
}
function the(e) {
  return {
    __await: e
  };
}
function p0(e, t) {
  function n(o, a, s, u) {
    var l = F_(e[o], e, a);
    if (l.type === "throw")
      u(l.arg);
    else {
      var c = l.arg, f = c.value;
      return f && typeof f == "object" && Ya.call(f, "__await") ? t.resolve(f.__await).then(function(d) {
        n("next", d, s, u);
      }, function(d) {
        n("throw", d, s, u);
      }) : t.resolve(f).then(function(d) {
        c.value = d, s(c);
      }, function(d) {
        return n("throw", d, s, u);
      });
    }
  }
  var i;
  function r(o, a) {
    function s() {
      return new t(function(u, l) {
        n(o, a, u, l);
      });
    }
    return i = i ? i.then(
      s,
      s
    ) : s();
  }
  this._invoke = r;
}
W4(p0.prototype);
p0.prototype[Qde] = function() {
  return this;
};
function nhe(e, t, n, i, r) {
  r === void 0 && (r = Promise);
  var o = new p0(q4(e, t, n, i), r);
  return G4(t) ? o : o.next().then(function(a) {
    return a.done ? a.value : o.next();
  });
}
function ihe(e, t, n) {
  var i = KC;
  return function(o, a) {
    if (i === JC)
      throw new Error("Generator is already running");
    if (i === Jd) {
      if (o === "throw")
        throw a;
      return Y4();
    }
    for (n.method = o, n.arg = a; ; ) {
      var s = n.delegate;
      if (s) {
        var u = H4(s, n);
        if (u) {
          if (u === wi)
            continue;
          return u;
        }
      }
      if (n.method === "next")
        n.sent = n._sent = n.arg;
      else if (n.method === "throw") {
        if (i === KC)
          throw i = Jd, n.arg;
        n.dispatchException(n.arg);
      } else
        n.method === "return" && n.abrupt("return", n.arg);
      i = JC;
      var l = F_(e, t, n);
      if (l.type === "normal") {
        if (i = n.done ? Jd : Zde, l.arg === wi)
          continue;
        return {
          value: l.arg,
          done: n.done
        };
      } else
        l.type === "throw" && (i = Jd, n.method = "throw", n.arg = l.arg);
    }
  };
}
function H4(e, t) {
  var n = e.iterator[t.method];
  if (n === ir) {
    if (t.delegate = null, t.method === "throw") {
      if (e.iterator.return && (t.method = "return", t.arg = ir, H4(e, t), t.method === "throw"))
        return wi;
      t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method");
    }
    return wi;
  }
  var i = F_(n, e.iterator, t.arg);
  if (i.type === "throw")
    return t.method = "throw", t.arg = i.arg, t.delegate = null, wi;
  var r = i.arg;
  if (!r)
    return t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, wi;
  if (r.done)
    t[e.resultName] = r.value, t.next = e.nextLoc, t.method !== "return" && (t.method = "next", t.arg = ir);
  else
    return r;
  return t.delegate = null, wi;
}
W4(Ol);
Ol[sg] = "Generator";
Ol[d0] = function() {
  return this;
};
Ol.toString = function() {
  return "[object Generator]";
};
function rhe(e) {
  var t = {
    tryLoc: e[0]
  };
  1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
}
function P1(e) {
  var t = e.completion || {};
  t.type = "normal", delete t.arg, e.completion = t;
}
function tb(e) {
  this.tryEntries = [{
    tryLoc: "root"
  }], e.forEach(rhe, this), this.reset(!0);
}
function ohe(e) {
  var t = [];
  for (var n in e)
    t.push(n);
  return t.reverse(), function i() {
    for (; t.length; ) {
      var r = t.pop();
      if (r in e)
        return i.value = r, i.done = !1, i;
    }
    return i.done = !0, i;
  };
}
function T_(e) {
  if (e) {
    var t = e[d0];
    if (t)
      return t.call(e);
    if (typeof e.next == "function")
      return e;
    if (!isNaN(e.length)) {
      var n = -1, i = function r() {
        for (; ++n < e.length; )
          if (Ya.call(e, n))
            return r.value = e[n], r.done = !1, r;
        return r.value = ir, r.done = !0, r;
      };
      return i.next = i;
    }
  }
  return {
    next: Y4
  };
}
function Y4() {
  return {
    value: ir,
    done: !0
  };
}
tb.prototype = {
  constructor: tb,
  reset: function(t) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = ir, this.done = !1, this.delegate = null, this.method = "next", this.arg = ir, this.tryEntries.forEach(P1), !t)
      for (var n in this)
        n.charAt(0) === "t" && Ya.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = ir);
  },
  stop: function() {
    this.done = !0;
    var t = this.tryEntries[0], n = t.completion;
    if (n.type === "throw")
      throw n.arg;
    return this.rval;
  },
  dispatchException: function(t) {
    if (this.done)
      throw t;
    var n = this;
    function i(l, c) {
      return a.type = "throw", a.arg = t, n.next = l, c && (n.method = "next", n.arg = ir), !!c;
    }
    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
      var o = this.tryEntries[r], a = o.completion;
      if (o.tryLoc === "root")
        return i("end");
      if (o.tryLoc <= this.prev) {
        var s = Ya.call(o, "catchLoc"), u = Ya.call(o, "finallyLoc");
        if (s && u) {
          if (this.prev < o.catchLoc)
            return i(o.catchLoc, !0);
          if (this.prev < o.finallyLoc)
            return i(o.finallyLoc);
        } else if (s) {
          if (this.prev < o.catchLoc)
            return i(o.catchLoc, !0);
        } else if (u) {
          if (this.prev < o.finallyLoc)
            return i(o.finallyLoc);
        } else
          throw new Error("try statement without catch or finally");
      }
    }
  },
  abrupt: function(t, n) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var r = this.tryEntries[i];
      if (r.tryLoc <= this.prev && Ya.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
        var o = r;
        break;
      }
    }
    o && (t === "break" || t === "continue") && o.tryLoc <= n && n <= o.finallyLoc && (o = null);
    var a = o ? o.completion : {};
    return a.type = t, a.arg = n, o ? (this.method = "next", this.next = o.finallyLoc, wi) : this.complete(a);
  },
  complete: function(t, n) {
    if (t.type === "throw")
      throw t.arg;
    return t.type === "break" || t.type === "continue" ? this.next = t.arg : t.type === "return" ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : t.type === "normal" && n && (this.next = n), wi;
  },
  finish: function(t) {
    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
      var i = this.tryEntries[n];
      if (i.finallyLoc === t)
        return this.complete(i.completion, i.afterLoc), P1(i), wi;
    }
  },
  catch: function(t) {
    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
      var i = this.tryEntries[n];
      if (i.tryLoc === t) {
        var r = i.completion;
        if (r.type === "throw") {
          var o = r.arg;
          P1(i);
        }
        return o;
      }
    }
    throw new Error("illegal catch attempt");
  },
  delegateYield: function(t, n, i) {
    return this.delegate = {
      iterator: T_(t),
      resultName: n,
      nextLoc: i
    }, this.method === "next" && (this.arg = ir), wi;
  }
};
var ar = {
  wrap: q4,
  isGeneratorFunction: G4,
  AsyncIterator: p0,
  mark: ehe,
  awrap: the,
  async: nhe,
  keys: ohe,
  values: T_
}, ahe = ke;
ke.Node = $s;
ke.create = ke;
function ke(e) {
  var t = this;
  if (t instanceof ke || (t = new ke()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(r) {
      t.push(r);
    });
  else if (arguments.length > 0)
    for (var n = 0, i = arguments.length; n < i; n++)
      t.push(arguments[n]);
  return t;
}
ke.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, n = e.prev;
  return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
ke.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
ke.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
ke.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    uhe(this, arguments[e]);
  return this.length;
};
ke.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    lhe(this, arguments[e]);
  return this.length;
};
ke.prototype.pop = function() {
  if (!!this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
ke.prototype.shift = function() {
  if (!!this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
ke.prototype.forEach = function(e, t) {
  t = t || this;
  for (var n = this.head, i = 0; n !== null; i++)
    e.call(t, n.value, i, this), n = n.next;
};
ke.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var n = this.tail, i = this.length - 1; n !== null; i--)
    e.call(t, n.value, i, this), n = n.prev;
};
ke.prototype.get = function(e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++)
    n = n.next;
  if (t === e && n !== null)
    return n.value;
};
ke.prototype.getReverse = function(e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++)
    n = n.prev;
  if (t === e && n !== null)
    return n.value;
};
ke.prototype.map = function(e, t) {
  t = t || this;
  for (var n = new ke(), i = this.head; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.next;
  return n;
};
ke.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var n = new ke(), i = this.tail; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.prev;
  return n;
};
ke.prototype.reduce = function(e, t) {
  var n, i = this.head;
  if (arguments.length > 1)
    n = t;
  else if (this.head)
    i = this.head.next, n = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var r = 0; i !== null; r++)
    n = e(n, i.value, r), i = i.next;
  return n;
};
ke.prototype.reduceReverse = function(e, t) {
  var n, i = this.tail;
  if (arguments.length > 1)
    n = t;
  else if (this.tail)
    i = this.tail.prev, n = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var r = this.length - 1; i !== null; r--)
    n = e(n, i.value, r), i = i.prev;
  return n;
};
ke.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    e[t] = n.value, n = n.next;
  return e;
};
ke.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    e[t] = n.value, n = n.prev;
  return e;
};
ke.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new ke();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = 0, r = this.head; r !== null && i < e; i++)
    r = r.next;
  for (; r !== null && i < t; i++, r = r.next)
    n.push(r.value);
  return n;
};
ke.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new ke();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = this.length, r = this.tail; r !== null && i > t; i--)
    r = r.prev;
  for (; r !== null && i > e; i--, r = r.prev)
    n.push(r.value);
  return n;
};
ke.prototype.splice = function(e, t) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var n = 0, i = this.head; i !== null && n < e; n++)
    i = i.next;
  for (var r = [], n = 0; i && n < t; n++)
    r.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var n = 0; n < (arguments.length <= 2 ? 0 : arguments.length - 2); n++)
    i = she(this, i, n + 2 < 2 || arguments.length <= n + 2 ? void 0 : arguments[n + 2]);
  return r;
};
ke.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var i = n.prev;
    n.prev = n.next, n.next = i;
  }
  return this.head = t, this.tail = e, this;
};
function she(e, t, n) {
  var i = t === e.head ? new $s(n, null, t, e) : new $s(n, t, t.next, e);
  return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
}
function uhe(e, t) {
  e.tail = new $s(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function lhe(e, t) {
  e.head = new $s(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function $s(e, t, n, i) {
  if (!(this instanceof $s))
    return new $s(e, t, n, i);
  this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
}
try {
  ke.prototype[Symbol.iterator] = /* @__PURE__ */ ar.mark(function e() {
    var t;
    return ar.wrap(function(i) {
      for (; ; )
        switch (i.prev = i.next) {
          case 0:
            t = this.head;
          case 1:
            if (!t) {
              i.next = 7;
              break;
            }
            return i.next = 4, t.value;
          case 4:
            t = t.next, i.next = 1;
            break;
          case 7:
          case "end":
            return i.stop();
        }
    }, e, this);
  });
} catch {
}
var che = ahe, Ua = Symbol("max"), Ur = Symbol("length"), ru = Symbol("lengthCalculator"), Wc = Symbol("allowStale"), Xa = Symbol("maxAge"), zr = Symbol("dispose"), QC = Symbol("noDisposeOnSet"), ft = Symbol("lruList"), di = Symbol("cache"), X4 = Symbol("updateAgeOnGet"), z1 = () => 1;
class fhe {
  constructor(t) {
    if (typeof t == "number" && (t = {
      max: t
    }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[Ua] = t.max || 1 / 0;
    var n = t.length || z1;
    if (this[ru] = typeof n != "function" ? z1 : n, this[Wc] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Xa] = t.maxAge || 0, this[zr] = t.dispose, this[QC] = t.noDisposeOnSet || !1, this[X4] = t.updateAgeOnGet || !1, this.reset();
  }
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[Ua] = t || 1 / 0, ac(this);
  }
  get max() {
    return this[Ua];
  }
  set allowStale(t) {
    this[Wc] = !!t;
  }
  get allowStale() {
    return this[Wc];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Xa] = t, ac(this);
  }
  get maxAge() {
    return this[Xa];
  }
  set lengthCalculator(t) {
    typeof t != "function" && (t = z1), t !== this[ru] && (this[ru] = t, this[Ur] = 0, this[ft].forEach((n) => {
      n.length = this[ru](n.value, n.key), this[Ur] += n.length;
    })), ac(this);
  }
  get lengthCalculator() {
    return this[ru];
  }
  get length() {
    return this[Ur];
  }
  get itemCount() {
    return this[ft].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (var i = this[ft].tail; i !== null; ) {
      var r = i.prev;
      ZC(this, t, i, n), i = r;
    }
  }
  forEach(t, n) {
    n = n || this;
    for (var i = this[ft].head; i !== null; ) {
      var r = i.next;
      ZC(this, t, i, n), i = r;
    }
  }
  keys() {
    return this[ft].toArray().map((t) => t.key);
  }
  values() {
    return this[ft].toArray().map((t) => t.value);
  }
  reset() {
    this[zr] && this[ft] && this[ft].length && this[ft].forEach((t) => this[zr](t.key, t.value)), this[di] = /* @__PURE__ */ new Map(), this[ft] = new che(), this[Ur] = 0;
  }
  dump() {
    return this[ft].map((t) => ug(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[ft];
  }
  set(t, n, i) {
    if (i = i || this[Xa], i && typeof i != "number")
      throw new TypeError("maxAge must be a number");
    var r = i ? Date.now() : 0, o = this[ru](n, t);
    if (this[di].has(t)) {
      if (o > this[Ua])
        return Au(this, this[di].get(t)), !1;
      var a = this[di].get(t), s = a.value;
      return this[zr] && (this[QC] || this[zr](t, s.value)), s.now = r, s.maxAge = i, s.value = n, this[Ur] += o - s.length, s.length = o, this.get(t), ac(this), !0;
    }
    var u = new dhe(t, n, o, r, i);
    return u.length > this[Ua] ? (this[zr] && this[zr](t, n), !1) : (this[Ur] += u.length, this[ft].unshift(u), this[di].set(t, this[ft].head), ac(this), !0);
  }
  has(t) {
    if (!this[di].has(t))
      return !1;
    var n = this[di].get(t).value;
    return !ug(this, n);
  }
  get(t) {
    return B1(this, t, !0);
  }
  peek(t) {
    return B1(this, t, !1);
  }
  pop() {
    var t = this[ft].tail;
    return t ? (Au(this, t), t.value) : null;
  }
  del(t) {
    Au(this, this[di].get(t));
  }
  load(t) {
    this.reset();
    for (var n = Date.now(), i = t.length - 1; i >= 0; i--) {
      var r = t[i], o = r.e || 0;
      if (o === 0)
        this.set(r.k, r.v);
      else {
        var a = o - n;
        a > 0 && this.set(r.k, r.v, a);
      }
    }
  }
  prune() {
    this[di].forEach((t, n) => B1(this, n, !1));
  }
}
var B1 = (e, t, n) => {
  var i = e[di].get(t);
  if (i) {
    var r = i.value;
    if (ug(e, r)) {
      if (Au(e, i), !e[Wc])
        return;
    } else
      n && (e[X4] && (i.value.now = Date.now()), e[ft].unshiftNode(i));
    return r.value;
  }
}, ug = (e, t) => {
  if (!t || !t.maxAge && !e[Xa])
    return !1;
  var n = Date.now() - t.now;
  return t.maxAge ? n > t.maxAge : e[Xa] && n > e[Xa];
}, ac = (e) => {
  if (e[Ur] > e[Ua])
    for (var t = e[ft].tail; e[Ur] > e[Ua] && t !== null; ) {
      var n = t.prev;
      Au(e, t), t = n;
    }
}, Au = (e, t) => {
  if (t) {
    var n = t.value;
    e[zr] && e[zr](n.key, n.value), e[Ur] -= n.length, e[di].delete(n.key), e[ft].removeNode(t);
  }
};
class dhe {
  constructor(t, n, i, r, o) {
    this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = o || 0;
  }
}
var ZC = (e, t, n, i) => {
  var r = n.value;
  ug(e, r) && (Au(e, n), e[Wc] || (r = void 0)), r && t.call(i, r.value, r.key, e);
}, hhe = fhe, phe = ["includePrerelease", "loose", "rtl"], ghe = (e) => e ? typeof e != "object" ? {
  loose: !0
} : phe.filter((t) => e[t]).reduce((t, n) => (t[n] = !0, t), {}) : {}, O_ = ghe, Ei = { exports: {} }, mhe = "2.0.0", yhe = 256, vhe = Number.MAX_SAFE_INTEGER || 9007199254740991, bhe = 16, N_ = {
  SEMVER_SPEC_VERSION: mhe,
  MAX_LENGTH: yhe,
  MAX_SAFE_INTEGER: vhe,
  MAX_SAFE_COMPONENT_LENGTH: bhe
}, xhe = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return console.error("SEMVER", ...t);
} : () => {
}, g0 = xhe;
(function(e, t) {
  var n = N_.MAX_SAFE_COMPONENT_LENGTH, i = g0;
  t = e.exports = {};
  var r = t.re = [], o = t.src = [], a = t.t = {}, s = 0, u = (l, c, f) => {
    var d = s++;
    i(l, d, c), a[l] = d, o[d] = c, r[d] = new RegExp(c, f ? "g" : void 0);
  };
  u("NUMERICIDENTIFIER", "0|[1-9]\\d*"), u("NUMERICIDENTIFIERLOOSE", "[0-9]+"), u("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), u("MAINVERSION", "(".concat(o[a.NUMERICIDENTIFIER], ")\\.") + "(".concat(o[a.NUMERICIDENTIFIER], ")\\.") + "(".concat(o[a.NUMERICIDENTIFIER], ")")), u("MAINVERSIONLOOSE", "(".concat(o[a.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o[a.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o[a.NUMERICIDENTIFIERLOOSE], ")")), u("PRERELEASEIDENTIFIER", "(?:".concat(o[a.NUMERICIDENTIFIER], "|").concat(o[a.NONNUMERICIDENTIFIER], ")")), u("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(o[a.NUMERICIDENTIFIERLOOSE], "|").concat(o[a.NONNUMERICIDENTIFIER], ")")), u("PRERELEASE", "(?:-(".concat(o[a.PRERELEASEIDENTIFIER], "(?:\\.").concat(o[a.PRERELEASEIDENTIFIER], ")*))")), u("PRERELEASELOOSE", "(?:-?(".concat(o[a.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(o[a.PRERELEASEIDENTIFIERLOOSE], ")*))")), u("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), u("BUILD", "(?:\\+(".concat(o[a.BUILDIDENTIFIER], "(?:\\.").concat(o[a.BUILDIDENTIFIER], ")*))")), u("FULLPLAIN", "v?".concat(o[a.MAINVERSION]).concat(o[a.PRERELEASE], "?").concat(o[a.BUILD], "?")), u("FULL", "^".concat(o[a.FULLPLAIN], "$")), u("LOOSEPLAIN", "[v=\\s]*".concat(o[a.MAINVERSIONLOOSE]).concat(o[a.PRERELEASELOOSE], "?").concat(o[a.BUILD], "?")), u("LOOSE", "^".concat(o[a.LOOSEPLAIN], "$")), u("GTLT", "((?:<|>)?=?)"), u("XRANGEIDENTIFIERLOOSE", "".concat(o[a.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), u("XRANGEIDENTIFIER", "".concat(o[a.NUMERICIDENTIFIER], "|x|X|\\*")), u("XRANGEPLAIN", "[v=\\s]*(".concat(o[a.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o[a.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o[a.XRANGEIDENTIFIER], ")") + "(?:".concat(o[a.PRERELEASE], ")?").concat(o[a.BUILD], "?") + ")?)?"), u("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(o[a.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o[a.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o[a.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(o[a.PRERELEASELOOSE], ")?").concat(o[a.BUILD], "?") + ")?)?"), u("XRANGE", "^".concat(o[a.GTLT], "\\s*").concat(o[a.XRANGEPLAIN], "$")), u("XRANGELOOSE", "^".concat(o[a.GTLT], "\\s*").concat(o[a.XRANGEPLAINLOOSE], "$")), u("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n, "})") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:$|[^\\d])"), u("COERCERTL", o[a.COERCE], !0), u("LONETILDE", "(?:~>?)"), u("TILDETRIM", "(\\s*)".concat(o[a.LONETILDE], "\\s+"), !0), t.tildeTrimReplace = "$1~", u("TILDE", "^".concat(o[a.LONETILDE]).concat(o[a.XRANGEPLAIN], "$")), u("TILDELOOSE", "^".concat(o[a.LONETILDE]).concat(o[a.XRANGEPLAINLOOSE], "$")), u("LONECARET", "(?:\\^)"), u("CARETTRIM", "(\\s*)".concat(o[a.LONECARET], "\\s+"), !0), t.caretTrimReplace = "$1^", u("CARET", "^".concat(o[a.LONECARET]).concat(o[a.XRANGEPLAIN], "$")), u("CARETLOOSE", "^".concat(o[a.LONECARET]).concat(o[a.XRANGEPLAINLOOSE], "$")), u("COMPARATORLOOSE", "^".concat(o[a.GTLT], "\\s*(").concat(o[a.LOOSEPLAIN], ")$|^$")), u("COMPARATOR", "^".concat(o[a.GTLT], "\\s*(").concat(o[a.FULLPLAIN], ")$|^$")), u("COMPARATORTRIM", "(\\s*)".concat(o[a.GTLT], "\\s*(").concat(o[a.LOOSEPLAIN], "|").concat(o[a.XRANGEPLAIN], ")"), !0), t.comparatorTrimReplace = "$1$2$3", u("HYPHENRANGE", "^\\s*(".concat(o[a.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(o[a.XRANGEPLAIN], ")") + "\\s*$"), u("HYPHENRANGELOOSE", "^\\s*(".concat(o[a.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(o[a.XRANGEPLAINLOOSE], ")") + "\\s*$"), u("STAR", "(<|>)?=?\\s*\\*"), u("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), u("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Ei, Ei.exports);
var eF = /^[0-9]+$/, V4 = (e, t) => {
  var n = eF.test(e), i = eF.test(t);
  return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1;
}, whe = (e, t) => V4(t, e), Ehe = {
  compareIdentifiers: V4,
  rcompareIdentifiers: whe
}, Zd = g0, tF = N_.MAX_LENGTH, eh = N_.MAX_SAFE_INTEGER, nF = Ei.exports.re, iF = Ei.exports.t, _he = O_, ou = Ehe.compareIdentifiers;
class hi {
  constructor(t, n) {
    if (n = _he(n), t instanceof hi) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError("Invalid Version: ".concat(t));
    if (t.length > tF)
      throw new TypeError("version is longer than ".concat(tF, " characters"));
    Zd("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    var i = t.trim().match(n.loose ? nF[iF.LOOSE] : nF[iF.FULL]);
    if (!i)
      throw new TypeError("Invalid Version: ".concat(t));
    if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > eh || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > eh || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > eh || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((r) => {
      if (/^[0-9]+$/.test(r)) {
        var o = +r;
        if (o >= 0 && o < eh)
          return o;
      }
      return r;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (Zd("SemVer.compare", this.version, this.options, t), !(t instanceof hi)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new hi(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof hi || (t = new hi(t, this.options)), ou(this.major, t.major) || ou(this.minor, t.minor) || ou(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof hi || (t = new hi(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    var n = 0;
    do {
      var i = this.prerelease[n], r = t.prerelease[n];
      if (Zd("prerelease compare", n, i, r), i === void 0 && r === void 0)
        return 0;
      if (r === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === r)
        continue;
      return ou(i, r);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof hi || (t = new hi(t, this.options));
    var n = 0;
    do {
      var i = this.build[n], r = t.build[n];
      if (Zd("prerelease compare", n, i, r), i === void 0 && r === void 0)
        return 0;
      if (r === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === r)
        continue;
      return ou(i, r);
    } while (++n);
  }
  inc(t, n) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n), this.inc("pre", n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n), this.inc("pre", n);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var i = this.prerelease.length; --i >= 0; )
            typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
          i === -1 && this.prerelease.push(0);
        }
        n && (ou(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [n, 0]) : this.prerelease = [n, 0]);
        break;
      default:
        throw new Error("invalid increment argument: ".concat(t));
    }
    return this.format(), this.raw = this.version, this;
  }
}
var D_ = hi, rF = D_, She = (e, t, n) => new rF(e, n).compare(new rF(t, n)), Nl = She, Ahe = Nl, $he = (e, t, n) => Ahe(e, t, n) === 0, khe = $he, Che = Nl, Fhe = (e, t, n) => Che(e, t, n) !== 0, Mhe = Fhe, The = Nl, Ohe = (e, t, n) => The(e, t, n) > 0, Nhe = Ohe, Dhe = Nl, Rhe = (e, t, n) => Dhe(e, t, n) >= 0, Lhe = Rhe, Ihe = Nl, Phe = (e, t, n) => Ihe(e, t, n) < 0, zhe = Phe, Bhe = Nl, jhe = (e, t, n) => Bhe(e, t, n) <= 0, Uhe = jhe, qhe = khe, Whe = Mhe, Ghe = Nhe, Hhe = Lhe, Yhe = zhe, Xhe = Uhe, Vhe = (e, t, n, i) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
    case "":
    case "=":
    case "==":
      return qhe(e, n, i);
    case "!=":
      return Whe(e, n, i);
    case ">":
      return Ghe(e, n, i);
    case ">=":
      return Hhe(e, n, i);
    case "<":
      return Yhe(e, n, i);
    case "<=":
      return Xhe(e, n, i);
    default:
      throw new TypeError("Invalid operator: ".concat(t));
  }
}, Khe = Vhe, j1, oF;
function Jhe() {
  if (oF)
    return j1;
  oF = 1;
  var e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(c, f) {
      if (f = n(f), c instanceof t) {
        if (c.loose === !!f.loose)
          return c;
        c = c.value;
      }
      a("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, a("comp", this);
    }
    parse(c) {
      var f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR], d = c.match(f);
      if (!d)
        throw new TypeError("Invalid comparator: ".concat(c));
      this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new s(d[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(c) {
      if (a("Comparator.test", c, this.options.loose), this.semver === e || c === e)
        return !0;
      if (typeof c == "string")
        try {
          c = new s(c, this.options);
        } catch {
          return !1;
        }
      return o(c, this.operator, this.semver, this.options);
    }
    intersects(c, f) {
      if (!(c instanceof t))
        throw new TypeError("a Comparator is required");
      if ((!f || typeof f != "object") && (f = {
        loose: !!f,
        includePrerelease: !1
      }), this.operator === "")
        return this.value === "" ? !0 : new u(c.value, f).test(this.value);
      if (c.operator === "")
        return c.value === "" ? !0 : new u(this.value, f).test(c.semver);
      var d = (this.operator === ">=" || this.operator === ">") && (c.operator === ">=" || c.operator === ">"), h = (this.operator === "<=" || this.operator === "<") && (c.operator === "<=" || c.operator === "<"), p = this.semver.version === c.semver.version, g = (this.operator === ">=" || this.operator === "<=") && (c.operator === ">=" || c.operator === "<="), m = o(this.semver, "<", c.semver, f) && (this.operator === ">=" || this.operator === ">") && (c.operator === "<=" || c.operator === "<"), y = o(this.semver, ">", c.semver, f) && (this.operator === "<=" || this.operator === "<") && (c.operator === ">=" || c.operator === ">");
      return d || h || p && g || m || y;
    }
  }
  j1 = t;
  var n = O_, i = Ei.exports.re, r = Ei.exports.t, o = Khe, a = g0, s = D_, u = K4();
  return j1;
}
function aF(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = Qhe(e)) || t && e && typeof e.length == "number") {
      n && (e = n);
      var i = 0, r = function() {
      };
      return { s: r, n: function() {
        return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
      }, e: function(l) {
        throw l;
      }, f: r };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var o = !0, a = !1, s;
  return { s: function() {
    n = n.call(e);
  }, n: function() {
    var l = n.next();
    return o = l.done, l;
  }, e: function(l) {
    a = !0, s = l;
  }, f: function() {
    try {
      !o && n.return != null && n.return();
    } finally {
      if (a)
        throw s;
    }
  } };
}
function Qhe(e, t) {
  if (!!e) {
    if (typeof e == "string")
      return sF(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return sF(e, t);
  }
}
function sF(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, i = new Array(t); n < t; n++)
    i[n] = e[n];
  return i;
}
var U1, uF;
function K4() {
  if (uF)
    return U1;
  uF = 1;
  class e {
    constructor(M, F) {
      if (F = i(F), M instanceof e)
        return M.loose === !!F.loose && M.includePrerelease === !!F.includePrerelease ? M : new e(M.raw, F);
      if (M instanceof r)
        return this.raw = M.value, this.set = [[M]], this.format(), this;
      if (this.options = F, this.loose = !!F.loose, this.includePrerelease = !!F.includePrerelease, this.raw = M, this.set = M.split("||").map((L) => this.parseRange(L.trim())).filter((L) => L.length), !this.set.length)
        throw new TypeError("Invalid SemVer Range: ".concat(M));
      if (this.set.length > 1) {
        var O = this.set[0];
        if (this.set = this.set.filter((L) => !d(L[0])), this.set.length === 0)
          this.set = [O];
        else if (this.set.length > 1) {
          var k = aF(this.set), T;
          try {
            for (k.s(); !(T = k.n()).done; ) {
              var N = T.value;
              if (N.length === 1 && h(N[0])) {
                this.set = [N];
                break;
              }
            }
          } catch (L) {
            k.e(L);
          } finally {
            k.f();
          }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((M) => M.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(M) {
      M = M.trim();
      var F = Object.keys(this.options).join(","), O = "parseRange:".concat(F, ":").concat(M), k = n.get(O);
      if (k)
        return k;
      var T = this.options.loose, N = T ? s[u.HYPHENRANGELOOSE] : s[u.HYPHENRANGE];
      M = M.replace(N, C(this.options.includePrerelease)), o("hyphen replace", M), M = M.replace(s[u.COMPARATORTRIM], l), o("comparator trim", M), M = M.replace(s[u.TILDETRIM], c), M = M.replace(s[u.CARETTRIM], f), M = M.split(/\s+/).join(" ");
      var L = M.split(" ").map((ye) => g(ye, this.options)).join(" ").split(/\s+/).map((ye) => S(ye, this.options));
      T && (L = L.filter((ye) => (o("loose invalid filter", ye, this.options), !!ye.match(s[u.COMPARATORLOOSE])))), o("range list", L);
      var z = /* @__PURE__ */ new Map(), J = L.map((ye) => new r(ye, this.options)), le = aF(J), Ee;
      try {
        for (le.s(); !(Ee = le.n()).done; ) {
          var _e = Ee.value;
          if (d(_e))
            return [_e];
          z.set(_e.value, _e);
        }
      } catch (ye) {
        le.e(ye);
      } finally {
        le.f();
      }
      z.size > 1 && z.has("") && z.delete("");
      var Ue = [...z.values()];
      return n.set(O, Ue), Ue;
    }
    intersects(M, F) {
      if (!(M instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((O) => p(O, F) && M.set.some((k) => p(k, F) && O.every((T) => k.every((N) => T.intersects(N, F)))));
    }
    test(M) {
      if (!M)
        return !1;
      if (typeof M == "string")
        try {
          M = new a(M, this.options);
        } catch {
          return !1;
        }
      for (var F = 0; F < this.set.length; F++)
        if ($(this.set[F], M, this.options))
          return !0;
      return !1;
    }
  }
  U1 = e;
  var t = hhe, n = new t({
    max: 1e3
  }), i = O_, r = Jhe(), o = g0, a = D_, s = Ei.exports.re, u = Ei.exports.t, l = Ei.exports.comparatorTrimReplace, c = Ei.exports.tildeTrimReplace, f = Ei.exports.caretTrimReplace, d = (A) => A.value === "<0.0.0-0", h = (A) => A.value === "", p = (A, M) => {
    for (var F = !0, O = A.slice(), k = O.pop(); F && O.length; )
      F = O.every((T) => k.intersects(T, M)), k = O.pop();
    return F;
  }, g = (A, M) => (o("comp", A, M), A = b(A, M), o("caret", A), A = y(A, M), o("tildes", A), A = E(A, M), o("xrange", A), A = w(A, M), o("stars", A), A), m = (A) => !A || A.toLowerCase() === "x" || A === "*", y = (A, M) => A.trim().split(/\s+/).map((F) => v(F, M)).join(" "), v = (A, M) => {
    var F = M.loose ? s[u.TILDELOOSE] : s[u.TILDE];
    return A.replace(F, (O, k, T, N, L) => {
      o("tilde", A, O, k, T, N, L);
      var z;
      return m(k) ? z = "" : m(T) ? z = ">=".concat(k, ".0.0 <").concat(+k + 1, ".0.0-0") : m(N) ? z = ">=".concat(k, ".").concat(T, ".0 <").concat(k, ".").concat(+T + 1, ".0-0") : L ? (o("replaceTilde pr", L), z = ">=".concat(k, ".").concat(T, ".").concat(N, "-").concat(L, " <").concat(k, ".").concat(+T + 1, ".0-0")) : z = ">=".concat(k, ".").concat(T, ".").concat(N, " <").concat(k, ".").concat(+T + 1, ".0-0"), o("tilde return", z), z;
    });
  }, b = (A, M) => A.trim().split(/\s+/).map((F) => x(F, M)).join(" "), x = (A, M) => {
    o("caret", A, M);
    var F = M.loose ? s[u.CARETLOOSE] : s[u.CARET], O = M.includePrerelease ? "-0" : "";
    return A.replace(F, (k, T, N, L, z) => {
      o("caret", A, k, T, N, L, z);
      var J;
      return m(T) ? J = "" : m(N) ? J = ">=".concat(T, ".0.0").concat(O, " <").concat(+T + 1, ".0.0-0") : m(L) ? T === "0" ? J = ">=".concat(T, ".").concat(N, ".0").concat(O, " <").concat(T, ".").concat(+N + 1, ".0-0") : J = ">=".concat(T, ".").concat(N, ".0").concat(O, " <").concat(+T + 1, ".0.0-0") : z ? (o("replaceCaret pr", z), T === "0" ? N === "0" ? J = ">=".concat(T, ".").concat(N, ".").concat(L, "-").concat(z, " <").concat(T, ".").concat(N, ".").concat(+L + 1, "-0") : J = ">=".concat(T, ".").concat(N, ".").concat(L, "-").concat(z, " <").concat(T, ".").concat(+N + 1, ".0-0") : J = ">=".concat(T, ".").concat(N, ".").concat(L, "-").concat(z, " <").concat(+T + 1, ".0.0-0")) : (o("no pr"), T === "0" ? N === "0" ? J = ">=".concat(T, ".").concat(N, ".").concat(L).concat(O, " <").concat(T, ".").concat(N, ".").concat(+L + 1, "-0") : J = ">=".concat(T, ".").concat(N, ".").concat(L).concat(O, " <").concat(T, ".").concat(+N + 1, ".0-0") : J = ">=".concat(T, ".").concat(N, ".").concat(L, " <").concat(+T + 1, ".0.0-0")), o("caret return", J), J;
    });
  }, E = (A, M) => (o("replaceXRanges", A, M), A.split(/\s+/).map((F) => _(F, M)).join(" ")), _ = (A, M) => {
    A = A.trim();
    var F = M.loose ? s[u.XRANGELOOSE] : s[u.XRANGE];
    return A.replace(F, (O, k, T, N, L, z) => {
      o("xRange", A, O, k, T, N, L, z);
      var J = m(T), le = J || m(N), Ee = le || m(L), _e = Ee;
      return k === "=" && _e && (k = ""), z = M.includePrerelease ? "-0" : "", J ? k === ">" || k === "<" ? O = "<0.0.0-0" : O = "*" : k && _e ? (le && (N = 0), L = 0, k === ">" ? (k = ">=", le ? (T = +T + 1, N = 0, L = 0) : (N = +N + 1, L = 0)) : k === "<=" && (k = "<", le ? T = +T + 1 : N = +N + 1), k === "<" && (z = "-0"), O = "".concat(k + T, ".").concat(N, ".").concat(L).concat(z)) : le ? O = ">=".concat(T, ".0.0").concat(z, " <").concat(+T + 1, ".0.0-0") : Ee && (O = ">=".concat(T, ".").concat(N, ".0").concat(z, " <").concat(T, ".").concat(+N + 1, ".0-0")), o("xRange return", O), O;
    });
  }, w = (A, M) => (o("replaceStars", A, M), A.trim().replace(s[u.STAR], "")), S = (A, M) => (o("replaceGTE0", A, M), A.trim().replace(s[M.includePrerelease ? u.GTE0PRE : u.GTE0], "")), C = (A) => (M, F, O, k, T, N, L, z, J, le, Ee, _e, Ue) => (m(O) ? F = "" : m(k) ? F = ">=".concat(O, ".0.0").concat(A ? "-0" : "") : m(T) ? F = ">=".concat(O, ".").concat(k, ".0").concat(A ? "-0" : "") : N ? F = ">=".concat(F) : F = ">=".concat(F).concat(A ? "-0" : ""), m(J) ? z = "" : m(le) ? z = "<".concat(+J + 1, ".0.0-0") : m(Ee) ? z = "<".concat(J, ".").concat(+le + 1, ".0-0") : _e ? z = "<=".concat(J, ".").concat(le, ".").concat(Ee, "-").concat(_e) : A ? z = "<".concat(J, ".").concat(le, ".").concat(+Ee + 1, "-0") : z = "<=".concat(z), "".concat(F, " ").concat(z).trim()), $ = (A, M, F) => {
    for (var O = 0; O < A.length; O++)
      if (!A[O].test(M))
        return !1;
    if (M.prerelease.length && !F.includePrerelease) {
      for (var k = 0; k < A.length; k++)
        if (o(A[k].semver), A[k].semver !== r.ANY && A[k].semver.prerelease.length > 0) {
          var T = A[k].semver;
          if (T.major === M.major && T.minor === M.minor && T.patch === M.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return U1;
}
var Zhe = K4(), epe = (e, t, n) => {
  try {
    t = new Zhe(t, n);
  } catch {
    return !1;
  }
  return t.test(e);
}, J4 = epe;
function tpe(e, t, n) {
  var i = e.open(t), r = 1e4, o = 250, a = new URL(t), s = a.origin, u = ~~(r / o);
  function l(f) {
    f.source === i && (u = 0, e.removeEventListener("message", l, !1));
  }
  e.addEventListener("message", l, !1);
  function c() {
    u <= 0 || (i.postMessage(n, s), setTimeout(c, o), u -= 1);
  }
  setTimeout(c, o);
}
var npe = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
String.prototype.startsWith || (String.prototype.startsWith = function(e, t) {
  return this.substr(!t || t < 0 ? 0 : +t, e.length) === e;
});
function Q4(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  for (var r = 0, o = n; r < o.length; r++) {
    var a = o[r];
    ipe(e, a);
  }
  return e;
}
function ipe(e, t) {
  for (var n = 0, i = Object.keys(t); n < i.length; n++) {
    var r = i[n];
    cl(e, r, t[r], !0);
  }
}
var q1;
function rpe(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = ope(e)) || t && e && typeof e.length == "number") {
      n && (e = n);
      var i = 0, r = function() {
      };
      return { s: r, n: function() {
        return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
      }, e: function(l) {
        throw l;
      }, f: r };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var o = !0, a = !1, s;
  return { s: function() {
    n = n.call(e);
  }, n: function() {
    var l = n.next();
    return o = l.done, l;
  }, e: function(l) {
    a = !0, s = l;
  }, f: function() {
    try {
      !o && n.return != null && n.return();
    } finally {
      if (a)
        throw s;
    }
  } };
}
function ope(e, t) {
  if (!!e) {
    if (typeof e == "string")
      return lF(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return lF(e, t);
  }
}
function lF(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, i = new Array(t); n < t; n++)
    i[n] = e[n];
  return i;
}
function cF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Go(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cF(Object(n), !0).forEach(function(i) {
      Jde(e, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cF(Object(n)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return e;
}
var Ki = Bne, Ef = Hfe, th = typeof window < "u" ? window : void 0;
Ef === void 0 && th !== null && th !== void 0 && (q1 = th.vl) !== null && q1 !== void 0 && q1.compile && (Ef = th.vl);
var ape = {
  export: {
    svg: !0,
    png: !0
  },
  source: !0,
  compiled: !0,
  editor: !0
}, spe = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
}, Fc = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
}, lg = {
  vega: Ki.version,
  "vega-lite": Ef ? Ef.version : "not available"
}, upe = {
  vega: (e) => e,
  "vega-lite": (e, t) => Ef.compile(e, {
    config: t
  }).spec
}, lpe = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`, cpe = "chart-wrapper";
function fpe(e) {
  return typeof e == "function";
}
function fF(e, t, n, i) {
  var r = "<html><head>".concat(t, '</head><body><pre><code class="json">'), o = "</code></pre>".concat(n, "</body></html>"), a = window.open("");
  a.document.write(r + e + o), a.document.title = "".concat(Fc[i], " JSON Source");
}
function dpe(e, t) {
  if (e.$schema) {
    var n = P4(e.$schema);
    if (t && t !== n.library) {
      var i;
      console.warn("The given visualization spec is written in ".concat(Fc[n.library], ", but mode argument sets ").concat((i = Fc[t]) !== null && i !== void 0 ? i : t, "."));
    }
    var r = n.library;
    return J4(lg[r], "^".concat(n.version.slice(1))) || console.warn("The input spec uses ".concat(Fc[r], " ").concat(n.version, ", but the current version of ").concat(Fc[r], " is v").concat(lg[r], ".")), r;
  }
  return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t != null ? t : "vega";
}
function hpe(e) {
  return !!(e && "load" in e);
}
function dF(e) {
  return hpe(e) ? e : Ki.loader(e);
}
function ppe(e) {
  var t, n, i = (t = (n = e.usermeta) === null || n === void 0 ? void 0 : n.embedOptions) !== null && t !== void 0 ? t : {};
  return Y(i.defaultStyle) && (i.defaultStyle = !1), i;
}
function gpe(e, t) {
  return nb.apply(this, arguments);
}
function nb() {
  return nb = ag(/* @__PURE__ */ ar.mark(function e(t, n) {
    var i, r, o, a, s, u, l, c, f, d, h, p = arguments;
    return ar.wrap(function(m) {
      for (; ; )
        switch (m.prev = m.next) {
          case 0:
            if (o = p.length > 2 && p[2] !== void 0 ? p[2] : {}, !Y(n)) {
              m.next = 10;
              break;
            }
            return s = dF(o.loader), m.t0 = JSON, m.next = 6, s.load(n);
          case 6:
            m.t1 = m.sent, a = m.t0.parse.call(m.t0, m.t1), m.next = 11;
            break;
          case 10:
            a = n;
          case 11:
            return u = ppe(a), l = u.loader, (!s || l) && (s = dF((c = o.loader) !== null && c !== void 0 ? c : l)), m.next = 16, hF(u, s);
          case 16:
            return f = m.sent, m.next = 19, hF(o, s);
          case 19:
            return d = m.sent, h = Go(Go({}, Q4(d, f)), {}, {
              config: ll((i = d.config) !== null && i !== void 0 ? i : {}, (r = f.config) !== null && r !== void 0 ? r : {})
            }), m.next = 23, ype(t, a, h, s);
          case 23:
            return m.abrupt("return", m.sent);
          case 24:
          case "end":
            return m.stop();
        }
    }, e);
  })), nb.apply(this, arguments);
}
function hF(e, t) {
  return ib.apply(this, arguments);
}
function ib() {
  return ib = ag(/* @__PURE__ */ ar.mark(function e(t, n) {
    var i, r, o;
    return ar.wrap(function(s) {
      for (; ; )
        switch (s.prev = s.next) {
          case 0:
            if (!Y(t.config)) {
              s.next = 8;
              break;
            }
            return s.t1 = JSON, s.next = 4, n.load(t.config);
          case 4:
            s.t2 = s.sent, s.t0 = s.t1.parse.call(s.t1, s.t2), s.next = 9;
            break;
          case 8:
            s.t0 = (i = t.config) !== null && i !== void 0 ? i : {};
          case 9:
            if (r = s.t0, !Y(t.patch)) {
              s.next = 18;
              break;
            }
            return s.t4 = JSON, s.next = 14, n.load(t.patch);
          case 14:
            s.t5 = s.sent, s.t3 = s.t4.parse.call(s.t4, s.t5), s.next = 19;
            break;
          case 18:
            s.t3 = t.patch;
          case 19:
            return o = s.t3, s.abrupt("return", Go(Go(Go({}, t), o ? {
              patch: o
            } : {}), r ? {
              config: r
            } : {}));
          case 21:
          case "end":
            return s.stop();
        }
    }, e);
  })), ib.apply(this, arguments);
}
function mpe(e) {
  var t, n = e.getRootNode ? e.getRootNode() : document;
  return n instanceof ShadowRoot ? {
    root: n,
    rootContainer: n
  } : {
    root: document,
    rootContainer: (t = document.head) !== null && t !== void 0 ? t : document.body
  };
}
function ype(e, t) {
  return rb.apply(this, arguments);
}
function rb() {
  return rb = ag(/* @__PURE__ */ ar.mark(function e(t, n) {
    var i, r, o, a, s, u, l, c, f, d, h, p, g, m, y, v, b, x, E, _, w, S, C, $, A, M, F, O, k, T, N, L, z, J, le, Ee, _e, Ue, ye, Mt, Gi, Ht, V, ue, de, j, He, ve, rt, Xe, Tn, Hi = arguments;
    return ar.wrap(function(Ws) {
      for (; ; )
        switch (Ws.prev = Ws.next) {
          case 0:
            if (Tn = function() {
              Ue && document.removeEventListener("click", Ue), L.finalize();
            }, c = Hi.length > 2 && Hi[2] !== void 0 ? Hi[2] : {}, f = Hi.length > 3 ? Hi[3] : void 0, d = c.theme ? ll(jde[c.theme], (i = c.config) !== null && i !== void 0 ? i : {}) : c.config, h = ua(c.actions) ? c.actions : Q4({}, ape, (r = c.actions) !== null && r !== void 0 ? r : {}), p = Go(Go({}, spe), c.i18n), g = (o = c.renderer) !== null && o !== void 0 ? o : "canvas", m = (a = c.logLevel) !== null && a !== void 0 ? a : Ki.Warn, y = (s = c.downloadFileName) !== null && s !== void 0 ? s : "visualization", v = typeof t == "string" ? document.querySelector(t) : t, v) {
              Ws.next = 12;
              break;
            }
            throw new Error("".concat(t, " does not exist"));
          case 12:
            if (c.defaultStyle !== !1 && (b = "vega-embed-style", x = mpe(v), E = x.root, _ = x.rootContainer, E.getElementById(b) || (w = document.createElement("style"), w.id = b, w.innerHTML = c.defaultStyle === void 0 || c.defaultStyle === !0 ? npe.toString() : c.defaultStyle, _.appendChild(w))), S = dpe(n, c.mode), C = upe[S](n, d), S === "vega-lite" && C.$schema && ($ = P4(C.$schema), J4(lg.vega, "^".concat($.version.slice(1))) || console.warn("The compiled spec uses Vega ".concat($.version, ", but current version is v").concat(lg.vega, "."))), v.classList.add("vega-embed"), h && v.classList.add("has-actions"), v.innerHTML = "", A = v, h && (M = document.createElement("div"), M.classList.add(cpe), v.appendChild(M), A = M), F = c.patch, F && (C = F instanceof Function ? F(C) : cg(C, F, !0, !1).newDocument), c.formatLocale && Ki.formatLocale(c.formatLocale), c.timeFormatLocale && Ki.timeFormatLocale(c.timeFormatLocale), c.expressionFunctions)
              for (O in c.expressionFunctions)
                k = c.expressionFunctions[O], "fn" in k ? Ki.expressionFunction(O, k.fn, k.visitor) : k instanceof Function && Ki.expressionFunction(O, k);
            return T = c.ast, N = Ki.parse(C, S === "vega-lite" ? {} : d, {
              ast: T
            }), L = new (c.viewClass || Ki.View)(N, Go({
              loader: f,
              logLevel: m,
              renderer: g
            }, T ? {
              expr: (u = (l = Ki.expressionInterpreter) !== null && l !== void 0 ? l : c.expr) !== null && u !== void 0 ? u : Kne
            } : {})), L.addSignalListener("autosize", (Gn, cn) => {
              var On = cn.type;
              On == "fit-x" ? (A.classList.add("fit-x"), A.classList.remove("fit-y")) : On == "fit-y" ? (A.classList.remove("fit-x"), A.classList.add("fit-y")) : On == "fit" ? A.classList.add("fit-x", "fit-y") : A.classList.remove("fit-x", "fit-y");
            }), c.tooltip !== !1 && (z = fpe(c.tooltip) ? c.tooltip : new Kde(c.tooltip === !0 ? {} : c.tooltip).call, L.tooltip(z)), J = c.hover, J === void 0 && (J = S === "vega"), J && (le = typeof J == "boolean" ? {} : J, Ee = le.hoverSet, _e = le.updateSet, L.hover(Ee, _e)), c && (c.width != null && L.width(c.width), c.height != null && L.height(c.height), c.padding != null && L.padding(c.padding)), Ws.next = 37, L.initialize(A, c.bind).runAsync();
          case 37:
            if (h !== !1) {
              if (ye = v, c.defaultStyle !== !1 && (Mt = document.createElement("details"), Mt.title = p.CLICK_TO_VIEW_ACTIONS, v.append(Mt), ye = Mt, Gi = document.createElement("summary"), Gi.innerHTML = lpe, Mt.append(Gi), Ue = (Gn) => {
                Mt.contains(Gn.target) || Mt.removeAttribute("open");
              }, document.addEventListener("click", Ue)), Ht = document.createElement("div"), ye.append(Ht), Ht.classList.add("vega-actions"), h === !0 || h.export !== !1) {
                V = rpe(["svg", "png"]);
                try {
                  for (de = function() {
                    var cn = ue.value;
                    if (h === !0 || h.export === !0 || h.export[cn]) {
                      var On = p["".concat(cn.toUpperCase(), "_ACTION")], Gs = document.createElement("a");
                      Gs.text = On, Gs.href = "#", Gs.target = "_blank", Gs.download = "".concat(y, ".").concat(cn), Gs.addEventListener("mousedown", /* @__PURE__ */ function() {
                        var Z4 = ag(/* @__PURE__ */ ar.mark(function R_(eI) {
                          var L_;
                          return ar.wrap(function(Dl) {
                            for (; ; )
                              switch (Dl.prev = Dl.next) {
                                case 0:
                                  return eI.preventDefault(), Dl.next = 3, L.toImageURL(cn, c.scaleFactor);
                                case 3:
                                  L_ = Dl.sent, this.href = L_;
                                case 5:
                                case "end":
                                  return Dl.stop();
                              }
                          }, R_, this);
                        }));
                        return function(R_) {
                          return Z4.apply(this, arguments);
                        };
                      }()), Ht.append(Gs);
                    }
                  }, V.s(); !(ue = V.n()).done; )
                    de();
                } catch (Gn) {
                  V.e(Gn);
                } finally {
                  V.f();
                }
              }
              (h === !0 || h.source !== !1) && (j = document.createElement("a"), j.text = p.SOURCE_ACTION, j.href = "#", j.addEventListener("click", function(Gn) {
                var cn, On;
                fF(m0(n), (cn = c.sourceHeader) !== null && cn !== void 0 ? cn : "", (On = c.sourceFooter) !== null && On !== void 0 ? On : "", S), Gn.preventDefault();
              }), Ht.append(j)), S === "vega-lite" && (h === !0 || h.compiled !== !1) && (He = document.createElement("a"), He.text = p.COMPILED_ACTION, He.href = "#", He.addEventListener("click", function(Gn) {
                var cn, On;
                fF(m0(C), (cn = c.sourceHeader) !== null && cn !== void 0 ? cn : "", (On = c.sourceFooter) !== null && On !== void 0 ? On : "", "vega"), Gn.preventDefault();
              }), Ht.append(He)), (h === !0 || h.editor !== !1) && (rt = (ve = c.editorUrl) !== null && ve !== void 0 ? ve : "https://vega.github.io/editor/", Xe = document.createElement("a"), Xe.text = p.EDITOR_ACTION, Xe.href = "#", Xe.addEventListener("click", function(Gn) {
                tpe(window, rt, {
                  config: d,
                  mode: S,
                  renderer: g,
                  spec: m0(n)
                }), Gn.preventDefault();
              }), Ht.append(Xe));
            }
            return Ws.abrupt("return", {
              view: L,
              spec: n,
              vgSpec: C,
              finalize: Tn,
              embedOptions: c
            });
          case 39:
          case "end":
            return Ws.stop();
        }
    }, e);
  })), rb.apply(this, arguments);
}
const ige = /* @__PURE__ */ tI({
  __name: "Vega",
  props: {
    plotJson: null,
    responsive: { type: Boolean },
    singleBlockEmbed: { type: Boolean }
  },
  setup(e) {
    const t = e, n = `vega_${uI()}`, i = nI(), r = (s) => {
      s.width = "container", t.singleBlockEmbed && (s.height = "container");
    }, o = () => {
      const s = document.getElementById(n), u = s && s.querySelector(".vega-bindings"), l = s && s.querySelector("canvas");
      l && u && (l.style.height = `${l.offsetHeight - u.offsetHeight}px`);
    }, a = async () => {
      try {
        t.responsive && r(t.plotJson);
        const s = await gpe(`#${n}`, t.plotJson, {
          mode: "vega-lite",
          actions: !1
        });
        i.value = s, t.singleBlockEmbed && o();
      } catch (s) {
        console.error("An error occurred while rendering an Altair chart: ", s);
      }
    };
    return iI(() => {
      a();
    }), rI(() => {
      var s;
      return void ((s = i.value) == null ? void 0 : s.finalize());
    }), (s, u) => (oI(), aI("div", {
      class: I_([
        "justify-center bg-white flex",
        { "w-full": t.responsive, "h-iframe": e.singleBlockEmbed }
      ])
    }, [
      sI("div", {
        id: n,
        class: I_({ "w-full": t.responsive, "h-iframe": e.singleBlockEmbed }),
        "data-cy": "block-vega"
      }, null, 2)
    ], 2));
  }
});
export {
  ige as default
};
